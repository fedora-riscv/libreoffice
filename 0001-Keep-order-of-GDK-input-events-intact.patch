From 6ddfa506483d720e326f51f58ff75b65b9363462 Mon Sep 17 00:00:00 2001
From: Stephan Bergmann <sbergman@redhat.com>
Date: Thu, 14 May 2020 14:47:21 +0200
Subject: [PATCH] Keep order of GDK input events intact

As explained at <https://bugzilla.redhat.com/show_bug.cgi?id=1377293#c12>
"[Wayland] When typing fast at high CPU load, LibreOffice breaks key (letter)
order":  "with a local LO master --with-lang=ALL ASan+UBSan build (i.e., which
executes somewhat slowly):  When typing 'file' in Writer right after it started
up (but no longer after more typing), that gets garbled as 'fiel'."  The reason
for that (but probably not for the original issue reported in that rhbz#1377293)
apparently was:

Two GDK_KEY_PRESS events (A and B) were in the GTK event queue.
GtkInstance::AnyInput consumed only A, because it broke from the first while
loop as soon as it saw the first event of appropriate type.  In the second while
loop it put A back on the end of the GTK event loop, so that it now followed B.
GtkSalFrame::signalKey (vcl/unx/gtk3/gtk3gtkframe.cxx) thus received the events
in the wrong order.

Dropping the "break" also reveals that GtkInstance::AnyInput should obviously
use a queue (i.e., deque) rather than a stack to hold the events it consumed and
needs to re-enqueue.

This appears to be a regression introduced with
658954e8b50fc264428402dc5a95b0d6f690d191 "Resolves: fdo#48011 writer
idle-callbacks are halting when events pending".

Change-Id: I87d601df118a20ea3dd59e9cebbcf5176db04be8
---
 vcl/unx/gtk/gtkinst.cxx | 9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)

diff --git a/vcl/unx/gtk/gtkinst.cxx b/vcl/unx/gtk/gtkinst.cxx
index 02ed688f366b..744c66b0baf0 100644
--- a/vcl/unx/gtk/gtkinst.cxx
+++ b/vcl/unx/gtk/gtkinst.cxx
@@ -427,25 +427,24 @@ bool GtkInstance::AnyInput( VclInputFlags nType )
         return true;
 
     bool bRet = false;
-    std::stack<GdkEvent*> aEvents;
+    std::deque<GdkEvent*> aEvents;
     GdkEvent *pEvent = nullptr;
     while ((pEvent = gdk_event_get()))
     {
-        aEvents.push(pEvent);
+        aEvents.push_back(pEvent);
         VclInputFlags nEventType = categorizeEvent(pEvent);
         if ( (nEventType & nType) || ( nEventType == VclInputFlags::NONE && (nType & VclInputFlags::OTHER) ) )
         {
             bRet = true;
-            break;
         }
     }
 
     while (!aEvents.empty())
     {
-        pEvent = aEvents.top();
+        pEvent = aEvents.front();
         gdk_event_put(pEvent);
         gdk_event_free(pEvent);
-        aEvents.pop();
+        aEvents.pop_front();
     }
 #endif
     return bRet;
-- 
2.25.4

