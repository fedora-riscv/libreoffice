From 91e881d3b4113c94650682b7d850b322a2866628 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Caol=C3=A1n=20McNamara?= <caolanm@redhat.com>
Date: Thu, 23 Jun 2016 17:32:11 +0100
Subject: [PATCH] Resolves: rhbz#1349501 gtk3: smooth scrolling events can be
 disabled...

by the user with GDK_CORE_DEVICE_EVENTS=1, and so manage to disable their wheel
scrolling

(cherry picked from commit 7dfd50f947671d79b9119f10259857700d5728d8)

Change-Id: I7df63f738983c90dea75b9f43a36133910446aba
---
 vcl/inc/unx/gtk/gtkframe.hxx  |   3 +-
 vcl/unx/gtk/gtksalframe.cxx   |   3 +-
 vcl/unx/gtk3/gtk3gtkframe.cxx | 120 +++++++++++++++++++++++++++++-------------
 3 files changed, 85 insertions(+), 41 deletions(-)

diff --git a/vcl/inc/unx/gtk/gtkframe.hxx b/vcl/inc/unx/gtk/gtkframe.hxx
index eaa222f..f4d2f38 100644
--- a/vcl/inc/unx/gtk/gtkframe.hxx
+++ b/vcl/inc/unx/gtk/gtkframe.hxx
@@ -210,6 +210,7 @@ class GtkSalFrame : public SalFrame
 #if GTK_CHECK_VERSION(3,0,0)
     OUString                        m_aTooltip;
     Rectangle                       m_aHelpArea;
+    guint32                         m_nLastScrollEventTime;
     long                            m_nWidthRequest;
     long                            m_nHeightRequest;
     cairo_region_t*                 m_pRegion;
@@ -277,7 +278,7 @@ class GtkSalFrame : public SalFrame
     static gboolean     signalKey( GtkWidget*, GdkEventKey*, gpointer );
     static gboolean     signalDelete( GtkWidget*, GdkEvent*, gpointer );
     static gboolean     signalWindowState( GtkWidget*, GdkEvent*, gpointer );
-    static gboolean     signalScroll( GtkWidget*, GdkEvent*, gpointer );
+    static gboolean     signalScroll( GtkWidget*, GdkEventScroll* pEvent, gpointer );
     static gboolean     signalCrossing( GtkWidget*, GdkEventCrossing*, gpointer );
     static gboolean     signalVisibility( GtkWidget*, GdkEventVisibility*, gpointer );
     static void         signalDestroy( GtkWidget*, gpointer );
diff --git a/vcl/unx/gtk/gtksalframe.cxx b/vcl/unx/gtk/gtksalframe.cxx
index 95fd581..84615c8 100644
--- a/vcl/unx/gtk/gtksalframe.cxx
+++ b/vcl/unx/gtk/gtksalframe.cxx
@@ -2855,10 +2855,9 @@ gboolean GtkSalFrame::signalButton( GtkWidget*, GdkEventButton* pEvent, gpointer
     return true;
 }
 
-gboolean GtkSalFrame::signalScroll( GtkWidget*, GdkEvent* pEvent, gpointer frame )
+gboolean GtkSalFrame::signalScroll( GtkWidget*, GdkEventScroll* pSEvent, gpointer frame )
 {
     GtkSalFrame* pThis = static_cast<GtkSalFrame*>(frame);
-    GdkEventScroll* pSEvent = reinterpret_cast<GdkEventScroll*>(pEvent);
 
     static sal_uLong        nLines = 0;
     if( ! nLines )
diff --git a/vcl/unx/gtk3/gtk3gtkframe.cxx b/vcl/unx/gtk3/gtk3gtkframe.cxx
index 6363815..6b006cc 100644
--- a/vcl/unx/gtk3/gtk3gtkframe.cxx
+++ b/vcl/unx/gtk3/gtk3gtkframe.cxx
@@ -1077,6 +1077,7 @@ void GtkSalFrame::InitCommon()
     m_bSpanMonitorsWhenFullscreen = false;
     m_nState            = GDK_WINDOW_STATE_WITHDRAWN;
     m_nVisibility       = GDK_VISIBILITY_FULLY_OBSCURED;
+    m_nLastScrollEventTime = GDK_CURRENT_TIME;
     m_bSendModChangeOnRelease = false;
     m_pIMHandler        = nullptr;
     m_hBackgroundPixmap = None;
@@ -2559,54 +2560,97 @@ gboolean GtkSalFrame::signalButton( GtkWidget*, GdkEventButton* pEvent, gpointer
     return true;
 }
 
-gboolean GtkSalFrame::signalScroll( GtkWidget*, GdkEvent* pEvent, gpointer frame )
+gboolean GtkSalFrame::signalScroll( GtkWidget*, GdkEventScroll* pEvent, gpointer frame )
 {
-    GdkEventScroll* pSEvent = reinterpret_cast<GdkEventScroll*>(pEvent);
-    if (pSEvent->direction != GDK_SCROLL_SMOOTH)
-        return false;
-
     GtkSalFrame* pThis = static_cast<GtkSalFrame*>(frame);
 
+    // gnome#726878 check for duplicate legacy scroll event
+    if (pEvent->direction != GDK_SCROLL_SMOOTH &&
+        pThis->m_nLastScrollEventTime == pEvent->time)
+    {
+        return false;
+    }
+
     SalWheelMouseEvent aEvent;
 
-    aEvent.mnTime = pSEvent->time;
-    aEvent.mnX = (sal_uLong)pSEvent->x;
+    aEvent.mnTime = pEvent->time;
+    aEvent.mnX = (sal_uLong)pEvent->x;
     // --- RTL --- (mirror mouse pos)
     if (AllSettings::GetLayoutRTL())
         aEvent.mnX = pThis->maGeometry.nWidth - 1 - aEvent.mnX;
-    aEvent.mnY = (sal_uLong)pSEvent->y;
-    aEvent.mnCode = GetMouseModCode( pSEvent->state );
-
-    // rhbz#1344042 "Traditionally" in gtk3 we tool a single up/down event as
-    // equating to 3 scroll lines and a delta of 120. So scale the delta here
-    // by 120 where a single mouse wheel click is an incoming delta_x of 1
-    // and divide that by 40 to get the number of scrollines
-    if (pSEvent->delta_x != 0.0)
-    {
-        aEvent.mnDelta = -pSEvent->delta_x * 120;
-        aEvent.mnNotchDelta = aEvent.mnDelta < 0 ? -1 : +1;
-        if (aEvent.mnDelta == 0)
-            aEvent.mnDelta = aEvent.mnNotchDelta;
-        aEvent.mbHorz = true;
-        aEvent.mnScrollLines = std::abs(aEvent.mnDelta) / 40;
-        if (aEvent.mnScrollLines == 0)
-            aEvent.mnScrollLines = 1;
-
-        pThis->CallCallback(SALEVENT_WHEELMOUSE, &aEvent);
-    }
+    aEvent.mnY = (sal_uLong)pEvent->y;
+    aEvent.mnCode = GetMouseModCode( pEvent->state );
 
-    if (pSEvent->delta_y != 0.0)
+    switch (pEvent->direction)
     {
-        aEvent.mnDelta = -pSEvent->delta_y * 120;
-        aEvent.mnNotchDelta = aEvent.mnDelta < 0 ? -1 : +1;
-        if (aEvent.mnDelta == 0)
-            aEvent.mnDelta = aEvent.mnNotchDelta;
-        aEvent.mbHorz = false;
-        aEvent.mnScrollLines = std::abs(aEvent.mnDelta) / 40;
-        if (aEvent.mnScrollLines == 0)
-            aEvent.mnScrollLines = 1;
-
-        pThis->CallCallback(SALEVENT_WHEELMOUSE, &aEvent);
+        case GDK_SCROLL_SMOOTH:
+            pThis->m_nLastScrollEventTime = pEvent->time;
+
+            // rhbz#1344042 "Traditionally" in gtk3 we tool a single up/down event as
+            // equating to 3 scroll lines and a delta of 120. So scale the delta here
+            // by 120 where a single mouse wheel click is an incoming delta_x of 1
+            // and divide that by 40 to get the number of scrollines
+            if (pEvent->delta_x != 0.0)
+            {
+                aEvent.mnDelta = -pEvent->delta_x * 120;
+                aEvent.mnNotchDelta = aEvent.mnDelta < 0 ? -1 : +1;
+                if (aEvent.mnDelta == 0)
+                    aEvent.mnDelta = aEvent.mnNotchDelta;
+                aEvent.mbHorz = true;
+                aEvent.mnScrollLines = std::abs(aEvent.mnDelta) / 40;
+                if (aEvent.mnScrollLines == 0)
+                    aEvent.mnScrollLines = 1;
+
+                pThis->CallCallback(SALEVENT_WHEELMOUSE, &aEvent);
+            }
+
+            if (pEvent->delta_y != 0.0)
+            {
+                aEvent.mnDelta = -pEvent->delta_y * 120;
+                aEvent.mnNotchDelta = aEvent.mnDelta < 0 ? -1 : +1;
+                if (aEvent.mnDelta == 0)
+                    aEvent.mnDelta = aEvent.mnNotchDelta;
+                aEvent.mbHorz = false;
+                aEvent.mnScrollLines = std::abs(aEvent.mnDelta) / 40;
+                if (aEvent.mnScrollLines == 0)
+                    aEvent.mnScrollLines = 1;
+
+                pThis->CallCallback(SALEVENT_WHEELMOUSE, &aEvent);
+            }
+
+            break;
+
+        case GDK_SCROLL_UP:
+            aEvent.mnDelta = 120;
+            aEvent.mnNotchDelta = 1;
+            aEvent.mnScrollLines = 3;
+            aEvent.mbHorz = false;
+            pThis->CallCallback(SALEVENT_WHEELMOUSE, &aEvent);
+            break;
+
+        case GDK_SCROLL_DOWN:
+            aEvent.mnDelta = -120;
+            aEvent.mnNotchDelta = -1;
+            aEvent.mnScrollLines = 3;
+            aEvent.mbHorz = false;
+            pThis->CallCallback(SALEVENT_WHEELMOUSE, &aEvent);
+            break;
+
+        case GDK_SCROLL_LEFT:
+            aEvent.mnDelta = 120;
+            aEvent.mnNotchDelta = 1;
+            aEvent.mnScrollLines = 3;
+            aEvent.mbHorz = true;
+            pThis->CallCallback(SALEVENT_WHEELMOUSE, &aEvent);
+            break;
+
+        case GDK_SCROLL_RIGHT:
+            aEvent.mnDelta = -120;
+            aEvent.mnNotchDelta = -1;
+            aEvent.mnScrollLines = 3;
+            aEvent.mbHorz = true;
+            pThis->CallCallback(SALEVENT_WHEELMOUSE, &aEvent);
+            break;
     }
 
     return true;
-- 
2.7.4

