From 19e1876935e6e14e73c8605a381eca6314357181 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Caol=C3=A1n=20McNamara?= <caolanm@redhat.com>
Date: Thu, 10 Nov 2016 13:20:34 +0000
Subject: [PATCH] Resolves: rhbz#1391418 wayland toolbars can't be docked after
 undocking

see gnome#768128 for extra details

under wayland, given the misery here I'm going to just disable toggling between
docked and undocked under wayland, and throw away user config on toggling
docked/undocked away from the defaults. You can still drag docked things around
to new docking position, but you can't pull them out of the dock to float.

non-wayland is unaffected

Change-Id: Iaa859f3420e6d1b103a8b93d1ad8f82dbffe75d4
---
 framework/source/layoutmanager/layoutmanager.cxx |  4 ++++
 include/vcl/settings.hxx                         |  2 ++
 sfx2/source/dialog/dockwin.cxx                   |  4 +++-
 vcl/inc/svdata.hxx                               |  4 ++++
 vcl/source/app/settings.cxx                      |  7 +++++++
 vcl/source/app/svdata.cxx                        |  1 +
 vcl/source/window/dockmgr.cxx                    |  3 +++
 vcl/source/window/dockwin.cxx                    |  9 +++++++--
 vcl/source/window/event.cxx                      | 10 ++++++----
 vcl/unx/gtk3/gtk3salnativewidgets-gtk.cxx        | 12 +++++++++++-
 10 files changed, 48 insertions(+), 8 deletions(-)

diff --git a/framework/source/layoutmanager/layoutmanager.cxx b/framework/source/layoutmanager/layoutmanager.cxx
index 2ade77e..46079eb 100644
--- a/framework/source/layoutmanager/layoutmanager.cxx
+++ b/framework/source/layoutmanager/layoutmanager.cxx
@@ -615,6 +615,10 @@ bool LayoutManager::readWindowStateData( const OUString& aName, UIElement& rElem
                 }
             }
 
+            const bool bDockingSupportCrippled = !StyleSettings::GetDockingFloatsSupported();
+            if (bDockingSupportCrippled)
+                rElementData.m_bFloating = false;
+
             return true;
         }
         catch (const NoSuchElementException&)
diff --git a/include/vcl/settings.hxx b/include/vcl/settings.hxx
index acbacf3..815e9f7 100644
--- a/include/vcl/settings.hxx
+++ b/include/vcl/settings.hxx
@@ -525,6 +525,8 @@ public:
     void                            SetAutoMnemonic( bool bAutoMnemonic );
     bool                            GetAutoMnemonic() const;
 
+    static bool                     GetDockingFloatsSupported();
+
     void                            SetFontColor( const Color& rColor );
     const Color&                    GetFontColor() const;
 
diff --git a/sfx2/source/dialog/dockwin.cxx b/sfx2/source/dialog/dockwin.cxx
index 25c72d8..0b45e7e 100644
--- a/sfx2/source/dialog/dockwin.cxx
+++ b/sfx2/source/dialog/dockwin.cxx
@@ -929,7 +929,9 @@ void SfxDockingWindow::Initialize(SfxChildWinInfo *pInfo)
 
             // check for valid alignment
             SfxChildAlignment eLocalAlignment = (SfxChildAlignment) (sal_uInt16) aStr.toInt32();
-            if ( pImpl->bDockingPrevented )
+            bool bIgnoreFloatConfig = (eLocalAlignment == SfxChildAlignment::NOALIGNMENT &&
+                                       !StyleSettings::GetDockingFloatsSupported());
+            if (pImpl->bDockingPrevented || bIgnoreFloatConfig)
                 // docking prevented, ignore old configuration and take alignment from default
                 aStr.clear();
             else
diff --git a/vcl/inc/svdata.hxx b/vcl/inc/svdata.hxx
index 39b5610..f348f84 100644
--- a/vcl/inc/svdata.hxx
+++ b/vcl/inc/svdata.hxx
@@ -280,6 +280,10 @@ struct ImplSVNWFData
     bool                    mbDDListBoxNoTextArea:1;
     bool                    mbEnableAccel:1;                // whether or not accelerators are shown
     bool                    mbAutoAccel:1;                  // whether accelerators are only shown when Alt is held down
+    // gnome#768128 I cannot see a route under wayland at present to support
+    // floating toolbars that can be redocked because there's no way to track
+    // that the toolbar is over a dockable area.
+    bool                    mbCanDetermineWindowPosition:1;
 };
 
 struct BlendFrameCache
diff --git a/vcl/source/app/settings.cxx b/vcl/source/app/settings.cxx
index cb84dbe..9ef9fd2 100644
--- a/vcl/source/app/settings.cxx
+++ b/vcl/source/app/settings.cxx
@@ -1931,6 +1931,13 @@ StyleSettings::GetAutoMnemonic() const
     return mxData->mbAutoMnemonic;
 }
 
+bool
+StyleSettings::GetDockingFloatsSupported()
+{
+    ImplSVData* pSVData = ImplGetSVData();
+    return pSVData->maNWFData.mbDockingFloatsSupported;
+}
+
 void
 StyleSettings::SetFontColor( const Color& rColor )
 {
diff --git a/vcl/source/app/svdata.cxx b/vcl/source/app/svdata.cxx
index ddad3e3..d050e0b 100644
--- a/vcl/source/app/svdata.cxx
+++ b/vcl/source/app/svdata.cxx
@@ -87,6 +87,7 @@ ImplSVData::ImplSVData()
     maNWFData.maMenuBarHighlightTextColor = Color( COL_TRANSPARENT );
     maNWFData.mbEnableAccel = true;
     maNWFData.mbAutoAccel = false;
+    maNWFData.mbCanDetermineWindowPosition = true;
 }
 
 ImplSVGDIData::~ImplSVGDIData()
diff --git a/vcl/source/window/dockmgr.cxx b/vcl/source/window/dockmgr.cxx
index 1b8ef13..d292553 100644
--- a/vcl/source/window/dockmgr.cxx
+++ b/vcl/source/window/dockmgr.cxx
@@ -992,6 +992,9 @@ void ImplDockingWindowWrapper::EndDocking( const Rectangle& rRect, bool bFloatMo
 {
     Rectangle aRect( rRect );
 
+    if (bFloatMode && !StyleSettings::GetDockingFloatsSupported())
+        mbDockCanceled = true;
+
     if ( !IsDockingCanceled() )
     {
         bool bShow = false;
diff --git a/vcl/source/window/dockwin.cxx b/vcl/source/window/dockwin.cxx
index 984d713..c3b2952 100644
--- a/vcl/source/window/dockwin.cxx
+++ b/vcl/source/window/dockwin.cxx
@@ -612,12 +612,14 @@ bool DockingWindow::Notify( NotifyEvent& rNEvt )
 
     if ( mbDockable )
     {
+        const bool bDockingSupportCrippled = !StyleSettings::GetDockingFloatsSupported();
+
         if ( rNEvt.GetType() == MouseNotifyEvent::MOUSEBUTTONDOWN )
         {
             const MouseEvent* pMEvt = rNEvt.GetMouseEvent();
             if ( pMEvt->IsLeft() )
             {
-                if ( pMEvt->IsMod1() && (pMEvt->GetClicks() == 2) )
+                if (!bDockingSupportCrippled && pMEvt->IsMod1() && (pMEvt->GetClicks() == 2) )
                 {
                     SetFloatingMode( !IsFloatingMode() );
                     return true;
@@ -646,7 +648,7 @@ bool DockingWindow::Notify( NotifyEvent& rNEvt )
         {
             const vcl::KeyCode& rKey = rNEvt.GetKeyEvent()->GetKeyCode();
             if( rKey.GetCode() == KEY_F10 && rKey.GetModifier() &&
-                rKey.IsShift() && rKey.IsMod1() )
+                rKey.IsShift() && rKey.IsMod1() && !bDockingSupportCrippled )
             {
                 SetFloatingMode( !IsFloatingMode() );
                 return true;
@@ -669,6 +671,9 @@ bool DockingWindow::Docking( const Point&, Rectangle& )
 
 void DockingWindow::EndDocking( const Rectangle& rRect, bool bFloatMode )
 {
+    if (bFloatMode && !StyleSettings::GetDockingFloatsSupported())
+        mbDockCanceled = true;
+
     if ( !IsDockingCanceled() )
     {
         bool bShow = false;
diff --git a/vcl/source/window/event.cxx b/vcl/source/window/event.cxx
index aa09c10..74abb18 100644
--- a/vcl/source/window/event.cxx
+++ b/vcl/source/window/event.cxx
@@ -101,15 +101,17 @@ bool Window::Notify( NotifyEvent& rNEvt )
     // check for docking window
     // but do nothing if window is docked and locked
     ImplDockingWindowWrapper *pWrapper = ImplGetDockingManager()->GetDockingWindowWrapper( this );
-    if( pWrapper && !( !pWrapper->IsFloatingMode() && pWrapper->IsLocked() ) )
+    if (pWrapper && !( !pWrapper->IsFloatingMode() && pWrapper->IsLocked() ))
     {
+        const bool bDockingSupportCrippled = !StyleSettings::GetDockingFloatsSupported();
+
         if ( rNEvt.GetType() == MouseNotifyEvent::MOUSEBUTTONDOWN )
         {
             const MouseEvent* pMEvt = rNEvt.GetMouseEvent();
             bool bHit = pWrapper->GetDragArea().IsInside( pMEvt->GetPosPixel() );
             if ( pMEvt->IsLeft() )
             {
-                if ( pMEvt->IsMod1() && (pMEvt->GetClicks() == 2) )
+                if (!bDockingSupportCrippled && pMEvt->IsMod1() && (pMEvt->GetClicks() == 2))
                 {
                     // ctrl double click toggles floating mode
                     pWrapper->SetFloatingMode( !pWrapper->IsFloatingMode() );
@@ -149,8 +151,8 @@ bool Window::Notify( NotifyEvent& rNEvt )
         else if( rNEvt.GetType() == MouseNotifyEvent::KEYINPUT )
         {
             const vcl::KeyCode& rKey = rNEvt.GetKeyEvent()->GetKeyCode();
-            if( rKey.GetCode() == KEY_F10 && rKey.GetModifier() &&
-                rKey.IsShift() && rKey.IsMod1() )
+            if (rKey.GetCode() == KEY_F10 && rKey.GetModifier() &&
+                rKey.IsShift() && rKey.IsMod1() && !bDockingSupportCrippled)
             {
                 pWrapper->SetFloatingMode( !pWrapper->IsFloatingMode() );
                 /* At this point the floating toolbar frame does not have the
diff --git a/vcl/unx/gtk3/gtk3salnativewidgets-gtk.cxx b/vcl/unx/gtk3/gtk3salnativewidgets-gtk.cxx
index 0365c52..091a615 100644
--- a/vcl/unx/gtk3/gtk3salnativewidgets-gtk.cxx
+++ b/vcl/unx/gtk3/gtk3salnativewidgets-gtk.cxx
@@ -18,7 +18,9 @@
 #include <vcl/settings.hxx>
 #include "unx/fontmanager.hxx"
 #include "cairo_gtk3_cairo.hxx"
-
+#if defined(GDK_WINDOWING_WAYLAND)
+#   include <gdk/gdkwayland.h>
+#endif
 #include <boost/optional.hpp>
 
 GtkStyleContext* GtkSalGraphics::mpButtonStyle = nullptr;
@@ -2322,6 +2324,14 @@ void GtkData::initNWF()
     pSVData->maNWFData.mbNoFocusRectsForFlatButtons = true;
     pSVData->maNWFData.mbAutoAccel = true;
     pSVData->maNWFData.mbEnableAccel = true;
+
+#if defined(GDK_WINDOWING_WAYLAND)
+    //gnome#768128 for the car crash that is wayland
+    //and floating dockable toolbars
+    GdkDisplay *pDisplay = gdk_display_get_default();
+    if (GDK_IS_WAYLAND_DISPLAY(pDisplay))
+        pSVData->maNWFData.mbDockingFloatsSupported = false;
+#endif
 }
 
 void GtkData::deInitNWF()
-- 
2.9.3

