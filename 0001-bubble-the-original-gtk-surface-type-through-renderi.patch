From 0533dd425a46fb8344c12eead0b7ac21fe7db047 Mon Sep 17 00:00:00 2001
From: rpmbuild <rpmbuild@fedoraproject.org>
Date: Fri, 18 Aug 2017 12:12:40 +0100
Subject: [PATCH] bubble the original gtk surface type through rendering

this makes presenting from a hidpi internal monitor to non-hidpi external
monitor use the correct sizes

and this may make scrolling a tad faster in general
---
 vcl/headless/svpframe.cxx     |   4 +-
 vcl/headless/svpgdi.cxx       | 135 ++++++++++++++++++++++++++----------------
 vcl/headless/svpvd.cxx        |  21 +++----
 vcl/inc/headless/svpgdi.hxx   |   5 +-
 vcl/inc/headless/svpvd.hxx    |   1 +
 vcl/inc/unx/gtk/gtkframe.hxx  |   2 +
 vcl/unx/gtk3/gtk3gtkframe.cxx |  50 +++++++---------
 7 files changed, 128 insertions(+), 90 deletions(-)

diff --git a/vcl/headless/svpframe.cxx b/vcl/headless/svpframe.cxx
index 0ce76cf..962cea0 100644
--- a/vcl/headless/svpframe.cxx
+++ b/vcl/headless/svpframe.cxx
@@ -150,7 +150,7 @@ SalGraphics* SvpSalFrame::AcquireGraphics()
 {
     SvpSalGraphics* pGraphics = new SvpSalGraphics();
 #ifndef IOS
-    pGraphics->setSurface( m_pSurface );
+    pGraphics->setSurface(m_pSurface, B2IVector(maGeometry.nWidth, maGeometry.nHeight));
 #endif
     m_aGraphics.push_back( pGraphics );
     return pGraphics;
@@ -281,7 +281,7 @@ void SvpSalFrame::SetPosSize( long nX, long nY, long nWidth, long nHeight, sal_u
         for( std::list< SvpSalGraphics* >::iterator it = m_aGraphics.begin();
              it != m_aGraphics.end(); ++it )
         {
-             (*it)->setSurface(m_pSurface);
+             (*it)->setSurface(m_pSurface, aFrameSize);
         }
     }
     if( m_bVisible )
diff --git a/vcl/headless/svpgdi.cxx b/vcl/headless/svpgdi.cxx
index bcc1df9..242cc13 100644
--- a/vcl/headless/svpgdi.cxx
+++ b/vcl/headless/svpgdi.cxx
@@ -133,6 +133,22 @@ namespace
         {
             return source;
         }
+        void mark_dirty()
+        {
+            cairo_surface_mark_dirty(source);
+        }
+        unsigned char* getBits(sal_Int32 &rStride)
+        {
+            cairo_surface_flush(source);
+
+            unsigned char *mask_data = cairo_image_surface_get_data(source);
+
+            cairo_format_t nFormat = cairo_image_surface_get_format(source);
+            assert(nFormat == CAIRO_FORMAT_ARGB32 && "need to implement CAIRO_FORMAT_A1 after all here");
+            rStride = cairo_format_stride_for_width(nFormat, cairo_image_surface_get_width(source));
+
+            return mask_data;
+        }
     private:
         SvpSalBitmap aTmpBmp;
         cairo_surface_t* source;
@@ -386,9 +402,10 @@ SvpSalGraphics::~SvpSalGraphics()
 {
 }
 
-void SvpSalGraphics::setSurface(cairo_surface_t* pSurface)
+void SvpSalGraphics::setSurface(cairo_surface_t* pSurface, const basegfx::B2IVector& rSize)
 {
     m_pSurface = pSurface;
+    m_aFrameSize = rSize;
 #if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 14, 0)
     cairo_surface_get_device_scale(pSurface, &m_fScale, nullptr);
 #endif
@@ -402,14 +419,14 @@ void SvpSalGraphics::GetResolution( sal_Int32& rDPIX, sal_Int32& rDPIY )
 
 sal_uInt16 SvpSalGraphics::GetBitCount() const
 {
-    if (CAIRO_FORMAT_A1 == cairo_image_surface_get_format(m_pSurface))
+    if (cairo_surface_get_content(m_pSurface) != CAIRO_CONTENT_COLOR_ALPHA)
         return 1;
     return 32;
 }
 
 long SvpSalGraphics::GetGraphicsWidth() const
 {
-    return m_pSurface ? cairo_image_surface_get_width(m_pSurface) / m_fScale : 0;
+    return m_pSurface ? m_aFrameSize.getX() : 0;
 }
 
 void SvpSalGraphics::ResetClipRegion()
@@ -885,7 +902,7 @@ bool SvpSalGraphics::drawPolyPolygon(const basegfx::B2DPolyPolygon& rPolyPoly, d
 
 void SvpSalGraphics::applyColor(cairo_t *cr, SalColor aColor)
 {
-    if (CAIRO_FORMAT_ARGB32 == cairo_image_surface_get_format(m_pSurface))
+    if (cairo_surface_get_content(m_pSurface) == CAIRO_CONTENT_COLOR_ALPHA)
     {
         cairo_set_source_rgba(cr, SALCOLOR_RED(aColor)/255.0,
                                   SALCOLOR_GREEN(aColor)/255.0,
@@ -982,17 +999,10 @@ void SvpSalGraphics::copyBits( const SalTwoRect& rTR,
     if (pSrc == this)
     {
         //self copy is a problem, so dup source in that case
-#if CAIRO_VERSION < CAIRO_VERSION_ENCODE(1, 12, 0)
         pCopy = cairo_surface_create_similar(source,
                                             cairo_surface_get_content(m_pSurface),
                                             aTR.mnSrcWidth * m_fScale,
                                             aTR.mnSrcHeight * m_fScale);
-#else
-        pCopy = cairo_surface_create_similar_image(source,
-                                            cairo_image_surface_get_format(m_pSurface),
-                                            aTR.mnSrcWidth * m_fScale,
-                                            aTR.mnSrcHeight * m_fScale);
-#endif
 #if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 14, 0)
         cairo_surface_set_device_scale(pCopy, m_fScale, m_fScale);
 #endif
@@ -1049,16 +1059,8 @@ void SvpSalGraphics::drawMask( const SalTwoRect& rTR,
     /** creates an image from the given rectangle, replacing all black pixels
      *  with nMaskColor and make all other full transparent */
     SourceHelper aSurface(rSalBitmap);
-    cairo_surface_t* mask = aSurface.getSurface();
-
-    cairo_surface_flush(mask);
-
-    unsigned char *mask_data = cairo_image_surface_get_data(mask);
-
-    cairo_format_t nFormat = cairo_image_surface_get_format(mask);
-    assert(nFormat == CAIRO_FORMAT_ARGB32 && "need to implement CAIRO_FORMAT_A1 after all here");
-    sal_Int32 nStride = cairo_format_stride_for_width(nFormat,
-                                                      cairo_image_surface_get_width(mask));
+    sal_Int32 nStride;
+    unsigned char *mask_data = aSurface.getBits(nStride);
     for (sal_Int32 y = rTR.mnSrcY ; y < rTR.mnSrcY + rTR.mnSrcHeight; ++y)
     {
         unsigned char *row = mask_data + (nStride*y);
@@ -1085,7 +1087,7 @@ void SvpSalGraphics::drawMask( const SalTwoRect& rTR,
             data+=4;
         }
     }
-    cairo_surface_mark_dirty(mask);
+    aSurface.mark_dirty();
 
     cairo_t* cr = getCairoContext(false);
     clipRegion(cr);
@@ -1098,7 +1100,7 @@ void SvpSalGraphics::drawMask( const SalTwoRect& rTR,
 
     cairo_translate(cr, rTR.mnDestX, rTR.mnDestY);
     cairo_scale(cr, (double)(rTR.mnDestWidth)/rTR.mnSrcWidth, ((double)rTR.mnDestHeight)/rTR.mnSrcHeight);
-    cairo_set_source_surface(cr, mask, -rTR.mnSrcX, -rTR.mnSrcY);
+    cairo_set_source_surface(cr, aSurface.getSurface(), -rTR.mnSrcX, -rTR.mnSrcY);
     cairo_paint(cr);
 
     releaseCairoContext(cr, false, extents);
@@ -1123,18 +1125,24 @@ SalBitmap* SvpSalGraphics::getBitmap( long nX, long nY, long nWidth, long nHeigh
 
 SalColor SvpSalGraphics::getPixel( long nX, long nY )
 {
-    cairo_surface_flush(m_pSurface);
-    cairo_format_t nFormat = cairo_image_surface_get_format(m_pSurface);
-    assert(nFormat == CAIRO_FORMAT_ARGB32 && "need to implement CAIRO_FORMAT_A1 after all here");
-    sal_Int32 nStride = cairo_format_stride_for_width(nFormat,
-                                                      cairo_image_surface_get_width(m_pSurface));
-    unsigned char *surface_data = cairo_image_surface_get_data(m_pSurface);
-    unsigned char *row = surface_data + (nStride*nY);
-    unsigned char *data = row + (nX * 4);
+    cairo_surface_t *target = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 1, 1);
+    cairo_t* cr = cairo_create(target);
+
+    cairo_rectangle(cr, 0, 0, 1, 1);
+    cairo_set_source_surface(cr, m_pSurface, -nX, -nY);
+    cairo_paint(cr);
+    cairo_destroy(cr);
+
+    cairo_surface_flush(target);
+    unsigned char *data = cairo_image_surface_get_data(target);
     sal_uInt8 b = unpremultiply(data[SVP_CAIRO_BLUE], data[SVP_CAIRO_ALPHA]);
     sal_uInt8 g = unpremultiply(data[SVP_CAIRO_GREEN], data[SVP_CAIRO_ALPHA]);
     sal_uInt8 r = unpremultiply(data[SVP_CAIRO_RED], data[SVP_CAIRO_ALPHA]);
-    return MAKE_SALCOLOR(r, g, b);
+    SalColor nRet = MAKE_SALCOLOR(r, g, b);
+
+    cairo_surface_destroy(target);
+
+    return nRet;
 }
 
 namespace
@@ -1268,17 +1276,15 @@ cairo_surface_t* SvpSalGraphics::createCairoSurface(const BitmapBuffer *pBuffer)
     return target;
 }
 
-static cairo_t* createTmpCompatibleCairoContext(cairo_surface_t* pSurface, double fScale)
+cairo_t* SvpSalGraphics::createTmpCompatibleCairoContext() const
 {
-    cairo_surface_t *target = cairo_image_surface_create(
-                                cairo_image_surface_get_format(pSurface),
-                                cairo_image_surface_get_width(pSurface),
-                                cairo_image_surface_get_height(pSurface));
+    cairo_surface_t *target = cairo_image_surface_create(CAIRO_FORMAT_ARGB32,
+                                                         m_aFrameSize.getX() * m_fScale,
+                                                         m_aFrameSize.getY() * m_fScale);
 #if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 14, 0)
-    cairo_surface_set_device_scale(target, fScale, fScale);
-#else
-    (void)fScale;
+    cairo_surface_set_device_scale(target, m_fScale, m_fScale);
 #endif
+
     return cairo_create(target);
 }
 
@@ -1286,7 +1292,7 @@ cairo_t* SvpSalGraphics::getCairoContext(bool bXorModeAllowed) const
 {
     cairo_t* cr;
     if (m_ePaintMode == XOR && bXorModeAllowed)
-        cr = createTmpCompatibleCairoContext(m_pSurface, m_fScale);
+        cr = createTmpCompatibleCairoContext();
     else
         cr = cairo_create(m_pSurface);
     cairo_set_line_width(cr, 1);
@@ -1316,8 +1322,8 @@ void SvpSalGraphics::releaseCairoContext(cairo_t* cr, bool bXorModeAllowed, cons
 
     sal_Int32 nExtentsLeft(rExtents.getMinX()), nExtentsTop(rExtents.getMinY());
     sal_Int32 nExtentsRight(rExtents.getMaxX()), nExtentsBottom(rExtents.getMaxY());
-    sal_Int32 nWidth = cairo_image_surface_get_width(m_pSurface);
-    sal_Int32 nHeight = cairo_image_surface_get_height(m_pSurface);
+    sal_Int32 nWidth = m_aFrameSize.getX();
+    sal_Int32 nHeight = m_aFrameSize.getY();
     nExtentsLeft = std::max<sal_Int32>(nExtentsLeft, 0);
     nExtentsTop = std::max<sal_Int32>(nExtentsTop, 0);
     nExtentsRight = std::min<sal_Int32>(nExtentsRight, nWidth);
@@ -1331,21 +1337,35 @@ void SvpSalGraphics::releaseCairoContext(cairo_t* cr, bool bXorModeAllowed, cons
     //emulate it (slowly) here.
     if (m_ePaintMode == XOR && bXorModeAllowed)
     {
-        cairo_surface_t* true_surface = m_pSurface;
-        cairo_surface_flush(true_surface);
-        unsigned char *true_surface_data = cairo_image_surface_get_data(true_surface);
+        cairo_surface_t* target_surface = m_pSurface;
+        if (cairo_surface_get_type(target_surface) != CAIRO_SURFACE_TYPE_IMAGE)
+        {
+            //in the unlikely case we can't use m_pSurface directly, copy contents
+            //to another temp image surface
+            cairo_t* copycr = createTmpCompatibleCairoContext();
+            cairo_rectangle(copycr, nExtentsLeft, nExtentsTop,
+                                    nExtentsRight - nExtentsLeft,
+                                    nExtentsBottom - nExtentsTop);
+            cairo_set_source_surface(copycr, m_pSurface, 0, 0);
+            cairo_paint(copycr);
+            target_surface = cairo_get_target(copycr);
+            cairo_destroy(copycr);
+        }
+
+        cairo_surface_flush(target_surface);
+        unsigned char *target_surface_data = cairo_image_surface_get_data(target_surface);
         unsigned char *xor_surface_data = cairo_image_surface_get_data(surface);
 
-        cairo_format_t nFormat = cairo_image_surface_get_format(m_pSurface);
+        cairo_format_t nFormat = cairo_image_surface_get_format(target_surface);
         assert(nFormat == CAIRO_FORMAT_ARGB32 && "need to implement CAIRO_FORMAT_A1 after all here");
-        sal_Int32 nStride = cairo_format_stride_for_width(nFormat, nWidth);
+        sal_Int32 nStride = cairo_format_stride_for_width(nFormat, nWidth * m_fScale);
         sal_Int32 nUnscaledExtentsLeft = nExtentsLeft * m_fScale;
         sal_Int32 nUnscaledExtentsRight = nExtentsRight * m_fScale;
         sal_Int32 nUnscaledExtentsTop = nExtentsTop * m_fScale;
         sal_Int32 nUnscaledExtentsBottom = nExtentsBottom * m_fScale;
         for (sal_Int32 y = nUnscaledExtentsTop; y < nUnscaledExtentsBottom; ++y)
         {
-            unsigned char *true_row = true_surface_data + (nStride*y);
+            unsigned char *true_row = target_surface_data + (nStride*y);
             unsigned char *xor_row = xor_surface_data + (nStride*y);
             unsigned char *true_data = true_row + (nUnscaledExtentsLeft * 4);
             unsigned char *xor_data = xor_row + (nUnscaledExtentsLeft * 4);
@@ -1364,7 +1384,22 @@ void SvpSalGraphics::releaseCairoContext(cairo_t* cr, bool bXorModeAllowed, cons
                 xor_data+=4;
             }
         }
-        cairo_surface_mark_dirty(true_surface);
+        cairo_surface_mark_dirty(target_surface);
+
+        if (target_surface != m_pSurface)
+        {
+            cairo_t* copycr = cairo_create(m_pSurface);
+            //unlikely case we couldn't use m_pSurface directly, copy contents
+            //back from image surface
+            cairo_rectangle(copycr, nExtentsLeft, nExtentsTop,
+                                    nExtentsRight - nExtentsLeft,
+                                    nExtentsBottom - nExtentsTop);
+            cairo_set_source_surface(copycr, target_surface, 0, 0);
+            cairo_paint(copycr);
+            cairo_destroy(copycr);
+            cairo_surface_destroy(target_surface);
+        }
+
         cairo_surface_destroy(surface);
     }
 
diff --git a/vcl/headless/svpvd.cxx b/vcl/headless/svpvd.cxx
index ca28a52..b5ab755 100644
--- a/vcl/headless/svpvd.cxx
+++ b/vcl/headless/svpvd.cxx
@@ -38,7 +38,7 @@ SvpSalVirtualDevice::~SvpSalVirtualDevice()
 SalGraphics* SvpSalVirtualDevice::AcquireGraphics()
 {
     SvpSalGraphics* pGraphics = new SvpSalGraphics();
-    pGraphics->setSurface(m_pSurface);
+    pGraphics->setSurface(m_pSurface, m_aFrameSize);
     m_aGraphics.push_back( pGraphics );
     return pGraphics;
 }
@@ -62,12 +62,14 @@ bool SvpSalVirtualDevice::SetSizeUsingBuffer( long nNewDX, long nNewDY,
     if (nNewDY == 0)
         nNewDY = 1;
 
-    nNewDX *= m_fScale;
-    nNewDY *= m_fScale;
-
-    if (!m_pSurface || cairo_image_surface_get_width(m_pSurface) != nNewDX ||
-                       cairo_image_surface_get_height(m_pSurface) != nNewDY )
+    if (!m_pSurface || m_aFrameSize.getX() != nNewDX ||
+                       m_aFrameSize.getY() != nNewDY )
     {
+        m_aFrameSize = basegfx::B2IVector(nNewDX, nNewDY);
+
+        nNewDX *= m_fScale;
+        nNewDY *= m_fScale;
+
         if (m_pSurface)
         {
             cairo_surface_destroy(m_pSurface);
@@ -96,20 +98,19 @@ bool SvpSalVirtualDevice::SetSizeUsingBuffer( long nNewDX, long nNewDY,
         // update device in existing graphics
         for( std::list< SvpSalGraphics* >::iterator it = m_aGraphics.begin();
              it != m_aGraphics.end(); ++it )
-            (*it)->setSurface(m_pSurface);
-
+            (*it)->setSurface(m_pSurface, m_aFrameSize);
     }
     return true;
 }
 
 long SvpSalVirtualDevice::GetWidth() const
 {
-    return m_pSurface ? cairo_image_surface_get_width(m_pSurface) : 0;
+    return m_pSurface ? m_aFrameSize.getX() : 0;
 }
 
 long SvpSalVirtualDevice::GetHeight() const
 {
-    return m_pSurface ? cairo_image_surface_get_height(m_pSurface) : 0;
+    return m_pSurface ? m_aFrameSize.getY() : 0;
 }
 
 #endif
diff --git a/vcl/inc/headless/svpgdi.hxx b/vcl/inc/headless/svpgdi.hxx
index 97fd678..0f46c5f 100644
--- a/vcl/inc/headless/svpgdi.hxx
+++ b/vcl/inc/headless/svpgdi.hxx
@@ -80,6 +80,7 @@ struct VCL_DLLPUBLIC DamageHandler
 class VCL_DLLPUBLIC SvpSalGraphics : public SalGraphics
 {
     cairo_surface_t*               m_pSurface;
+    basegfx::B2IVector             m_aFrameSize;
     double                         m_fScale;
     SalColor                       m_aLineColor;
     SalColor                       m_aFillColor;
@@ -87,7 +88,7 @@ class VCL_DLLPUBLIC SvpSalGraphics : public SalGraphics
 
 public:
     static GlyphCache& getPlatformGlyphCache();
-    void setSurface(cairo_surface_t* pSurface);
+    void setSurface(cairo_surface_t* pSurface, const basegfx::B2IVector& rSize);
     static cairo_user_data_key_t* getDamageKey();
 
 private:
@@ -115,6 +116,8 @@ protected:
         const SalBitmap* pAlphaBitmap) override;
     virtual bool drawAlphaRect( long nX, long nY, long nWidth, long nHeight, sal_uInt8 nTransparency ) override;
 
+    cairo_t* createTmpCompatibleCairoContext() const;
+
 public:
     SvpSalGraphics();
     virtual ~SvpSalGraphics() override;
diff --git a/vcl/inc/headless/svpvd.hxx b/vcl/inc/headless/svpvd.hxx
index 882f36d..7ac1563 100644
--- a/vcl/inc/headless/svpvd.hxx
+++ b/vcl/inc/headless/svpvd.hxx
@@ -31,6 +31,7 @@ class VCL_DLLPUBLIC SvpSalVirtualDevice : public SalVirtualDevice
 {
     DeviceFormat                        m_eFormat;
     cairo_surface_t*                    m_pSurface;
+    basegfx::B2IVector                  m_aFrameSize;
     double                              m_fScale;
     std::list< SvpSalGraphics* >        m_aGraphics;
 
diff --git a/vcl/inc/unx/gtk/gtkframe.hxx b/vcl/inc/unx/gtk/gtkframe.hxx
index f263160..8f60671 100644
--- a/vcl/inc/unx/gtk/gtkframe.hxx
+++ b/vcl/inc/unx/gtk/gtkframe.hxx
@@ -246,6 +246,7 @@ class GtkSalFrame : public SalFrame
 #endif
 #if GTK_CHECK_VERSION(3,0,0)
     static gboolean     signalDraw( GtkWidget*, cairo_t *cr, gpointer );
+    static void         signalRealize(GtkWidget*, gpointer frame);
     static void         sizeAllocated(GtkWidget*, GdkRectangle *pAllocation, gpointer frame);
     static gboolean     signalTooltipQuery(GtkWidget*, gint x, gint y,
                                      gboolean keyboard_mode, GtkTooltip *tooltip,
@@ -346,6 +347,7 @@ class GtkSalFrame : public SalFrame
 public:
 #if GTK_CHECK_VERSION(3,0,0)
     cairo_surface_t*                m_pSurface;
+    basegfx::B2IVector              m_aFrameSize;
     DamageHandler                   m_aDamageHandler;
     std::vector<GdkEvent*>          m_aPendingScrollEvents;
     Idle                            m_aSmoothScrollIdle;
diff --git a/vcl/unx/gtk3/gtk3gtkframe.cxx b/vcl/unx/gtk3/gtk3gtkframe.cxx
index 9be38dd..dc9d83b 100644
--- a/vcl/unx/gtk3/gtk3gtkframe.cxx
+++ b/vcl/unx/gtk3/gtk3gtkframe.cxx
@@ -1045,6 +1045,7 @@ void GtkSalFrame::InitCommon()
     m_aMouseSignalIds.push_back(g_signal_connect( G_OBJECT(pEventWidget), "scroll-event", G_CALLBACK(signalScroll), this ));
 
     g_signal_connect( G_OBJECT(m_pFixedContainer), "draw", G_CALLBACK(signalDraw), this );
+    g_signal_connect( G_OBJECT(m_pFixedContainer), "realize", G_CALLBACK(signalRealize), this );
     g_signal_connect( G_OBJECT(m_pFixedContainer), "size-allocate", G_CALLBACK(sizeAllocated), this );
 #if GTK_CHECK_VERSION(3,14,0)
     GtkGesture *pSwipe = gtk_gesture_swipe_new(pEventWidget);
@@ -1340,7 +1341,7 @@ SalGraphics* GtkSalFrame::AcquireGraphics()
             AllocateFrame();
             TriggerPaintEvent();
         }
-        m_pGraphics->setSurface(m_pSurface);
+        m_pGraphics->setSurface(m_pSurface, m_aFrameSize);
     }
     m_bGraphics = true;
     return m_pGraphics;
@@ -1587,13 +1588,11 @@ void GtkSalFrame::SetMinClientSize( long nWidth, long nHeight )
     }
 }
 
-// FIXME: we should really be an SvpSalFrame sub-class, and
-// share their AllocateFrame !
 void GtkSalFrame::AllocateFrame()
 {
     basegfx::B2IVector aFrameSize( maGeometry.nWidth, maGeometry.nHeight );
-    if (!m_pSurface || cairo_image_surface_get_width(m_pSurface) != aFrameSize.getX() ||
-                       cairo_image_surface_get_height(m_pSurface) != aFrameSize.getY() )
+    if (!m_pSurface || m_aFrameSize.getX() != aFrameSize.getX() ||
+                       m_aFrameSize.getY() != aFrameSize.getY() )
     {
         if( aFrameSize.getX() == 0 )
             aFrameSize.setX( 1 );
@@ -1603,30 +1602,17 @@ void GtkSalFrame::AllocateFrame()
         if (m_pSurface)
             cairo_surface_destroy(m_pSurface);
 
-#if GTK_CHECK_VERSION(3,10,0)
-#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 14, 0)
-        int scale = gtk_widget_get_scale_factor(m_pWindow);
-#else
-        int scale = 1;
-#endif
-        m_pSurface = gdk_window_create_similar_image_surface(widget_get_window(m_pWindow),
-                                                             CAIRO_FORMAT_ARGB32,
-                                                             aFrameSize.getX() * scale,
-                                                             aFrameSize.getY() * scale,
-                                                             scale);
-#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 14, 0)
-        cairo_surface_set_device_scale(m_pSurface, scale, scale);
-#endif
-#else
-        m_pSurface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32,
-                                                aFrameSize.getX(),
-                                                aFrameSize.getY());
-#endif
+        m_pSurface = gdk_window_create_similar_surface(widget_get_window(m_pWindow),
+                                                       CAIRO_CONTENT_COLOR_ALPHA,
+                                                       aFrameSize.getX(),
+                                                       aFrameSize.getY());
+        m_aFrameSize = aFrameSize;
+
         cairo_surface_set_user_data(m_pSurface, SvpSalGraphics::getDamageKey(), &m_aDamageHandler, nullptr);
         SAL_INFO("vcl.gtk3", "allocated Frame size of " << maGeometry.nWidth << " x " << maGeometry.nHeight);
 
         if (m_pGraphics)
-            m_pGraphics->setSurface(m_pSurface);
+            m_pGraphics->setSurface(m_pSurface, m_aFrameSize);
     }
 }
 
@@ -2967,13 +2953,23 @@ gboolean GtkSalFrame::signalDraw(GtkWidget*, cairo_t *cr, gpointer frame)
     return false;
 }
 
-void GtkSalFrame::sizeAllocated(GtkWidget*, GdkRectangle *pAllocation, gpointer frame)
+void GtkSalFrame::sizeAllocated(GtkWidget* pWidget, GdkRectangle *pAllocation, gpointer frame)
 {
     GtkSalFrame* pThis = static_cast<GtkSalFrame*>(frame);
     pThis->maGeometry.nWidth = pAllocation->width;
     pThis->maGeometry.nHeight = pAllocation->height;
-    pThis->AllocateFrame();
+    bool bRealized = gtk_widget_get_realized(pWidget);
+    if (bRealized)
+        pThis->AllocateFrame();
     pThis->CallCallbackExc( SalEvent::Resize, nullptr );
+    if (bRealized && !pThis->m_bSalObjectSetPosSize)
+        pThis->TriggerPaintEvent();
+}
+
+void GtkSalFrame::signalRealize(GtkWidget*, gpointer frame)
+{
+    GtkSalFrame* pThis = static_cast<GtkSalFrame*>(frame);
+    pThis->AllocateFrame();
     if (pThis->m_bSalObjectSetPosSize)
         return;
     pThis->TriggerPaintEvent();
-- 
2.13.0

