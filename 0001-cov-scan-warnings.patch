From b2549a70cb5d27f9c869451650c289ca831af97d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Caol=C3=A1n=20McNamara?= <caolanm@redhat.com>
Date: Thu, 26 Jul 2018 13:08:01 +0100
Subject: [PATCH] cov scan warnings
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Change-Id: If27bcfe85c5f2502ac1adb4ed4850ee42447516a

coverity#705646 Resource leak

Reviewed-on: https://gerrit.libreoffice.org/54139
Reviewed-by: Caolán McNamara <caolanm@redhat.com>
Tested-by: Caolán McNamara <caolanm@redhat.com>
(cherry picked from commit 1a3deaa7f7ff1d7e6ab5f5d551bcbc8c00d84052)

Change-Id: I709b16f720cf97c05207cfb22d0c0ea15622367a

Related: rhbz#1602589 silence error[memleak]: Memory leak: newValue

Change-Id: I2d04c75aa9b5e1d91e06992fdb99899657ecf96d

Related: rhbz#1602589 double_free, convert to std::vector

Change-Id: I5fa19422d7ee61e7aad74eae86d843072e94016c

Related: rhbz#1602589 silence coverity leaked_storage

Change-Id: Iae694be40b32cc3821d326bb362e6091dba19a35

Related: rhbz#1602589 silence coverity use_after_free

Change-Id: If5345b6515c45bee2742d1293cd181ab46e8e61b

Related: rhbz#1602589 silence coverity copy_paste_error

Change-Id: Idca4bfaaa9f127eae87ae879e2131aed747ce4b3

Related: rhbz#1602589 add comments to coverity annotations

Change-Id: I88c941832a0d682ea4b6028c28edd48cf5df38f7

Related: rhbz#1602589 silence leaked_storage

Change-Id: Ib489ebf55d3a18d2af6f34b3f6128231d6d7758c

InsertNewTable always returns true

Change-Id: I28b2cd46bf40011f5f813784bd5c182f18ee103f

pDPObject can never be null

Change-Id: Ie98da9b53e952c2fb1f8f91e4b9489060114c366

ScDPObject is only needed in endFastElement

Change-Id: I8e1a7897777111c225e42ebcf81e67face6b29b9

Related: rhbz#1602589 silence leaked_storage

Change-Id: I21cc4af40429fa3ef4284d6c0ea592b05bf36620

bodge it

Change-Id: Ie9e4e3173a91f5380a98d629c8a67d2ebb9c6c14

Related: rhbz#1602589 rework to avoid bogus cppcheck double free warning

Change-Id: Ie673de68f39b903536c2287b8989fe6afcc9fd66

SHELLCHECK_WARNING, VERBOSE is unused

gengal.sh was originally based on unopkg.sh
which had this --verbose switch...

commit 164027e48899faaee284242eaca04b8aa5545319
Date:   Fri Apr 5 16:39:24 2013 +0100

    gengal: re-base on original tool.

    new wrapper based on unopkg.sh.
    work re-based on original SUSE implementation.

and unopkg.sh later had VERBOSE removed...

commit 1fc195f7e830619d56cc4c56043b154bc3a72b02
Author: Stephan Bergmann <sbergman@redhat.com>
Date:   Thu Oct 17 15:34:53 2013 +0200

    Simplify code (VERBOSE was unused)

but gengal.sh retained its unused VERBOSE variable

Change-Id: I56aa830aef829c7727550fcaf7aed5058fffdc78
---
 bridges/source/cpp_uno/shared/bridge.cxx      |   2 +-
 bridges/source/jni_uno/jni_bridge.cxx         |   4 +-
 bridges/source/jni_uno/jni_info.cxx           |   6 +-
 comphelper/source/misc/threadpool.cxx         |   2 +-
 cppu/source/typelib/static_types.cxx          |   2 +-
 cppu/source/typelib/typelib.cxx               |   9 +-
 extensions/source/scanner/sanedlg.cxx         |   2 +-
 filter/source/svg/presentation_engine.js      |   8 +-
 .../accelerators/acceleratorconfiguration.cxx |   4 +-
 idlc/source/parser.y                          |   2 +-
 include/LibreOfficeKit/LibreOfficeKitInit.h   |   4 +-
 include/vcl/bitmap.hxx                        |  14 +-
 pyuno/source/module/pyuno_dlopenwrapper.c     |   1 +
 registry/source/reflwrit.cxx                  |   8 +-
 registry/source/regimpl.cxx                   | 124 ++++++---------
 sal/osl/unx/file.cxx                          |   4 +-
 sal/osl/unx/pipe.cxx                          |   9 +-
 sal/osl/unx/profile.cxx                       |   1 +
 sal/osl/w32/file.cxx                          |   4 +-
 sal/rtl/alloc_arena.cxx                       |   2 +-
 sal/rtl/alloc_cache.cxx                       |   6 +-
 sc/inc/dpobject.hxx                           |   2 +-
 sc/qa/unit/ucalc_pivottable.cxx               | 142 +++++++-----------
 sc/source/core/data/dpobject.cxx              |   3 +-
 sc/source/core/tool/chgtrack.cxx              |  20 ++-
 sc/source/core/tool/compiler.cxx              |   1 +
 sc/source/filter/xml/xmldpimp.cxx             |  19 +--
 sc/source/filter/xml/xmldpimp.hxx             |   3 +-
 sc/source/ui/docshell/dbdocfun.cxx            |   4 +-
 sc/source/ui/undo/undodat.cxx                 |   6 +-
 sc/source/ui/view/viewdata.cxx                |   2 +
 .../ui/animations/CustomAnimationPane.cxx     |   2 +
 sd/source/ui/unoidl/unosrch.cxx               |  71 +++------
 sfx2/source/control/itemdel.cxx               |   2 +-
 solenv/bin/pack_images.py                     |   2 +-
 soltools/cpp/_unix.c                          |   1 +
 soltools/mkdepend/parse.c                     |   1 +
 svtools/source/svhtml/htmlout.cxx             |   2 +-
 svx/source/gengal/gengal.sh                   |   2 -
 sw/source/core/text/itrform2.cxx              |   2 +
 sw/source/ui/index/cnttab.cxx                 |   9 +-
 unoidl/source/legacyprovider.cxx              |  32 ++--
 unotest/source/cpp/officeconnection.cxx       |   2 +-
 vcl/source/bitmap/BitmapScaleConvolution.cxx  |  62 ++++----
 vcl/source/gdi/bitmap3.cxx                    |  10 +-
 vcl/source/gdi/bitmap4.cxx                    |  53 +++----
 vcl/source/gdi/pdfwriter_impl.cxx             |   1 +
 vcl/unx/generic/plugadapt/salplug.cxx         |   1 +
 .../sun/star/wizards/agenda/TopicsControl.py  |   6 +-
 .../star/wizards/document/OfficeDocument.py   |   1 -
 50 files changed, 306 insertions(+), 376 deletions(-)

diff --git a/bridges/source/cpp_uno/shared/bridge.cxx b/bridges/source/cpp_uno/shared/bridge.cxx
index 556350022e48..186d89aa1956 100644
--- a/bridges/source/cpp_uno/shared/bridge.cxx
+++ b/bridges/source/cpp_uno/shared/bridge.cxx
@@ -144,7 +144,7 @@ uno_Mapping * Bridge::createMapping(
     bool bExportCpp2Uno)
 {
     Bridge * bridge = new Bridge(pCppEnv, pUnoEnv, bExportCpp2Uno);
-    //coverity[leaked_storage]
+    // coverity[leaked_storage] - on purpose
     return bExportCpp2Uno ? &bridge->aCpp2Uno : &bridge->aUno2Cpp;
 }
 
diff --git a/bridges/source/jni_uno/jni_bridge.cxx b/bridges/source/jni_uno/jni_bridge.cxx
index 3859b148c541..15daa8e28603 100644
--- a/bridges/source/jni_uno/jni_bridge.cxx
+++ b/bridges/source/jni_uno/jni_bridge.cxx
@@ -551,7 +551,7 @@ SAL_DLLPUBLIC_EXPORT void SAL_CALL uno_ext_getMapping(
             uno_registerMapping(
                 &mapping, Bridge_free,
                 pFrom, &pTo->pExtEnv->aBase, nullptr );
-            // coverity[leaked_storage]
+            // coverity[leaked_storage] - on purpose
         }
         else if ( from_env_typename == UNO_LB_UNO && to_env_typename == UNO_LB_JAVA )
         {
@@ -561,7 +561,7 @@ SAL_DLLPUBLIC_EXPORT void SAL_CALL uno_ext_getMapping(
             uno_registerMapping(
                 &mapping, Bridge_free,
                 &pFrom->pExtEnv->aBase, pTo, nullptr );
-            // coverity[leaked_storage]
+            // coverity[leaked_storage] - on purpose
         }
     }
     catch (const BridgeRuntimeError & err)
diff --git a/bridges/source/jni_uno/jni_info.cxx b/bridges/source/jni_uno/jni_info.cxx
index 82b773d6d58c..1542eebbf4e6 100644
--- a/bridges/source/jni_uno/jni_info.cxx
+++ b/bridges/source/jni_uno/jni_info.cxx
@@ -103,7 +103,7 @@ JNI_interface_type_info::JNI_interface_type_info(
             typelib_InterfaceTypeDescription * td =
                 reinterpret_cast< typelib_InterfaceTypeDescription * >(
                     m_td.get() );
-            // coverity [ctor_dtor_leak]
+            // coverity[ctor_dtor_leak] - on purpose
             m_methods = new jmethodID[ td->nMapFunctionIndexToMemberIndex ];
             sal_Int32 nMethodIndex = 0;
             typelib_TypeDescriptionReference ** ppMembers = td->ppMembers;
@@ -288,7 +288,7 @@ JNI_compound_type_info::JNI_compound_type_info(
                 td->aBase.pWeakRef,
                 jni_info->m_RuntimeException_type.getTypeLibType() ))
         {
-            // coverity [ctor_dtor_leak]
+            // coverity[ctor_dtor_leak] - on purpose
             m_fields = new jfieldID[ 2 ];
             m_fields[ 0 ] = nullptr; // special Throwable.getMessage()
             // field Context
@@ -860,7 +860,7 @@ JNI_info::JNI_info(
     {
         css::uno::TypeDescription XInterface_td(
             cppu::UnoType<css::uno::XInterface>::get());
-        // coverity [ctor_dtor_leak]
+        // coverity[ctor_dtor_leak] - on purpose
         m_XInterface_type_info =
             new JNI_interface_type_info( jni, XInterface_td.get() );
     }
diff --git a/comphelper/source/misc/threadpool.cxx b/comphelper/source/misc/threadpool.cxx
index 23e363213206..d8e984fe58d5 100644
--- a/comphelper/source/misc/threadpool.cxx
+++ b/comphelper/source/misc/threadpool.cxx
@@ -153,7 +153,7 @@ void ThreadPool::shutdownLocked(std::unique_lock<std::mutex>& aGuard)
     }
     assert( maTasks.empty() );
 
-    // coverity[missing_lock]
+    // coverity[missing_lock] - on purpose
     mbTerminate = true;
 
     maTasksChanged.notify_all();
diff --git a/cppu/source/typelib/static_types.cxx b/cppu/source/typelib/static_types.cxx
index 3fb0bf6ab62a..f432b766a84a 100644
--- a/cppu/source/typelib/static_types.cxx
+++ b/cppu/source/typelib/static_types.cxx
@@ -439,7 +439,7 @@ void SAL_CALL typelib_static_interface_type_init(
     typelib_TypeDescriptionReference * pBaseType )
     SAL_THROW_EXTERN_C()
 {
-    // coverity[callee_ptr_arith]
+    // coverity[callee_ptr_arith] - not a bug
     typelib_static_mi_interface_type_init(
         ppRef, pTypeName, pBaseType == nullptr ? 0 : 1, &pBaseType);
 }
diff --git a/cppu/source/typelib/typelib.cxx b/cppu/source/typelib/typelib.cxx
index 4ef5aaf18ac7..8d0c8e5647de 100644
--- a/cppu/source/typelib/typelib.cxx
+++ b/cppu/source/typelib/typelib.cxx
@@ -564,6 +564,7 @@ extern "C" void SAL_CALL typelib_typedescription_newEmpty(
             osl_atomic_increment( &Init::get().nIndirectTypeDescriptionCount );
 #endif
             pTmp->pType = nullptr;
+            // coverity[leaked_storage] - this is on purpose
         }
         break;
 
@@ -581,6 +582,7 @@ extern "C" void SAL_CALL typelib_typedescription_newEmpty(
             pTmp->aBase.ppTypeRefs = nullptr;
             pTmp->aBase.ppMemberNames = nullptr;
             pTmp->pParameterizedTypes = nullptr;
+            // coverity[leaked_storage] - this is on purpose
         }
         break;
 
@@ -597,6 +599,7 @@ extern "C" void SAL_CALL typelib_typedescription_newEmpty(
             pTmp->pMemberOffsets = nullptr;
             pTmp->ppTypeRefs = nullptr;
             pTmp->ppMemberNames = nullptr;
+            // coverity[leaked_storage] - this is on purpose
         }
         break;
 
@@ -611,6 +614,7 @@ extern "C" void SAL_CALL typelib_typedescription_newEmpty(
             pTmp->nEnumValues       = 0;
             pTmp->ppEnumNames       = nullptr;
             pTmp->pEnumValues       = nullptr;
+            // coverity[leaked_storage] - this is on purpose
         }
         break;
 
@@ -632,6 +636,7 @@ extern "C" void SAL_CALL typelib_typedescription_newEmpty(
             pTmp->pMapMemberIndexToFunctionIndex= nullptr;
             pTmp->nBaseTypes = 0;
             pTmp->ppBaseTypes = nullptr;
+            // coverity[leaked_storage] - this is on purpose
         }
         break;
 
@@ -652,6 +657,7 @@ extern "C" void SAL_CALL typelib_typedescription_newEmpty(
             pTmp->pInterface = nullptr;
             pTmp->pBaseRef = nullptr;
             pTmp->nIndex = 0;
+            // coverity[leaked_storage] - this is on purpose
         }
         break;
 
@@ -672,6 +678,7 @@ extern "C" void SAL_CALL typelib_typedescription_newEmpty(
             pTmp->ppGetExceptions = nullptr;
             pTmp->nSetExceptions = 0;
             pTmp->ppSetExceptions = nullptr;
+            // coverity[leaked_storage] - this is on purpose
         }
         break;
 
@@ -892,7 +899,7 @@ extern "C" void SAL_CALL typelib_typedescription_newInterface(
     typelib_TypeDescriptionReference ** ppMembers )
     SAL_THROW_EXTERN_C()
 {
-    // coverity[callee_ptr_arith]
+    // coverity[callee_ptr_arith] - not a bug
     typelib_typedescription_newMIInterface(
         ppRet, pTypeName, 0, 0, 0, 0, 0, pBaseInterface == nullptr ? 0 : 1,
         &pBaseInterface, nMembers, ppMembers);
diff --git a/extensions/source/scanner/sanedlg.cxx b/extensions/source/scanner/sanedlg.cxx
index e515a763af39..d4b4bf9d3156 100644
--- a/extensions/source/scanner/sanedlg.cxx
+++ b/extensions/source/scanner/sanedlg.cxx
@@ -495,7 +495,6 @@ void SaneDlg::InitFields()
                         pField->SetMax( (long)pDouble[ nValue-1 ] );
                     else
                         pField->SetMax( (long)pDouble[ 1 ] );
-                    delete [] pDouble;
                 }
                 switch( i ) {
                     case 0: aMinTopLeft.X() = pField->GetMin();break;
@@ -513,6 +512,7 @@ void SaneDlg::InitFields()
                     case 3: aMaxBottomRight.Y() = (int)fValue;break;
                 }
             }
+            delete [] pDouble;
             pField->Enable();
         }
         else
diff --git a/filter/source/svg/presentation_engine.js b/filter/source/svg/presentation_engine.js
index 7dbe377697dd..f4b9db25e4e0 100644
--- a/filter/source/svg/presentation_engine.js
+++ b/filter/source/svg/presentation_engine.js
@@ -7987,7 +7987,7 @@ AnimationBaseNode3.prototype.info = function( bVerbose )
             sInfo += ';  keyTimes: ' + this.getKeyTimes().join( ',' );
 
         // values
-        if( this.getKeyTimes().length )
+        if( this.getValues().length )
             sInfo += ';  values: ' + this.getValues().join( ',' );
 
         // formula
@@ -12170,7 +12170,6 @@ SlideTransition.prototype.createSlideTransition = function( aLeavingSlide, aEnte
 
                 case PUSHWIPE_TRANSITION:
                 {
-                    var bCombined = false;
                     var aDirection = null;
                     switch( this.eTransitionSubType )
                     {
@@ -12192,10 +12191,7 @@ SlideTransition.prototype.createSlideTransition = function( aLeavingSlide, aEnte
                             aDirection = { x: -1.0, y: 0.0 };
                             break;
                     }
-                    if( bCombined )
-                        return null;
-                    else
-                        return new MovingSlideChange( aLeavingSlide, aEnteringSlide, aDirection, aDirection );
+                    return new MovingSlideChange( aLeavingSlide, aEnteringSlide, aDirection, aDirection );
                 }
 
                 case SLIDEWIPE_TRANSITION:
diff --git a/framework/source/accelerators/acceleratorconfiguration.cxx b/framework/source/accelerators/acceleratorconfiguration.cxx
index ecc33938ab75..6a5a120331c1 100644
--- a/framework/source/accelerators/acceleratorconfiguration.cxx
+++ b/framework/source/accelerators/acceleratorconfiguration.cxx
@@ -1125,7 +1125,7 @@ void XCUBasedAcceleratorConfiguration::impl_ts_save(bool bPreferred)
 
         // take over all changes into the original container
         SolarMutexGuard g;
-        // coverity[check_after_deref]
+        // coverity[check_after_deref] - confusing but correct
         if (m_pPrimaryWriteCache)
         {
             m_aPrimaryReadCache.takeOver(*m_pPrimaryWriteCache);
@@ -1164,7 +1164,7 @@ void XCUBasedAcceleratorConfiguration::impl_ts_save(bool bPreferred)
 
         // take over all changes into the original container
         SolarMutexGuard g;
-        // coverity[check_after_deref]
+        // coverity[check_after_deref] - confusing but correct
         if (m_pSecondaryWriteCache)
         {
             m_aSecondaryReadCache.takeOver(*m_pSecondaryWriteCache);
diff --git a/idlc/source/parser.y b/idlc/source/parser.y
index 1e873853b46e..592a082d58f8 100644
--- a/idlc/source/parser.y
+++ b/idlc/source/parser.y
@@ -2136,7 +2136,7 @@ at_least_one_scoped_name :
         } else
         {
             std::list< OString >* pScopedNames = new std::list< OString >;
-            // coverity [copy_paste_error]
+            // coverity[copy_paste_error] - this is not a cut and paste
             pScopedNames->push_back(*$1);
             $$ = pScopedNames;
         }
diff --git a/include/LibreOfficeKit/LibreOfficeKitInit.h b/include/LibreOfficeKit/LibreOfficeKitInit.h
index a0c111a9e0e2..71f4f2e68b04 100644
--- a/include/LibreOfficeKit/LibreOfficeKitInit.h
+++ b/include/LibreOfficeKit/LibreOfficeKitInit.h
@@ -280,13 +280,13 @@ static LibreOfficeKit *lok_init_2( const char *install_path,  const char *user_p
         }
         free( imp_lib );
         // dlhandle is "leaked"
-        // coverity[leaked_storage]
+        // coverity[leaked_storage] - on purpose
         return pSym( install_path );
     }
 
     free( imp_lib );
     // dlhandle is "leaked"
-    // coverity[leaked_storage]
+    // coverity[leaked_storage] - on purpose
     return pSym2( install_path, user_profile_url );
 }
 
diff --git a/include/vcl/bitmap.hxx b/include/vcl/bitmap.hxx
index 66a056448b53..d38aabac32f3 100644
--- a/include/vcl/bitmap.hxx
+++ b/include/vcl/bitmap.hxx
@@ -667,9 +667,9 @@ public:
                                 Bitmap& aNewBitmap,
                                 BitmapReadAccess const * pReadAcc,
                                 int aNumberOfContributions,
-                                const double* pWeights,
-                                int const * pPixels,
-                                const int* pCount );
+                                const std::vector<double>& rWeights,
+                                const std::vector<int>& rPixels,
+                                const std::vector<int>& rCounts );
 
     SAL_DLLPRIVATE bool     ImplMakeMono( sal_uInt8 cThreshold );
     SAL_DLLPRIVATE bool     ImplMakeGreyscales( sal_uInt16 nGreyscales );
@@ -704,10 +704,10 @@ public:
     SAL_DLLPRIVATE static void ImplBlurContributions(
                                 const int aSize,
                                 const int aNumberOfContributions,
-                                const double* pBlurVector,
-                                double*& pWeights,
-                                int*& pPixels,
-                                int*& pCount );
+                                const std::vector<double>& rBlurVector,
+                                std::vector<double>& pWeights,
+                                std::vector<int>& rPixels,
+                                std::vector<int>& rCounts );
 
 public:
 
diff --git a/pyuno/source/module/pyuno_dlopenwrapper.c b/pyuno/source/module/pyuno_dlopenwrapper.c
index 5654cb0f8f0a..44e711653e35 100644
--- a/pyuno/source/module/pyuno_dlopenwrapper.c
+++ b/pyuno/source/module/pyuno_dlopenwrapper.c
@@ -72,6 +72,7 @@ static void * load(void const * address, char const * symbol) {
         dlclose(h);
         abort();
     }
+    // coverity[leaked_storage] - this is on purpose
     return func;
 }
 
diff --git a/registry/source/reflwrit.cxx b/registry/source/reflwrit.cxx
index 45c5ae474a2c..7f82f9cd5172 100644
--- a/registry/source/reflwrit.cxx
+++ b/registry/source/reflwrit.cxx
@@ -376,11 +376,11 @@ void FieldEntry::setData(const OString&    name,
                          RTValueType        constValueType,
                          RTConstValueUnion  constValue)
 {
-    sal_Unicode * newValue = nullptr;
+    std::unique_ptr<sal_Unicode[]> newValue;
     if (constValueType == RT_TYPE_STRING && constValue.aString != nullptr) {
         sal_Int32 n = rtl_ustr_getLength(constValue.aString) + 1;
-        newValue = new sal_Unicode[n];
-        memcpy(newValue, constValue.aString, n * sizeof (sal_Unicode));
+        newValue.reset(new sal_Unicode[n]);
+        memcpy(newValue.get(), constValue.aString, n * sizeof (sal_Unicode));
     }
 
     m_name = name;
@@ -406,7 +406,7 @@ void FieldEntry::setData(const OString&    name,
             m_constValue.aString = NULL_WSTRING;
         else
         {
-            m_constValue.aString = newValue;
+            m_constValue.aString = newValue.release();
         }
     }
     else
diff --git a/registry/source/regimpl.cxx b/registry/source/regimpl.cxx
index 6dec181933ea..260c7e9d2a7e 100644
--- a/registry/source/regimpl.cxx
+++ b/registry/source/regimpl.cxx
@@ -21,6 +21,7 @@
 #include "regimpl.hxx"
 
 #include <memory>
+#include <vector>
 #include <string.h>
 #include <stdio.h>
 
@@ -323,8 +324,7 @@ void dumpType(typereg::Reader const & reader, OString const & indent) {
             printf(
                 "%s    parameter count: %u\n", indent.getStr(),
                 static_cast< unsigned int >(reader.getMethodParameterCount(i)));
-            // coverity[tainted_data] cid#1215304 unhelpfully warns about an
-            // untrusted loop bound here:
+            // coverity[tainted_data] - cid#1215304 unhelpfully warns about untrusted loop bound
             for (sal_uInt16 j = 0; j < reader.getMethodParameterCount(i); ++j)
             {
                 printf(
@@ -365,8 +365,7 @@ void dumpType(typereg::Reader const & reader, OString const & indent) {
             printf(
                 "%s    exception count: %u\n", indent.getStr(),
                 static_cast< unsigned int >(reader.getMethodExceptionCount(i)));
-            // coverity[tainted_data] cid#1215304 unhelpfully warns about an
-            // untrusted loop bound here:
+            // coverity[tainted_data] - cid#1215304 unhelpfully warns about untrusted loop bound
             for (sal_uInt16 j = 0; j < reader.getMethodExceptionCount(i); ++j)
             {
                 printf(
@@ -903,7 +902,6 @@ RegError ORegistry::loadAndSaveValue(ORegKey* pTargetKey,
                                      bool bReport)
 {
     OStoreStream    rValue;
-    sal_uInt8*      pBuffer;
     RegValueType    valueType;
     sal_uInt32      valueSize;
     sal_uInt32      nSize;
@@ -937,37 +935,32 @@ RegError ORegistry::loadAndSaveValue(ORegKey* pTargetKey,
         return RegError::VALUE_NOT_EXISTS;
     }
 
-    pBuffer = static_cast<sal_uInt8*>(rtl_allocateMemory(VALUE_HEADERSIZE));
+    std::vector<sal_uInt8> aBuffer(VALUE_HEADERSIZE);
 
     sal_uInt32  rwBytes;
-    if (rValue.readAt(0, pBuffer, VALUE_HEADERSIZE, rwBytes))
+    if (rValue.readAt(0, aBuffer.data(), VALUE_HEADERSIZE, rwBytes))
     {
-        rtl_freeMemory(pBuffer);
         return RegError::INVALID_VALUE;
     }
     if (rwBytes != VALUE_HEADERSIZE)
     {
-        rtl_freeMemory(pBuffer);
         return RegError::INVALID_VALUE;
     }
 
     RegError _ret = RegError::NO_ERROR;
-    sal_uInt8   type = *pBuffer;
-    valueType = (RegValueType)type;
-    readUINT32(pBuffer+VALUE_TYPEOFFSET, valueSize);
-    rtl_freeMemory(pBuffer);
+    sal_uInt8   type = aBuffer[0];
+    valueType = static_cast<RegValueType>(type);
+    readUINT32(aBuffer.data() + VALUE_TYPEOFFSET, valueSize);
 
     nSize = VALUE_HEADERSIZE + valueSize;
-    pBuffer = static_cast<sal_uInt8*>(rtl_allocateMemory(nSize));
+    aBuffer.resize(nSize);
 
-    if (rValue.readAt(0, pBuffer, nSize, rwBytes))
+    if (rValue.readAt(0, aBuffer.data(), nSize, rwBytes))
     {
-        rtl_freeMemory(pBuffer);
         return RegError::INVALID_VALUE;
     }
     if (rwBytes != nSize)
     {
-        rtl_freeMemory(pBuffer);
         return RegError::INVALID_VALUE;
     }
 
@@ -978,19 +971,17 @@ RegError ORegistry::loadAndSaveValue(ORegKey* pTargetKey,
         if (valueType == RegValueType::BINARY)
         {
             _ret = checkBlop(
-                rValue, sTargetPath, valueSize, pBuffer+VALUE_HEADEROFFSET,
+                rValue, sTargetPath, valueSize, aBuffer.data() + VALUE_HEADEROFFSET,
                 bReport);
             if (_ret != RegError::NO_ERROR)
             {
                 if (_ret == RegError::MERGE_ERROR ||
                     (_ret == RegError::MERGE_CONFLICT && bWarnings))
                 {
-                    rtl_freeMemory(pBuffer);
                     return _ret;
                 }
             } else
             {
-                rtl_freeMemory(pBuffer);
                 return _ret;
             }
         }
@@ -998,23 +989,19 @@ RegError ORegistry::loadAndSaveValue(ORegKey* pTargetKey,
 
     if (rValue.create(rTargetFile, sTargetPath, valueName, storeAccessMode::Create))
     {
-        rtl_freeMemory(pBuffer);
         return RegError::INVALID_VALUE;
     }
-    if (rValue.writeAt(0, pBuffer, nSize, rwBytes))
+    if (rValue.writeAt(0, aBuffer.data(), nSize, rwBytes))
     {
-        rtl_freeMemory(pBuffer);
         return RegError::INVALID_VALUE;
     }
 
     if (rwBytes != nSize)
     {
-        rtl_freeMemory(pBuffer);
         return RegError::INVALID_VALUE;
     }
     pTargetKey->setModified();
 
-    rtl_freeMemory(pBuffer);
     return _ret;
 }
 
@@ -1031,33 +1018,30 @@ RegError ORegistry::checkBlop(OStoreStream& rValue,
         return RegError::INVALID_VALUE;
     }
 
-    sal_uInt8*      pBuffer = static_cast<sal_uInt8*>(rtl_allocateMemory(VALUE_HEADERSIZE));
+    std::vector<sal_uInt8> aBuffer(VALUE_HEADERSIZE);
     RegValueType    valueType;
     sal_uInt32      valueSize;
     sal_uInt32      rwBytes;
     OString         targetPath(OUStringToOString(sTargetPath, RTL_TEXTENCODING_UTF8));
 
-    if (!rValue.readAt(0, pBuffer, VALUE_HEADERSIZE, rwBytes) &&
+    if (!rValue.readAt(0, aBuffer.data(), VALUE_HEADERSIZE, rwBytes) &&
         (rwBytes == VALUE_HEADERSIZE))
     {
-        sal_uInt8 type = *pBuffer;
-        valueType = (RegValueType)type;
-        readUINT32(pBuffer+VALUE_TYPEOFFSET, valueSize);
-        rtl_freeMemory(pBuffer);
+        sal_uInt8 type = aBuffer[0];
+        valueType = static_cast<RegValueType>(type);
+        readUINT32(aBuffer.data() + VALUE_TYPEOFFSET, valueSize);
 
         if (valueType == RegValueType::BINARY)
         {
-            pBuffer = static_cast<sal_uInt8*>(rtl_allocateMemory(valueSize));
-            if (!rValue.readAt(VALUE_HEADEROFFSET, pBuffer, valueSize, rwBytes) &&
+            aBuffer.resize(valueSize);
+            if (!rValue.readAt(VALUE_HEADEROFFSET, aBuffer.data(), valueSize, rwBytes) &&
                 (rwBytes == valueSize))
             {
-                RegistryTypeReader reader2(pBuffer, valueSize);
+                RegistryTypeReader reader2(aBuffer.data(), valueSize);
 
                 if ((reader.getTypeClass() != reader2.getTypeClass())
                     || reader2.getTypeClass() == RT_TYPE_INVALID)
                 {
-                    rtl_freeMemory(pBuffer);
-
                     if (bReport)
                     {
                         fprintf(stdout, "ERROR: values of blop from key \"%s\" has different types.\n",
@@ -1073,22 +1057,17 @@ RegError ORegistry::checkBlop(OStoreStream& rValue,
                     {
                         mergeModuleValue(rValue, reader, reader2);
 
-                        rtl_freeMemory(pBuffer);
                         return RegError::NO_ERROR;
                     } else
                     if (reader2.getFieldCount() > 0)
                     {
-                        rtl_freeMemory(pBuffer);
                         return RegError::NO_ERROR;
                     } else
                     {
-                        rtl_freeMemory(pBuffer);
                         return RegError::MERGE_CONFLICT;
                     }
                 } else
                 {
-                    rtl_freeMemory(pBuffer);
-
                     if (bReport)
                     {
                         fprintf(stderr, "WARNING: value of key \"%s\" already exists.\n",
@@ -1098,7 +1077,6 @@ RegError ORegistry::checkBlop(OStoreStream& rValue,
                 }
             } else
             {
-                rtl_freeMemory(pBuffer);
                 if (bReport)
                 {
                     fprintf(stderr, "ERROR: values of key \"%s\" contains bad data.\n",
@@ -1108,7 +1086,6 @@ RegError ORegistry::checkBlop(OStoreStream& rValue,
             }
         } else
         {
-            rtl_freeMemory(pBuffer);
             if (bReport)
             {
                 fprintf(stderr, "ERROR: values of key \"%s\" has different types.\n",
@@ -1118,7 +1095,6 @@ RegError ORegistry::checkBlop(OStoreStream& rValue,
         }
     } else
     {
-        rtl_freeMemory(pBuffer);
         return RegError::INVALID_VALUE;
     }
 }
@@ -1189,27 +1165,23 @@ RegError ORegistry::mergeModuleValue(OStoreStream& rTargetValue,
         const sal_uInt8*    pBlop = writer.getBlop();
         sal_uInt32          aBlopSize = writer.getBlopSize();
 
-        sal_uInt8   type = (sal_uInt8)RegValueType::BINARY;
-        sal_uInt8*  pBuffer = static_cast<sal_uInt8*>(rtl_allocateMemory(VALUE_HEADERSIZE + aBlopSize));
+        sal_uInt8   type = sal_uInt8(RegValueType::BINARY);
+        std::vector<sal_uInt8> aBuffer(VALUE_HEADERSIZE + aBlopSize);
 
-        memcpy(pBuffer, &type, 1);
-        writeUINT32(pBuffer+VALUE_TYPEOFFSET, aBlopSize);
-        memcpy(pBuffer+VALUE_HEADEROFFSET, pBlop, aBlopSize);
+        memcpy(aBuffer.data(), &type, 1);
+        writeUINT32(aBuffer.data() + VALUE_TYPEOFFSET, aBlopSize);
+        memcpy(aBuffer.data() + VALUE_HEADEROFFSET, pBlop, aBlopSize);
 
         sal_uInt32  rwBytes;
-        if (rTargetValue.writeAt(0, pBuffer, VALUE_HEADERSIZE+aBlopSize, rwBytes))
+        if (rTargetValue.writeAt(0, aBuffer.data(), VALUE_HEADERSIZE+aBlopSize, rwBytes))
         {
-            rtl_freeMemory(pBuffer);
             return RegError::INVALID_VALUE;
         }
 
         if (rwBytes != VALUE_HEADERSIZE+aBlopSize)
         {
-            rtl_freeMemory(pBuffer);
             return RegError::INVALID_VALUE;
         }
-
-        rtl_freeMemory(pBuffer);
     }
     return RegError::NO_ERROR;
 }
@@ -1325,7 +1297,6 @@ RegError ORegistry::dumpRegistry(RegKeyHandle hKey) const
 RegError ORegistry::dumpValue(const OUString& sPath, const OUString& sName, sal_Int16 nSpc) const
 {
     OStoreStream    rValue;
-    sal_uInt8*      pBuffer;
     sal_uInt32      valueSize;
     RegValueType    valueType;
     OUString        sFullPath(sPath);
@@ -1348,33 +1319,29 @@ RegError ORegistry::dumpValue(const OUString& sPath, const OUString& sName, sal_
         return RegError::VALUE_NOT_EXISTS;
     }
 
-    pBuffer = static_cast<sal_uInt8*>(rtl_allocateMemory(VALUE_HEADERSIZE));
+    std::vector<sal_uInt8> aBuffer(VALUE_HEADERSIZE);
 
     sal_uInt32  rwBytes;
-    if (rValue.readAt(0, pBuffer, VALUE_HEADERSIZE, rwBytes))
+    if (rValue.readAt(0, aBuffer.data(), VALUE_HEADERSIZE, rwBytes))
     {
-        rtl_freeMemory(pBuffer);
         return RegError::INVALID_VALUE;
     }
     if (rwBytes != (VALUE_HEADERSIZE))
     {
-        rtl_freeMemory(pBuffer);
         return RegError::INVALID_VALUE;
     }
 
-    sal_uInt8 type = *pBuffer;
-    valueType = (RegValueType)type;
-    readUINT32(pBuffer+VALUE_TYPEOFFSET, valueSize);
+    sal_uInt8 type = aBuffer[0];
+    valueType = static_cast<RegValueType>(type);
+    readUINT32(aBuffer.data() + VALUE_TYPEOFFSET, valueSize);
 
-    pBuffer = static_cast<sal_uInt8*>(rtl_allocateMemory(valueSize));
-    if (rValue.readAt(VALUE_HEADEROFFSET, pBuffer, valueSize, rwBytes))
+    aBuffer.resize(valueSize);
+    if (rValue.readAt(VALUE_HEADEROFFSET, aBuffer.data(), valueSize, rwBytes))
     {
-        rtl_freeMemory(pBuffer);
         return RegError::INVALID_VALUE;
     }
     if (rwBytes != valueSize)
     {
-        rtl_freeMemory(pBuffer);
         return RegError::INVALID_VALUE;
     }
 
@@ -1393,14 +1360,14 @@ RegError ORegistry::dumpValue(const OUString& sPath, const OUString& sName, sal_
                 fprintf(stdout, "%s       Data = ", indent);
 
                 sal_Int32 value;
-                readINT32(pBuffer, value);
+                readINT32(aBuffer.data(), value);
                 fprintf(stdout, "%ld\n", sal::static_int_cast< long >(value));
             }
             break;
         case RegValueType::STRING:
             {
                 sal_Char* value = static_cast<sal_Char*>(rtl_allocateMemory(valueSize));
-                readUtf8(pBuffer, value, valueSize);
+                readUtf8(aBuffer.data(), value, valueSize);
                 fprintf(stdout, "%sValue: Type = RegValueType::STRING\n", indent);
                 fprintf(
                     stdout, "%s       Size = %lu\n", indent,
@@ -1419,7 +1386,7 @@ RegError ORegistry::dumpValue(const OUString& sPath, const OUString& sName, sal_
                 fprintf(stdout, "%s       Data = ", indent);
 
                 std::unique_ptr<sal_Unicode[]> value(new sal_Unicode[size]);
-                readString(pBuffer, value.get(), size);
+                readString(aBuffer.data(), value.get(), size);
 
                 OString uStr = OUStringToOString(value.get(), RTL_TEXTENCODING_UTF8);
                 fprintf(stdout, "L\"%s\"\n", uStr.getStr());
@@ -1433,7 +1400,7 @@ RegError ORegistry::dumpValue(const OUString& sPath, const OUString& sName, sal_
                     sal::static_int_cast< unsigned long >(valueSize));
                 fprintf(stdout, "%s       Data = ", indent);
                 dumpType(
-                    typereg::Reader(pBuffer, valueSize),
+                    typereg::Reader(aBuffer.data(), valueSize),
                     sIndent + "              ");
             }
             break;
@@ -1442,7 +1409,7 @@ RegError ORegistry::dumpValue(const OUString& sPath, const OUString& sName, sal_
                 sal_uInt32 offset = 4; // initial 4 bytes for the size of the array
                 sal_uInt32 len = 0;
 
-                readUINT32(pBuffer, len);
+                readUINT32(aBuffer.data(), len);
 
                 fprintf(stdout, "%sValue: Type = RegValueType::LONGLIST\n", indent);
                 fprintf(
@@ -1456,7 +1423,7 @@ RegError ORegistry::dumpValue(const OUString& sPath, const OUString& sName, sal_
                 sal_Int32 longValue;
                 for (sal_uInt32 i=0; i < len; i++)
                 {
-                    readINT32(pBuffer+offset, longValue);
+                    readINT32(aBuffer.data() + offset, longValue);
 
                     if (offset > 4)
                         fprintf(stdout, "%s              ", indent);
@@ -1475,7 +1442,7 @@ RegError ORegistry::dumpValue(const OUString& sPath, const OUString& sName, sal_
                 sal_uInt32 sLen = 0;
                 sal_uInt32 len = 0;
 
-                readUINT32(pBuffer, len);
+                readUINT32(aBuffer.data(), len);
 
                 fprintf(stdout, "%sValue: Type = RegValueType::STRINGLIST\n", indent);
                 fprintf(
@@ -1488,12 +1455,12 @@ RegError ORegistry::dumpValue(const OUString& sPath, const OUString& sName, sal_
 
                 for (sal_uInt32 i=0; i < len; i++)
                 {
-                    readUINT32(pBuffer+offset, sLen);
+                    readUINT32(aBuffer.data() + offset, sLen);
 
                     offset += 4; // 4 bytes (sal_uInt32) for the string size
 
                     sal_Char *pValue = static_cast<sal_Char*>(rtl_allocateMemory(sLen));
-                    readUtf8(pBuffer+offset, pValue, sLen);
+                    readUtf8(aBuffer.data() + offset, pValue, sLen);
 
                     if (offset > 8)
                         fprintf(stdout, "%s              ", indent);
@@ -1512,7 +1479,7 @@ RegError ORegistry::dumpValue(const OUString& sPath, const OUString& sName, sal_
                 sal_uInt32 sLen = 0;
                 sal_uInt32 len = 0;
 
-                readUINT32(pBuffer, len);
+                readUINT32(aBuffer.data(), len);
 
                 fprintf(stdout, "%sValue: Type = RegValueType::UNICODELIST\n", indent);
                 fprintf(
@@ -1526,12 +1493,12 @@ RegError ORegistry::dumpValue(const OUString& sPath, const OUString& sName, sal_
                 OString uStr;
                 for (sal_uInt32 i=0; i < len; i++)
                 {
-                    readUINT32(pBuffer+offset, sLen);
+                    readUINT32(aBuffer.data() + offset, sLen);
 
                     offset += 4; // 4 bytes (sal_uInt32) for the string size
 
                     sal_Unicode *pValue = static_cast<sal_Unicode*>(rtl_allocateMemory((sLen / 2) * sizeof(sal_Unicode)));
-                    readString(pBuffer+offset, pValue, sLen);
+                    readString(aBuffer.data() + offset, pValue, sLen);
 
                     if (offset > 8)
                         fprintf(stdout, "%s              ", indent);
@@ -1552,7 +1519,6 @@ RegError ORegistry::dumpValue(const OUString& sPath, const OUString& sName, sal_
 
     fprintf(stdout, "\n");
 
-    rtl_freeMemory(pBuffer);
     return RegError::NO_ERROR;
 }
 
diff --git a/sal/osl/unx/file.cxx b/sal/osl/unx/file.cxx
index de36b3d26a9c..d2b59dfb2851 100644
--- a/sal/osl/unx/file.cxx
+++ b/sal/osl/unx/file.cxx
@@ -1148,10 +1148,10 @@ const off_t MAX_OFF_T = std::numeric_limits< off_t >::max();
 
 namespace {
 
-//coverity[result_independent_of_operands]
+// coverity[result_independent_of_operands] - crossplatform requirement
 template<typename T> bool exceedsMaxOffT(T n) { return n > MAX_OFF_T; }
 
-//coverity[result_independent_of_operands]
+// coverity[result_independent_of_operands] - crossplatform requirement
 template<typename T> bool exceedsMinOffT(T n)
 { return n < std::numeric_limits<off_t>::min(); }
 
diff --git a/sal/osl/unx/pipe.cxx b/sal/osl/unx/pipe.cxx
index e577e89608ba..aae01fd36439 100644
--- a/sal/osl/unx/pipe.cxx
+++ b/sal/osl/unx/pipe.cxx
@@ -287,10 +287,11 @@ oslPipe SAL_CALL osl_psz_createPipe(const sal_Char *pszPipeName, oslPipeOptions
         if (listen(pPipe->m_Socket, 5) < 0)
         {
             SAL_WARN("sal.osl.pipe", "listen() failed: " << strerror(errno));
-            // coverity[toctou] cid#1255391 warns about unlink(name) after
-            // stat(name, &status) above, but the intervening call to bind makes
-            // those two clearly unrelated, as it would fail if name existed at
-            // that point in time:
+            // cid#1255391 warns about unlink(name) after stat(name, &status)
+            // above, but the intervening call to bind makes those two clearly
+            // unrelated, as it would fail if name existed at that point in
+            // time:
+            // coverity[toctou] - this is bogus
             unlink(name);   /* remove filesystem entry */
             close(pPipe->m_Socket);
             destroyPipeImpl(pPipe);
diff --git a/sal/osl/unx/profile.cxx b/sal/osl/unx/profile.cxx
index a3d029e94da2..0671a80d264d 100644
--- a/sal/osl/unx/profile.cxx
+++ b/sal/osl/unx/profile.cxx
@@ -181,6 +181,7 @@ static oslProfile SAL_CALL osl_psz_openProfile(const sal_Char *pszProfileName, o
     if (pProfile->m_pFile == nullptr)
         closeFileImpl(pFile,pProfile->m_Flags);
 
+    // coverity[leaked_storage] - pFile is not leaked
     return pProfile;
 }
 
diff --git a/sal/osl/w32/file.cxx b/sal/osl/w32/file.cxx
index 7c0b6674c23f..106e160f894e 100644
--- a/sal/osl/w32/file.cxx
+++ b/sal/osl/w32/file.cxx
@@ -776,7 +776,7 @@ oslFileError SAL_CALL osl_closeFile(oslFileHandle Handle)
 
 namespace {
 
-//coverity[result_independent_of_operands]
+// coverity[result_independent_of_operands] - crossplatform requirement
 template<typename T> bool exceedsMaxSIZE_T(T n)
 { return n > std::numeric_limits< SIZE_T >::max(); }
 
@@ -930,7 +930,7 @@ LONGLONG const g_limit_longlong = std::numeric_limits< LONGLONG >::max();
 
 namespace {
 
-//coverity[result_independent_of_operands]
+// coverity[result_independent_of_operands] - crossplatform requirement
 template<typename T> bool exceedsMaxLONGLONG(T n)
 { return n > g_limit_longlong; }
 
diff --git a/sal/rtl/alloc_arena.cxx b/sal/rtl/alloc_arena.cxx
index 373de6d51ad9..4967fac93293 100644
--- a/sal/rtl/alloc_arena.cxx
+++ b/sal/rtl/alloc_arena.cxx
@@ -258,7 +258,7 @@ void rtl_arena_hash_rescale(
                 rtl_arena_segment_type  * next = curr->m_fnext;
                 rtl_arena_segment_type ** head;
 
-                // coverity[negative_shift]
+                // coverity[negative_shift] - bogus
                 head = &(arena->m_hash_table[RTL_ARENA_HASH_INDEX(arena, curr->m_addr)]);
                 curr->m_fnext = (*head);
                 (*head) = curr;
diff --git a/sal/rtl/alloc_cache.cxx b/sal/rtl/alloc_cache.cxx
index 091a5bf774ee..6ffc506e2a6e 100644
--- a/sal/rtl/alloc_cache.cxx
+++ b/sal/rtl/alloc_cache.cxx
@@ -829,7 +829,7 @@ void rtl_cache_deactivate(rtl_cache_type * cache)
         /* cleanup cpu layer */
         if ((mag = cache->m_cpu_curr))
         {
-            // coverity[missing_lock]
+            // coverity[missing_lock] - locking is fine
             cache->m_cpu_curr = nullptr;
             rtl_cache_magazine_clear (cache, mag);
             rtl_cache_free (mag_cache, mag);
@@ -837,7 +837,7 @@ void rtl_cache_deactivate(rtl_cache_type * cache)
 
         if ((mag = cache->m_cpu_prev))
         {
-            // coverity[missing_lock]
+            // coverity[missing_lock] - locking is fine
             cache->m_cpu_prev = nullptr;
             rtl_cache_magazine_clear (cache, mag);
             rtl_cache_free (mag_cache, mag);
@@ -1279,7 +1279,7 @@ static void rtl_cache_depot_wsupdate(
             RTL_MEMORY_LOCK_ACQUIRE(&(cache->m_depot_lock));
         }
     }
-    // coverity[missing_unlock]
+    // coverity[missing_unlock] - locking is fine
 }
 
 /**
diff --git a/sc/inc/dpobject.hxx b/sc/inc/dpobject.hxx
index 39299c79ab26..814ad49e86c3 100644
--- a/sc/inc/dpobject.hxx
+++ b/sc/inc/dpobject.hxx
@@ -391,7 +391,7 @@ public:
     OUString CreateNewName() const;
 
     void FreeTable(const ScDPObject* pDPObj);
-    SC_DLLPUBLIC bool InsertNewTable(ScDPObject* pDPObj);
+    SC_DLLPUBLIC void InsertNewTable(ScDPObject* pDPObj);
     SC_DLLPUBLIC bool HasTable(const ScDPObject* pDPObj) const;
 
     SC_DLLPUBLIC SheetCaches& GetSheetCaches();
diff --git a/sc/qa/unit/ucalc_pivottable.cxx b/sc/qa/unit/ucalc_pivottable.cxx
index 404de5d06c14..dbf991387fef 100644
--- a/sc/qa/unit/ucalc_pivottable.cxx
+++ b/sc/qa/unit/ucalc_pivottable.cxx
@@ -221,8 +221,7 @@ void Test::testPivotTable()
         m_pDoc, ScRange(nCol1, nRow1, 0, nCol2, nRow2, 0), aFields, nFieldCount, false);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new datapilot object into document", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -247,7 +246,7 @@ void Test::testPivotTable()
             { "Total Result", "50", "57", "23", "130" }
         };
 
-        bSuccess = checkDPTableOutput<5>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output");
+        bool bSuccess = checkDPTableOutput<5>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
     CPPUNIT_ASSERT_EQUAL_MESSAGE("There should be only one data cache.", size_t(1), pDPs->GetSheetCaches().size());
@@ -285,7 +284,7 @@ void Test::testPivotTable()
             { "Total Result", "50", "57", "23", "130" }
         };
 
-        bSuccess = checkDPTableOutput<5>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output (from old cache)");
+        bool bSuccess = checkDPTableOutput<5>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output (from old cache)");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -322,7 +321,7 @@ void Test::testPivotTable()
             { "Total Result", "300", "700", "1100", "2100" }
         };
 
-        bSuccess = checkDPTableOutput<5>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output (refreshed)");
+        bool bSuccess = checkDPTableOutput<5>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output (refreshed)");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -351,8 +350,7 @@ void Test::testPivotTable()
 
     pDPObj = createDPFromRange(
         m_pDoc, ScRange(nCol1, nRow1, 0, nCol2, nRow2, 0), aFields, nFieldCount, false);
-    bSuccess = pDPs->InsertNewTable(pDPObj);
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new datapilot object into document", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -402,8 +400,7 @@ void Test::testPivotTableLabels()
         m_pDoc, ScRange(nCol1, nRow1, 0, nCol2, nRow2, 0), aFields, nFieldCount, false);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new datapilot object into document", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -418,7 +415,7 @@ void Test::testPivotTableLabels()
             { "Total Result", "30", "20", "45", "95" }
         };
 
-        bSuccess = checkDPTableOutput<5>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output");
+        bool bSuccess = checkDPTableOutput<5>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -458,8 +455,7 @@ void Test::testPivotTableDateLabels()
         m_pDoc, ScRange(nCol1, nRow1, 0, nCol2, nRow2, 0), aFields, nFieldCount, false);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new datapilot object into document", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -476,7 +472,7 @@ void Test::testPivotTableDateLabels()
             { "Total Result", "30", "20", "45", "95" }
         };
 
-        bSuccess = checkDPTableOutput<5>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output");
+        bool bSuccess = checkDPTableOutput<5>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -541,8 +537,7 @@ void Test::testPivotTableFilters()
         m_pDoc, ScRange(nCol1, nRow1, 0, nCol2, nRow2, 0), aFields, nFieldCount, true);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new datapilot object into document", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -559,7 +554,7 @@ void Test::testPivotTableFilters()
             { "Sum - Val2", "80" }
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output (unfiltered)");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output (unfiltered)");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -593,7 +588,7 @@ void Test::testPivotTableFilters()
             { "Sum - Val2", "40" }
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output (filtered by page)");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output (filtered by page)");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -622,7 +617,7 @@ void Test::testPivotTableFilters()
             { "Sum - Val2", "20" }
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output (filtered by query)");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output (filtered by query)");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -645,7 +640,7 @@ void Test::testPivotTableFilters()
             { "Sum - Val2", "40" }
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output (filtered by page)");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output (filtered by page)");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -701,8 +696,7 @@ void Test::testPivotTableNamedSource()
     CPPUNIT_ASSERT_MESSAGE("Failed to create a new pivot table object.", pDPObj);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bSuccess = pDPs->InsertNewTable(pDPObj);
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new pivot table object into document.", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -977,9 +971,7 @@ void Test::testPivotTableDuplicateDataFields()
         m_pDoc, aDataRange, aFields, SAL_N_ELEMENTS(aFields), false);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new pivot table object into document.", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -997,7 +989,7 @@ void Test::testPivotTableDuplicateDataFields()
             { "Total Count - Value", nullptr, "10" },
         };
 
-        bSuccess = checkDPTableOutput<3>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output");
+        bool bSuccess = checkDPTableOutput<3>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1021,7 +1013,7 @@ void Test::testPivotTableDuplicateDataFields()
             { "Total Result", "411", "10" }
         };
 
-        bSuccess = checkDPTableOutput<3>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output");
+        bool bSuccess = checkDPTableOutput<3>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1070,9 +1062,7 @@ void Test::testPivotTableNormalGrouping()
         m_pDoc, aDataRange, aFields, SAL_N_ELEMENTS(aFields), false);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new pivot table object into document.", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -1092,7 +1082,7 @@ void Test::testPivotTableNormalGrouping()
             { "Total Result", "28" }
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Initial output without grouping");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Initial output without grouping");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1140,7 +1130,7 @@ void Test::testPivotTableNormalGrouping()
             { "Total Result", nullptr, "28" }
         };
 
-        bSuccess = checkDPTableOutput<3>(m_pDoc, aOutRange, aOutputCheck, "A, B, C grouped by Group1.");
+        bool bSuccess = checkDPTableOutput<3>(m_pDoc, aOutRange, aOutputCheck, "A, B, C grouped by Group1.");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1177,7 +1167,7 @@ void Test::testPivotTableNormalGrouping()
             { "Total Result", nullptr, "28" }
         };
 
-        bSuccess = checkDPTableOutput<3>(m_pDoc, aOutRange, aOutputCheck, "D, E, F grouped by Group2.");
+        bool bSuccess = checkDPTableOutput<3>(m_pDoc, aOutRange, aOutputCheck, "D, E, F grouped by Group2.");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1232,9 +1222,7 @@ void Test::testPivotTableNumberGrouping()
         m_pDoc, aDataRange, aFields, SAL_N_ELEMENTS(aFields), false);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new pivot table object into document.", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -1272,7 +1260,7 @@ void Test::testPivotTableNumberGrouping()
             { "Total Result", "1389" }
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Order grouped by numbers");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Order grouped by numbers");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1317,9 +1305,7 @@ void Test::testPivotTableDateGrouping()
         m_pDoc, aDataRange, aFields, SAL_N_ELEMENTS(aFields), false);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new pivot table object into document.", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -1389,7 +1375,7 @@ void Test::testPivotTableDateGrouping()
             { "Total Result", nullptr, nullptr, "36" },
         };
 
-        bSuccess = checkDPTableOutput<4>(m_pDoc, aOutRange, aOutputCheck, "Years, quarters and months date groups.");
+        bool bSuccess = checkDPTableOutput<4>(m_pDoc, aOutRange, aOutputCheck, "Years, quarters and months date groups.");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1417,7 +1403,7 @@ void Test::testPivotTableDateGrouping()
             { "Total Result", nullptr, nullptr, "10" },
         };
 
-        bSuccess = checkDPTableOutput<4>(m_pDoc, aOutRange, aOutputCheck, "Year 2012 data now hidden");
+        bool bSuccess = checkDPTableOutput<4>(m_pDoc, aOutRange, aOutputCheck, "Year 2012 data now hidden");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1446,7 +1432,7 @@ void Test::testPivotTableDateGrouping()
             { "Total Result", "36" }
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Remove all date grouping.");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Remove all date grouping.");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1490,9 +1476,7 @@ void Test::testPivotTableEmptyRows()
         m_pDoc, aDataRange, aFields, SAL_N_ELEMENTS(aFields), false);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new pivot table object into document.", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -1511,7 +1495,7 @@ void Test::testPivotTableEmptyRows()
             { "Total Result", "10" },
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Include empty rows");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Include empty rows");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1533,7 +1517,7 @@ void Test::testPivotTableEmptyRows()
             { "Total Result", "10" },
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Ignore empty rows");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Ignore empty rows");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1559,7 +1543,7 @@ void Test::testPivotTableEmptyRows()
             { "Total Result", "10" },
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Ignore empty rows");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Ignore empty rows");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1617,9 +1601,7 @@ void Test::testPivotTableTextNumber()
         m_pDoc, aDataRange, aFields, SAL_N_ELEMENTS(aFields), false);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new pivot table object into document.", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -1637,7 +1619,7 @@ void Test::testPivotTableTextNumber()
             { "Total Result", "10" },
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Text number field members");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Text number field members");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1662,7 +1644,7 @@ void Test::testPivotTableTextNumber()
             { "4", nullptr }
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Text number field members");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Text number field members");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1701,9 +1683,7 @@ void Test::testPivotTableCaseInsensitiveStrings()
         m_pDoc, aDataRange, aFields, SAL_N_ELEMENTS(aFields), false);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new pivot table object into document.", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -1718,7 +1698,7 @@ void Test::testPivotTableCaseInsensitiveStrings()
             { "Total Result", "3" },
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Case insensitive strings");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Case insensitive strings");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1792,9 +1772,7 @@ void Test::testPivotTableNumStability()
         m_pDoc, aDataRange, aFields, SAL_N_ELEMENTS(aFields), false);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new pivot table object into document.", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -1864,9 +1842,7 @@ void Test::testPivotTableFieldReference()
         m_pDoc, aDataRange, aFields, SAL_N_ELEMENTS(aFields), false);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new pivot table object into document.", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -1884,7 +1860,7 @@ void Test::testPivotTableFieldReference()
             { "Total Result", "15" },
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Field reference (none)");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Field reference (none)");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1911,7 +1887,7 @@ void Test::testPivotTableFieldReference()
             { "Total Result", nullptr },
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Field reference (difference from)");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Field reference (difference from)");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1931,7 +1907,7 @@ void Test::testPivotTableFieldReference()
             { "Total Result", nullptr },
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Field reference (% of)");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Field reference (% of)");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1951,7 +1927,7 @@ void Test::testPivotTableFieldReference()
             { "Total Result", nullptr },
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Field reference (% difference from)");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Field reference (% difference from)");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1971,7 +1947,7 @@ void Test::testPivotTableFieldReference()
             { "Total Result", nullptr },
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Field reference (Running total)");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Field reference (Running total)");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -1991,7 +1967,7 @@ void Test::testPivotTableFieldReference()
             { "Total Result", "100.00%" },
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Field reference (% of column)");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Field reference (% of column)");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -2105,9 +2081,7 @@ void Test::testFuncGETPIVOTDATA()
     }
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new pivot table object into document.", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -2122,7 +2096,7 @@ void Test::testFuncGETPIVOTDATA()
             { "Total Result", "21" },
         };
 
-        bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Pivot table created for GETPIVOTDATA");
+        bool bSuccess = checkDPTableOutput<2>(m_pDoc, aOutRange, aOutputCheck, "Pivot table created for GETPIVOTDATA");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -2168,8 +2142,7 @@ void Test::testFuncGETPIVOTDATA()
         pDPObj = createDPFromRange(m_pDoc, aDataRange, aFields, SAL_N_ELEMENTS(aFields), false);
     }
 
-    bSuccess = pDPs->InsertNewTable(pDPObj);
-    CPPUNIT_ASSERT_MESSAGE("InsertNewTable failed", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     aOutRange = refresh(pDPObj);
 
     {
@@ -2184,7 +2157,7 @@ void Test::testFuncGETPIVOTDATA()
             { "Total Count - Value", nullptr,               "6"  },
         };
 
-        bSuccess = checkDPTableOutput<3>(m_pDoc, aOutRange, aOutputCheck, "Pivot table refreshed");
+        bool bSuccess = checkDPTableOutput<3>(m_pDoc, aOutRange, aOutputCheck, "Pivot table refreshed");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -2264,9 +2237,7 @@ void Test::testFuncGETPIVOTDATALeafAccess()
     pDPObj = createDPFromRange(m_pDoc, aDataRange, aFields, SAL_N_ELEMENTS(aFields), false);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new pivot table object into document.", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -2283,7 +2254,7 @@ void Test::testFuncGETPIVOTDATALeafAccess()
             { "Total Result",  nullptr,         "10"          },
         };
 
-        bSuccess = checkDPTableOutput<3>(m_pDoc, aOutRange, aOutputCheck, "Pivot table refreshed");
+        bool bSuccess = checkDPTableOutput<3>(m_pDoc, aOutRange, aOutputCheck, "Pivot table refreshed");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -2361,8 +2332,7 @@ void Test::testPivotTableRepeatItemLabels()
         m_pDoc, ScRange(nCol1, nRow1, 0, nCol2, nRow2, 0), aFields, nFieldCount, false);
 
     ScDPCollection* pDPs = m_pDoc->GetDPCollection();
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new datapilot object into document", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.",
                            size_t(1), pDPs->GetCount());
     pDPObj->SetName(pDPs->CreateNewName());
@@ -2388,7 +2358,7 @@ void Test::testPivotTableRepeatItemLabels()
             { "Total Result", nullptr,         nullptr,      "220"         }
         };
 
-        bSuccess = checkDPTableOutput<4>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output");
+        bool bSuccess = checkDPTableOutput<4>(m_pDoc, aOutRange, aOutputCheck, "DataPilot table output");
         CPPUNIT_ASSERT_MESSAGE("Table output check failed", bSuccess);
     }
 
@@ -2442,15 +2412,13 @@ void Test::testPivotTableDPCollection()
 
     // Add 2 DP objects
     ScDPObject* pDPObj = createDPFromRange(m_pDoc, aDataRange , aFields, nFieldCount, false);
-    bool bSuccess = pDPs->InsertNewTable(pDPObj);
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new DP object into document", bSuccess);
+    pDPs->InsertNewTable(pDPObj);
     pDPObj->SetName("DP1"); // set custom name
 
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be only one data pilot table.", size_t(1), pDPs->GetCount());
 
     ScDPObject* pDPObj2 = createDPFromRange(m_pDoc, aDataRange, aFields, nFieldCount, false);
-    bSuccess = pDPs->InsertNewTable(pDPObj2);
-    CPPUNIT_ASSERT_MESSAGE("failed to insert a new DP object into document", bSuccess);
+    pDPs->InsertNewTable(pDPObj2);
     pDPObj2->SetName("DP2"); // set custom name
 
     CPPUNIT_ASSERT_EQUAL_MESSAGE("there should be two DP tables", size_t(2), pDPs->GetCount());
diff --git a/sc/source/core/data/dpobject.cxx b/sc/source/core/data/dpobject.cxx
index f86a608b156e..1cc9cf20f2ec 100644
--- a/sc/source/core/data/dpobject.cxx
+++ b/sc/source/core/data/dpobject.cxx
@@ -3797,7 +3797,7 @@ void ScDPCollection::FreeTable(const ScDPObject* pDPObject)
     maTables.erase(std::remove_if(maTables.begin(), maTables.end(), funcRemoveCondition), maTables.end());
 }
 
-bool ScDPCollection::InsertNewTable(ScDPObject* pDPObj)
+void ScDPCollection::InsertNewTable(ScDPObject* pDPObj)
 {
     const ScRange& rOutRange = pDPObj->GetOutRange();
     const ScAddress& s = rOutRange.aStart;
@@ -3805,7 +3805,6 @@ bool ScDPCollection::InsertNewTable(ScDPObject* pDPObj)
     mpDoc->ApplyFlagsTab(s.Col(), s.Row(), e.Col(), e.Row(), s.Tab(), ScMF::DpTable);
 
     maTables.push_back(std::unique_ptr<ScDPObject>(pDPObj));
-    return true;
 }
 
 bool ScDPCollection::HasTable(const ScDPObject* pDPObj) const
diff --git a/sc/source/core/tool/chgtrack.cxx b/sc/source/core/tool/chgtrack.cxx
index 67fe8aee6c41..1e461fed1ff4 100644
--- a/sc/source/core/tool/chgtrack.cxx
+++ b/sc/source/core/tool/chgtrack.cxx
@@ -339,8 +339,11 @@ bool ScChangeAction::IsDeletedIn( const ScChangeAction* p ) const
 void ScChangeAction::RemoveAllDeletedIn()
 {
     //TODO: Not from TopContent, but really this one
-    while ( pLinkDeletedIn )
-        delete pLinkDeletedIn; // Moves up by itself
+    while (pLinkDeletedIn)
+    {
+        // coverity[use_after_free] - Moves up by itself
+        delete pLinkDeletedIn;
+    }
 }
 
 bool ScChangeAction::IsDeletedInDelType( ScChangeActionType eDelType ) const
@@ -399,8 +402,11 @@ void ScChangeAction::SetDeletedIn( ScChangeAction* p )
 
 void ScChangeAction::RemoveAllDependent()
 {
-    while ( pLinkDependent )
-        delete pLinkDependent; // Moves up by itself
+    while (pLinkDependent)
+    {
+        // coverity[use_after_free] - Moves up by itself
+        delete pLinkDependent;
+    }
 }
 
 DateTime ScChangeAction::GetDateTime() const
@@ -828,8 +834,11 @@ ScChangeActionDel::ScChangeActionDel(
 ScChangeActionDel::~ScChangeActionDel()
 {
     DeleteCellEntries();
-    while ( pLinkMove )
+    while (pLinkMove)
+    {
+        // coverity[use_after_free] - Moves up by itself
         delete pLinkMove;
+    }
 }
 
 void ScChangeActionDel::AddContent( ScChangeActionContent* pContent )
@@ -1054,6 +1063,7 @@ void ScChangeActionDel::UndoCutOffMoves()
 {   // Restore cut off Moves; delete Entries/Links
     while ( pLinkMove )
     {
+        // coverity[deref_arg] - the call on delete pLinkMove at the block end Moves a new entry into pLinkMode by itself
         ScChangeActionMove* pMove = pLinkMove->GetMove();
         short nFrom = pLinkMove->GetCutOffFrom();
         short nTo = pLinkMove->GetCutOffTo();
diff --git a/sc/source/core/tool/compiler.cxx b/sc/source/core/tool/compiler.cxx
index 9e9edb77dc7a..58e3bbb69976 100644
--- a/sc/source/core/tool/compiler.cxx
+++ b/sc/source/core/tool/compiler.cxx
@@ -5697,6 +5697,7 @@ bool ScCompiler::HandleTableRef()
                     default:
                         ;   // nothing
                 }
+                // coverity[copy_paste_error] - this is correct, aStart in both aDBRange uses
                 if (aColRange.aStart.Row() != aDBRange.aStart.Row() || aColRange.aEnd.Row() != aDBRange.aStart.Row())
                     aRange = ScRange( ScAddress::INITIALIZE_INVALID);
                 else
diff --git a/sc/source/filter/xml/xmldpimp.cxx b/sc/source/filter/xml/xmldpimp.cxx
index c6d3581ca7a3..27c8804f8961 100644
--- a/sc/source/filter/xml/xmldpimp.cxx
+++ b/sc/source/filter/xml/xmldpimp.cxx
@@ -96,7 +96,7 @@ ScXMLDataPilotTableContext::ScXMLDataPilotTableContext( ScXMLImport& rImport,
                                       const rtl::Reference<sax_fastparser::FastAttributeList>& rAttrList ) :
     ScXMLImportContext( rImport ),
     pDoc(GetScImport().GetDocument()),
-    pDPObject(nullptr),
+    pDPSave(new ScDPSaveData()),
     pDPDimSaveData(nullptr),
     sDataPilotTableName(),
     sApplicationData(),
@@ -194,9 +194,6 @@ ScXMLDataPilotTableContext::ScXMLDataPilotTableContext( ScXMLImport& rImport,
             }
         }
     }
-
-    pDPObject = new ScDPObject(pDoc);
-    pDPSave.reset(new ScDPSaveData());
 }
 
 ScXMLDataPilotTableContext::~ScXMLDataPilotTableContext()
@@ -322,7 +319,7 @@ ScDPOutputGeometry::FieldType toFieldType(sheet::DataPilotFieldOrientation nOrie
 
 }
 
-void ScXMLDataPilotTableContext::SetButtons()
+void ScXMLDataPilotTableContext::SetButtons(ScDPObject* pDPObject)
 {
     ScDPOutputGeometry aGeometry(aTargetRangeAddress, bShowFilter);
     aGeometry.setColumnFieldCount(mnColFieldCount);
@@ -390,8 +387,7 @@ void ScXMLDataPilotTableContext::SetButtons()
         }
     }
 
-    if ( pDPObject )
-        pDPObject->RefreshAfterLoad();
+    pDPObject->RefreshAfterLoad();
 }
 
 void ScXMLDataPilotTableContext::SetSelectedPage( const OUString& rDimName, const OUString& rSelected )
@@ -455,6 +451,7 @@ void SAL_CALL ScXMLDataPilotTableContext::endFastElement( sal_Int32 /*nElement*/
     if (!bTargetRangeAddress)
         return;
 
+    ScDPObject* pDPObject(new ScDPObject(pDoc));
     pDPObject->SetName(sDataPilotTableName);
     pDPObject->SetTag(sApplicationData);
     pDPObject->SetOutRange(aTargetRangeAddress);
@@ -540,13 +537,9 @@ void SAL_CALL ScXMLDataPilotTableContext::endFastElement( sal_Int32 /*nElement*/
     if ( pDPCollection->GetByName(pDPObject->GetName()) )
         pDPObject->SetName( OUString() );     // ignore the invalid name, create a new name in AfterXMLLoading
 
-    if (!pDPCollection->InsertNewTable(pDPObject))
-    {
-        OSL_FAIL("cannot insert DPObject");
-        DELETEZ( pDPObject );
-    }
+    pDPCollection->InsertNewTable(pDPObject);
 
-    SetButtons();
+    SetButtons(pDPObject);
 }
 
 void ScXMLDataPilotTableContext::SetGrandTotal(
diff --git a/sc/source/filter/xml/xmldpimp.hxx b/sc/source/filter/xml/xmldpimp.hxx
index 9cc139e0f08f..3c9ff0911ce8 100644
--- a/sc/source/filter/xml/xmldpimp.hxx
+++ b/sc/source/filter/xml/xmldpimp.hxx
@@ -71,7 +71,6 @@ class ScXMLDataPilotTableContext : public ScXMLImportContext
         GrandTotalItem();
     };
     ScDocument*     pDoc;
-    ScDPObject*     pDPObject;
     std::unique_ptr<ScDPSaveData> pDPSave;
     std::unique_ptr<ScDPDimensionSaveData> pDPDimSaveData;
     GrandTotalItem  maRowGrandTotal;
@@ -139,7 +138,7 @@ public:
     void AddDimension(ScDPSaveDimension* pDim);
     void AddGroupDim(const ScDPSaveNumGroupDimension& aNumGroupDim);
     void AddGroupDim(const ScDPSaveGroupDimension& aGroupDim);
-    void SetButtons();
+    void SetButtons(ScDPObject* pDPObject);
     void SetSelectedPage( const OUString& rDimName, const OUString& rSelected );
 };
 
diff --git a/sc/source/ui/docshell/dbdocfun.cxx b/sc/source/ui/docshell/dbdocfun.cxx
index d518ff17c03a..ed6fa69b0d08 100644
--- a/sc/source/ui/docshell/dbdocfun.cxx
+++ b/sc/source/ui/docshell/dbdocfun.cxx
@@ -1431,9 +1431,7 @@ bool ScDBDocFunc::CreatePivotTable(const ScDPObject& rDPObj, bool bRecord, bool
         }
     }
 
-    if (!rDoc.GetDPCollection()->InsertNewTable(pDestObj.release()))
-        // Insertion into collection failed.
-        return false;
+    rDoc.GetDPCollection()->InsertNewTable(pDestObj.release());
 
     rDestObj.ReloadGroupTableData();
     rDestObj.SyncAllDimensionMembers();
diff --git a/sc/source/ui/undo/undodat.cxx b/sc/source/ui/undo/undodat.cxx
index b7a745a87d98..c84d38cc8c80 100644
--- a/sc/source/ui/undo/undodat.cxx
+++ b/sc/source/ui/undo/undodat.cxx
@@ -1442,11 +1442,7 @@ void ScUndoDataPilot::Undo()
         //  re-insert deleted object
 
         ScDPObject* pDestObj = new ScDPObject(*xOldDPObject);
-        if ( !rDoc.GetDPCollection()->InsertNewTable(pDestObj) )
-        {
-            OSL_FAIL("cannot insert DPObject");
-            DELETEZ( pDestObj );
-        }
+        rDoc.GetDPCollection()->InsertNewTable(pDestObj);
     }
 
     if (xNewUndoDoc)
diff --git a/sc/source/ui/view/viewdata.cxx b/sc/source/ui/view/viewdata.cxx
index e28704470b4e..8564c988336e 100644
--- a/sc/source/ui/view/viewdata.cxx
+++ b/sc/source/ui/view/viewdata.cxx
@@ -176,6 +176,7 @@ ScPositionHelper::getNearestByIndex(index_type nIndex) const
     }
 
     auto posLB = std::prev(posUB);
+    // coverity[copy_paste_error] - posUB is correct
     if (posUB == mData.end())
     {
         return *posLB;
@@ -206,6 +207,7 @@ ScPositionHelper::getNearestByPosition(long nPos) const
     }
 
     auto posLB = std::prev(posUB);
+    // coverity[copy_paste_error] - posUB is correct
     if (posUB == mData.end())
     {
         return *posLB;
diff --git a/sd/source/ui/animations/CustomAnimationPane.cxx b/sd/source/ui/animations/CustomAnimationPane.cxx
index c00aedf6c607..14bc19266ed2 100644
--- a/sd/source/ui/animations/CustomAnimationPane.cxx
+++ b/sd/source/ui/animations/CustomAnimationPane.cxx
@@ -2312,6 +2312,7 @@ void CustomAnimationPane::moveSelection( bool bUp )
             CustomAnimationEffectPtr pEffect = (*aIter++);
 
             EffectSequence::iterator aUpEffectPos( pSequence->find( pEffect ) );
+            // coverity[copy_paste_error] - this is correct, checking if it exists
             if( aUpEffectPos != rEffectSequence.end() )
             {
                 EffectSequence::iterator aInsertPos( rEffectSequence.erase( aUpEffectPos ) );
@@ -2342,6 +2343,7 @@ void CustomAnimationPane::moveSelection( bool bUp )
             CustomAnimationEffectPtr pEffect = (*aIter++);
 
             EffectSequence::iterator aDownEffectPos( pSequence->find( pEffect ) );
+            // coverity[copy_paste_error] - this is correct, checking if it exists
             if( aDownEffectPos != rEffectSequence.end() )
             {
                 EffectSequence::iterator aInsertPos( rEffectSequence.erase( aDownEffectPos ) );
diff --git a/sd/source/ui/unoidl/unosrch.cxx b/sd/source/ui/unoidl/unosrch.cxx
index a254bbe4a8b6..737710bcf4b2 100644
--- a/sd/source/ui/unoidl/unosrch.cxx
+++ b/sd/source/ui/unoidl/unosrch.cxx
@@ -56,11 +56,10 @@ class SearchContext_impl
 {
     uno::Reference< drawing::XShapes > mxShapes;
     sal_Int32 mnIndex;
-    SearchContext_impl* mpParent;
 
 public:
-    SearchContext_impl( uno::Reference< drawing::XShapes > const & xShapes, SearchContext_impl* pParent = nullptr )
-        : mxShapes( xShapes ), mnIndex( -1 ), mpParent( pParent ) {}
+    SearchContext_impl(uno::Reference<drawing::XShapes> const& xShapes)
+        : mxShapes( xShapes ), mnIndex( -1 ) {}
 
     uno::Reference< drawing::XShape > firstShape()
     {
@@ -78,8 +77,6 @@ public:
         }
         return xShape;
     }
-
-    SearchContext_impl* getParent() const { return mpParent; }
 };
 
 /* ================================================================= */
@@ -113,7 +110,7 @@ sal_Int32 SAL_CALL SdUnoSearchReplaceShape::replaceAll( const uno::Reference< ut
     uno::Reference< drawing::XShapes >  xShapes;
     uno::Reference< drawing::XShape >  xShape;
 
-    SearchContext_impl* pContext = nullptr;
+    std::vector<SearchContext_impl> aContexts;
     if(mpPage)
     {
         uno::Reference< drawing::XDrawPage > xPage( mpPage );
@@ -122,8 +119,8 @@ sal_Int32 SAL_CALL SdUnoSearchReplaceShape::replaceAll( const uno::Reference< ut
 
         if( xShapes.is() && (xShapes->getCount() > 0) )
         {
-            pContext = new SearchContext_impl( xShapes );
-            xShape = pContext->firstShape();
+            aContexts.push_back(SearchContext_impl(xShapes));
+            xShape = aContexts.back().firstShape();
         }
         else
         {
@@ -154,34 +151,24 @@ sal_Int32 SAL_CALL SdUnoSearchReplaceShape::replaceAll( const uno::Reference< ut
         uno::Reference< drawing::XShapes > xGroupShape( xShape, uno::UNO_QUERY );
         if( xGroupShape.is() && ( xGroupShape->getCount() > 0 ) )
         {
-            pContext = new SearchContext_impl( xGroupShape, pContext );
-            xShape = pContext->firstShape();
+            aContexts.push_back(SearchContext_impl(xGroupShape));
+            xShape = aContexts.back().firstShape();
         }
         else
         {
-            if( pContext )
-                xShape = pContext->nextShape();
+            if (!aContexts.empty())
+                xShape = aContexts.back().nextShape();
             else
                 xShape = nullptr;
         }
 
         // test parent contexts for next shape if none
         // is found in the current context
-        while( pContext && !xShape.is() )
+        while (!aContexts.empty() && !xShape.is())
         {
-            if( pContext->getParent() )
-            {
-                SearchContext_impl* pOldContext = pContext;
-                pContext = pContext->getParent();
-                delete pOldContext;
-                xShape = pContext->nextShape();
-            }
-            else
-            {
-                delete pContext;
-                pContext = nullptr;
-                xShape = nullptr;
-            }
+            aContexts.pop_back();
+            if (!aContexts.empty())
+                xShape = aContexts.back().nextShape();
         }
     }
 
@@ -210,7 +197,7 @@ uno::Reference< css::container::XIndexAccess > SAL_CALL SdUnoSearchReplaceShape:
     uno::Reference< drawing::XShapes >  xShapes;
     uno::Reference< drawing::XShape >  xShape;
 
-    SearchContext_impl* pContext = nullptr;
+    std::vector<SearchContext_impl> aContexts;
     if(mpPage)
     {
         uno::Reference< drawing::XDrawPage >  xPage( mpPage );
@@ -218,8 +205,8 @@ uno::Reference< css::container::XIndexAccess > SAL_CALL SdUnoSearchReplaceShape:
 
         if( xShapes.is() && xShapes->getCount() > 0 )
         {
-            pContext = new SearchContext_impl( xShapes );
-            xShape = pContext->firstShape();
+            aContexts.push_back(SearchContext_impl(xShapes));
+            xShape = aContexts.back().firstShape();
         }
         else
         {
@@ -259,34 +246,24 @@ uno::Reference< css::container::XIndexAccess > SAL_CALL SdUnoSearchReplaceShape:
 
         if( xGroupShape.is() && xGroupShape->getCount() > 0 )
         {
-            pContext = new SearchContext_impl( xGroupShape, pContext );
-            xShape = pContext->firstShape();
+            aContexts.push_back(SearchContext_impl(xGroupShape));
+            xShape = aContexts.back().firstShape();
         }
         else
         {
-            if( pContext )
-                xShape = pContext->nextShape();
+            if (!aContexts.empty())
+                xShape = aContexts.back().nextShape();
             else
                 xShape = nullptr;
         }
 
         // test parent contexts for next shape if none
         // is found in the current context
-        while( pContext && !xShape.is() )
+        while (!aContexts.empty() && !xShape.is())
         {
-            if( pContext->getParent() )
-            {
-                SearchContext_impl* pOldContext = pContext;
-                pContext = pContext->getParent();
-                delete pOldContext;
-                xShape = pContext->nextShape();
-            }
-            else
-            {
-                delete pContext;
-                pContext = nullptr;
-                xShape = nullptr;
-            }
+            aContexts.pop_back();
+            if (!aContexts.empty())
+                xShape = aContexts.back().nextShape();
         }
     }
 
diff --git a/sfx2/source/control/itemdel.cxx b/sfx2/source/control/itemdel.cxx
index 9ee76fd6a2bb..806b0895f2a5 100644
--- a/sfx2/source/control/itemdel.cxx
+++ b/sfx2/source/control/itemdel.cxx
@@ -77,7 +77,7 @@ void DeleteItemOnIdle(SfxPoolItem* pItem)
     DBG_ASSERT( 0 == pItem->GetRefCount(), "deleting item in use" );
     SfxItemDisruptor_Impl *pDesruptor = new SfxItemDisruptor_Impl(pItem);
     pDesruptor->LaunchDeleteOnIdle();
-    // coverity[leaked_storage] pDesruptor takes care of its own destruction at idle time
+    // coverity[leaked_storage] - pDesruptor takes care of its own destruction at idle time
 }
 
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/solenv/bin/pack_images.py b/solenv/bin/pack_images.py
index 0f493c8f3035..384b61db8bc6 100755
--- a/solenv/bin/pack_images.py
+++ b/solenv/bin/pack_images.py
@@ -512,7 +512,7 @@ def parse_image_list(imagelist_filenames):
 
                     if line.startswith('%MODULE%'):
                         key = line.replace('%MODULE%/', '')
-                        if key in global_image_list:
+                        if key in module_image_list:
                             module_image_list[key] += 1
                         else:
                             module_image_list[key] = 0
diff --git a/soltools/cpp/_unix.c b/soltools/cpp/_unix.c
index 7d15d57ed45a..2ee9215524a2 100644
--- a/soltools/cpp/_unix.c
+++ b/soltools/cpp/_unix.c
@@ -204,6 +204,7 @@ void
             error(FATAL, "Can't open output file %s", argv[optind + 1]);
 
         dup2(fdo, 1);
+        // coverity[leaked_handle] - on purpose
     }
     includelist[NINCLUDE - 1].always = 0;
     includelist[NINCLUDE - 1].file = dp;
diff --git a/soltools/mkdepend/parse.c b/soltools/mkdepend/parse.c
index b538c87be22b..7f87ca7e3529 100644
--- a/soltools/mkdepend/parse.c
+++ b/soltools/mkdepend/parse.c
@@ -158,6 +158,7 @@ int find_includes(struct filepointer *filep, struct inclist *file, struct inclis
             break;
         }
     }
+    // coverity[leaked_storage] - on purpose
     return -1;
 }
 
diff --git a/svtools/source/svhtml/htmlout.cxx b/svtools/source/svhtml/htmlout.cxx
index a4d030631398..4d3ff3006a73 100644
--- a/svtools/source/svhtml/htmlout.cxx
+++ b/svtools/source/svhtml/htmlout.cxx
@@ -465,7 +465,7 @@ static OString lcl_ConvertCharToHTML( sal_uInt32 c,
             // If the character could not be converted to the destination
             // character set, the UNICODE character is exported as character
             // entity.
-            // coverity[callee_ptr_arith]
+            // coverity[callee_ptr_arith] - its ok
             nLen = lcl_FlushContext(rContext, cBuffer, nFlags);
             sal_Char *pBuffer = cBuffer;
             while( nLen-- )
diff --git a/svx/source/gengal/gengal.sh b/svx/source/gengal/gengal.sh
index b4d10458650a..5f644c6702bb 100755
--- a/svx/source/gengal/gengal.sh
+++ b/svx/source/gengal/gengal.sh
@@ -55,8 +55,6 @@ for arg in "$@"
 do
   case "$arg" in
        -env:*) BOOTSTRAPVARS=$BOOTSTRAPVARS" ""$arg";;
-       -v) VERBOSE=true;;
-       --verbose) VERBOSE=true;;
   esac
 done
 
diff --git a/sw/source/core/text/itrform2.cxx b/sw/source/core/text/itrform2.cxx
index e762ab1f5842..68850b179d3f 100644
--- a/sw/source/core/text/itrform2.cxx
+++ b/sw/source/core/text/itrform2.cxx
@@ -722,6 +722,8 @@ void SwTextFormatter::BuildPortions( SwTextFormatInfo &rInf )
 
     // Reinit the tab overflow flag after the line
     rInf.SetTabOverflow( false );
+
+    // coverity[leaked_storage] - ownership is too complicated to hazard a fix, it definitely normally doesn't leak
 }
 
 void SwTextFormatter::CalcAdjustLine( SwLineLayout *pCurrent )
diff --git a/sw/source/ui/index/cnttab.cxx b/sw/source/ui/index/cnttab.cxx
index bd3693404b76..934676e47033 100644
--- a/sw/source/ui/index/cnttab.cxx
+++ b/sw/source/ui/index/cnttab.cxx
@@ -4047,8 +4047,9 @@ bool SwEntryBrowseBox::SaveModified()
         pController = m_xCheckController.get();
         bVal = static_cast< ::svt::CheckBoxCellController*>(pController)->GetCheckBox().IsChecked();
     }
-    AutoMarkEntry* pEntry = (nRow >= m_Entries.size()) ? new AutoMarkEntry
-                                                       : m_Entries[nRow].get();
+    const bool bAddEntry = nRow >= m_Entries.size();
+    std::unique_ptr<AutoMarkEntry> xNewEntry(bAddEntry ? new AutoMarkEntry : nullptr);
+    AutoMarkEntry* pEntry = bAddEntry ? xNewEntry.get() : m_Entries[nRow].get();
     switch(nCol)
     {
         case  ITEM_SEARCH       : pEntry->sSearch = sNew; break;
@@ -4059,9 +4060,9 @@ bool SwEntryBrowseBox::SaveModified()
         case  ITEM_CASE         : pEntry->bCase = bVal; break;
         case  ITEM_WORDONLY     : pEntry->bWord = bVal; break;
     }
-    if (nRow >= m_Entries.size())
+    if (bAddEntry)
     {
-        m_Entries.push_back(std::unique_ptr<AutoMarkEntry>(pEntry));
+        m_Entries.push_back(std::move(xNewEntry));
         RowInserted(nRow, 1, true, true);
         if(nCol < ITEM_WORDONLY)
         {
diff --git a/unoidl/source/legacyprovider.cxx b/unoidl/source/legacyprovider.cxx
index a7eb47fc7a88..eb9462c733f2 100644
--- a/unoidl/source/legacyprovider.cxx
+++ b/unoidl/source/legacyprovider.cxx
@@ -259,9 +259,9 @@ rtl::Reference< Entity > readEntity(
                             {
                                 sal_uInt16 m
                                     = reader.getMethodExceptionCount(k);
-                                // coverity[tainted_data] cid#1213376
-                                // unhelpfully warns about an untrusted loop
-                                // bound here:
+                                // cid#1213376 unhelpfully warns about an
+                                // untrusted loop bound here:
+                                // coverity[tainted_data] - trusted data source
                                 for (sal_uInt16 l = 0; l != m; ++l) {
                                     getExcs.push_back(
                                         reader.getMethodExceptionTypeName(k, l).
@@ -273,9 +273,9 @@ rtl::Reference< Entity > readEntity(
                             {
                                 sal_uInt16 m
                                     = reader.getMethodExceptionCount(k);
-                                // coverity[tainted_data] cid#1213376
-                                // unhelpfully warns about an untrusted loop
-                                // bound here:
+                                // cid#1213376 unhelpfully warns about an
+                                // untrusted loop bound here:
+                                // coverity[tainted_data] - trusted data source
                                 for (sal_uInt16 l = 0; l != m; ++l) {
                                     setExcs.push_back(
                                         reader.getMethodExceptionTypeName(k, l).
@@ -309,8 +309,9 @@ rtl::Reference< Entity > readEntity(
                     std::vector< InterfaceTypeEntity::Method::Parameter >
                         params;
                     sal_uInt16 m = reader.getMethodParameterCount(j);
-                    // coverity[tainted_data] cid#1213376 unhelpfully warns
-                    // about an untrusted loop bound here:
+                    // cid#1213376 unhelpfully warns about an untrusted loop
+                    // bound here:
+                    // coverity[tainted_data] - trusted data source
                     for (sal_uInt16 k = 0; k != m; ++k) {
                         RTParamMode mode = reader.getMethodParameterFlags(j, k);
                         InterfaceTypeEntity::Method::Parameter::Direction dir;
@@ -342,8 +343,9 @@ rtl::Reference< Entity > readEntity(
                     }
                     std::vector< OUString > excs;
                     m = reader.getMethodExceptionCount(j);
-                    // coverity[tainted_data] cid#1213376 unhelpfully warns
-                    // about an untrusted loop bound here:
+                    // cid#1213376 unhelpfully warns about an untrusted loop
+                    // bound here:
+                    // coverity[tainted_data] - trusted data source
                     for (sal_uInt16 k = 0; k != m; ++k) {
                         excs.push_back(
                             reader.getMethodExceptionTypeName(j, k).replace(
@@ -607,8 +609,9 @@ rtl::Reference< Entity > readEntity(
                             SingleInterfaceBasedServiceEntity::Constructor::
                             Parameter > params;
                         sal_uInt16 m = reader.getMethodParameterCount(j);
-                        // coverity[tainted_data] cid#1213376 unhelpfully warns
-                        // about an untrusted loop bound here:
+                        // cid#1213376 unhelpfully warns about an untrusted
+                        // loop bound here:
+                        // coverity[tainted_data] - trusted data source
                         for (sal_uInt16 k = 0; k != m; ++k) {
                             RTParamMode mode
                                 = reader.getMethodParameterFlags(j, k);
@@ -647,8 +650,9 @@ rtl::Reference< Entity > readEntity(
                         }
                         std::vector< OUString > excs;
                         m = reader.getMethodExceptionCount(j);
-                        // coverity[tainted_data] cid#1213376 unhelpfully warns
-                        // about an untrusted loop bound here:
+                        // cid#1213376 unhelpfully warns about an untrusted
+                        // loop bound here:
+                        // coverity[tainted_data] - trusted data source
                         for (sal_uInt16 k = 0; k != m; ++k) {
                             excs.push_back(
                                 reader.getMethodExceptionTypeName(j, k).replace(
diff --git a/unotest/source/cpp/officeconnection.cxx b/unotest/source/cpp/officeconnection.cxx
index a82471e3b921..c85ad7b72e5f 100644
--- a/unotest/source/cpp/officeconnection.cxx
+++ b/unotest/source/cpp/officeconnection.cxx
@@ -78,7 +78,7 @@ void OfficeConnection::setUp() {
         {
             envs = &argEnv.pData;
         }
-        // coverity[callee_ptr_arith]
+        // coverity[callee_ptr_arith] - arith is fine
         CPPUNIT_ASSERT_EQUAL(
             osl_Process_E_None,
             osl_executeProcess(
diff --git a/vcl/source/bitmap/BitmapScaleConvolution.cxx b/vcl/source/bitmap/BitmapScaleConvolution.cxx
index 49aed5d5940b..a8b9bc4b2494 100644
--- a/vcl/source/bitmap/BitmapScaleConvolution.cxx
+++ b/vcl/source/bitmap/BitmapScaleConvolution.cxx
@@ -36,9 +36,9 @@ void ImplCalculateContributions(
     const long aSourceSize,
     const long aDestinationSize,
     long& aNumberOfContributions,
-    double*& pWeights,
-    long*& pPixels,
-    long*& pCount,
+    std::vector<double>& rWeights,
+    std::vector<long>& rPixels,
+    std::vector<long>& rCounts,
     const Kernel& aKernel)
 {
     const double fSamplingRadius(aKernel.GetWidth());
@@ -48,9 +48,9 @@ void ImplCalculateContributions(
 
     aNumberOfContributions = (long(fabs(ceil(fScaledRadius))) * 2) + 1;
     const long nAllocSize(aDestinationSize * aNumberOfContributions);
-    pWeights = new double[nAllocSize];
-    pPixels = new long[nAllocSize];
-    pCount = new long[aDestinationSize];
+    rWeights.resize(nAllocSize);
+    rPixels.resize(nAllocSize);
+    rCounts.resize(aDestinationSize);
 
     for(long i(0); i < aDestinationSize; i++)
     {
@@ -74,13 +74,13 @@ void ImplCalculateContributions(
             const long aPixelIndex(MinMax(j, 0, aSourceSize - 1));
             const long nIndex(aIndex + aCurrentCount);
 
-            pWeights[nIndex] = aWeight;
-            pPixels[nIndex] = aPixelIndex;
+            rWeights[nIndex] = aWeight;
+            rPixels[nIndex] = aPixelIndex;
 
             aCurrentCount++;
         }
 
-        pCount[i] = aCurrentCount;
+        rCounts[i] = aCurrentCount;
     }
 }
 
@@ -100,13 +100,13 @@ bool ImplScaleConvolutionHor(Bitmap& rSource, Bitmap& rTarget, const double& rSc
 
     if(pReadAcc)
     {
-        double* pWeights = nullptr;
-        long* pPixels = nullptr;
-        long* pCount = nullptr;
+        std::vector<double> aWeights;
+        std::vector<long> aPixels;
+        std::vector<long> aCounts;
         long aNumberOfContributions(0);
 
         const long nHeight(rSource.GetSizePixel().Height());
-        ImplCalculateContributions(nWidth, nNewWidth, aNumberOfContributions, pWeights, pPixels, pCount, aKernel);
+        ImplCalculateContributions(nWidth, nNewWidth, aNumberOfContributions, aWeights, aPixels, aCounts, aKernel);
         rTarget = Bitmap(Size(nNewWidth, nHeight), 24);
         Bitmap::ScopedWriteAccess pWriteAcc(rTarget);
         bool bResult(nullptr != pWriteAcc);
@@ -123,21 +123,21 @@ bool ImplScaleConvolutionHor(Bitmap& rSource, Bitmap& rTarget, const double& rSc
                     double aValueGreen(0.0);
                     double aValueBlue(0.0);
 
-                    for(long j(0); j < pCount[x]; j++)
+                    for(long j(0); j < aCounts[x]; j++)
                     {
                         const long aIndex(aBaseIndex + j);
-                        const double aWeight(pWeights[aIndex]);
+                        const double aWeight(aWeights[aIndex]);
                         BitmapColor aColor;
 
                         aSum += aWeight;
 
                         if(pReadAcc->HasPalette())
                         {
-                            aColor = pReadAcc->GetPaletteColor(pReadAcc->GetPixelIndex(y, pPixels[aIndex]));
+                            aColor = pReadAcc->GetPaletteColor(pReadAcc->GetPixelIndex(y, aPixels[aIndex]));
                         }
                         else
                         {
-                            aColor = pReadAcc->GetPixel(y, pPixels[aIndex]);
+                            aColor = pReadAcc->GetPixel(y, aPixels[aIndex]);
                         }
 
                         aValueRed += aWeight * aColor.GetRed();
@@ -157,9 +157,9 @@ bool ImplScaleConvolutionHor(Bitmap& rSource, Bitmap& rTarget, const double& rSc
             pWriteAcc.reset();
         }
 
-        delete[] pWeights;
-        delete[] pCount;
-        delete[] pPixels;
+        aWeights.clear();
+        aCounts.clear();
+        aPixels.clear();
 
         if(bResult)
         {
@@ -186,13 +186,13 @@ bool ImplScaleConvolutionVer(Bitmap& rSource, Bitmap& rTarget, const double& rSc
 
     if(pReadAcc)
     {
-        double* pWeights = nullptr;
-        long* pPixels = nullptr;
-        long* pCount = nullptr;
+        std::vector<double> aWeights;
+        std::vector<long> aPixels;
+        std::vector<long> aCounts;
         long aNumberOfContributions(0);
 
         const long nWidth(rSource.GetSizePixel().Width());
-        ImplCalculateContributions(nHeight, nNewHeight, aNumberOfContributions, pWeights, pPixels, pCount, aKernel);
+        ImplCalculateContributions(nHeight, nNewHeight, aNumberOfContributions, aWeights, aPixels, aCounts, aKernel);
         rTarget = Bitmap(Size(nWidth, nNewHeight), 24);
         Bitmap::ScopedWriteAccess pWriteAcc(rTarget);
         bool bResult(nullptr != pWriteAcc);
@@ -209,21 +209,21 @@ bool ImplScaleConvolutionVer(Bitmap& rSource, Bitmap& rTarget, const double& rSc
                     double aValueGreen(0.0);
                     double aValueBlue(0.0);
 
-                    for(long j(0); j < pCount[y]; j++)
+                    for(long j(0); j < aCounts[y]; j++)
                     {
                         const long aIndex(aBaseIndex + j);
-                        const double aWeight(pWeights[aIndex]);
+                        const double aWeight(aWeights[aIndex]);
                         BitmapColor aColor;
 
                         aSum += aWeight;
 
                         if(pReadAcc->HasPalette())
                         {
-                            aColor = pReadAcc->GetPaletteColor(pReadAcc->GetPixelIndex(pPixels[aIndex], x));
+                            aColor = pReadAcc->GetPaletteColor(pReadAcc->GetPixelIndex(aPixels[aIndex], x));
                         }
                         else
                         {
-                            aColor = pReadAcc->GetPixel(pPixels[aIndex], x);
+                            aColor = pReadAcc->GetPixel(aPixels[aIndex], x);
                         }
 
                         aValueRed += aWeight * aColor.GetRed();
@@ -248,9 +248,9 @@ bool ImplScaleConvolutionVer(Bitmap& rSource, Bitmap& rTarget, const double& rSc
             }
         }
 
-        delete[] pWeights;
-        delete[] pCount;
-        delete[] pPixels;
+        aWeights.clear();
+        aCounts.clear();
+        aPixels.clear();
 
         if(bResult)
         {
diff --git a/vcl/source/gdi/bitmap3.cxx b/vcl/source/gdi/bitmap3.cxx
index b509f6059737..70225ce146c9 100644
--- a/vcl/source/gdi/bitmap3.cxx
+++ b/vcl/source/gdi/bitmap3.cxx
@@ -2127,7 +2127,9 @@ bool Bitmap::Adjust( short nLuminancePercent, short nContrastPercent,
     return bRet;
 }
 
-bool Bitmap::ImplConvolutionPass(Bitmap& aNewBitmap, BitmapReadAccess const * pReadAcc, int aNumberOfContributions, const double* pWeights, int const * pPixels, const int* pCount)
+bool Bitmap::ImplConvolutionPass(Bitmap& aNewBitmap, BitmapReadAccess const * pReadAcc, int aNumberOfContributions,
+                                 const std::vector<double>& rWeights, const std::vector<int>& rPixels,
+                                 const std::vector<int>& rCounts)
 {
     if (!pReadAcc)
         return false;
@@ -2153,12 +2155,12 @@ bool Bitmap::ImplConvolutionPass(Bitmap& aNewBitmap, BitmapReadAccess const * pR
             aBaseIndex = nSourceX * aNumberOfContributions;
             aSum = aValueRed = aValueGreen = aValueBlue = 0.0;
 
-            for (int j = 0; j < pCount[nSourceX]; ++j)
+            for (int j = 0; j < rCounts[nSourceX]; ++j)
             {
                 aIndex = aBaseIndex + j;
-                aSum += aWeight = pWeights[ aIndex ];
+                aSum += aWeight = rWeights[ aIndex ];
 
-                aColor = pReadAcc->GetColor(nSourceY, pPixels[aIndex]);
+                aColor = pReadAcc->GetColor(nSourceY, rPixels[aIndex]);
 
                 aValueRed += aWeight * aColor.GetRed();
                 aValueGreen += aWeight * aColor.GetGreen();
diff --git a/vcl/source/gdi/bitmap4.cxx b/vcl/source/gdi/bitmap4.cxx
index d5e995770993..28bd9fab7f3f 100644
--- a/vcl/source/gdi/bitmap4.cxx
+++ b/vcl/source/gdi/bitmap4.cxx
@@ -1042,10 +1042,10 @@ bool Bitmap::ImplPopArt()
     return bRet;
 }
 
-double* MakeBlurKernel(const double radius, int& rows) {
+std::vector<double> MakeBlurKernel(const double radius, int& rows) {
     int intRadius = (int) radius + 1.0;
     rows = intRadius * 2 + 1;
-    double* matrix = new double[rows];
+    std::vector<double> matrix(rows);
 
     double sigma = radius / 3;
     double radius2 = radius * radius;
@@ -1064,11 +1064,12 @@ double* MakeBlurKernel(const double radius, int& rows) {
 }
 
 void Bitmap::ImplBlurContributions( const int aSize, const int aNumberOfContributions,
-                                    const double* pBlurVector, double*& pWeights, int*& pPixels, int*& pCount )
+                                    const std::vector<double>& rBlurVector,
+                                    std::vector<double>& rWeights, std::vector<int>& rPixels, std::vector<int>& rCounts)
 {
-    pWeights = new double[ aSize*aNumberOfContributions ];
-    pPixels = new int[ aSize*aNumberOfContributions ];
-    pCount = new int[ aSize ];
+    rWeights.resize(aSize*aNumberOfContributions);
+    rPixels.resize(aSize*aNumberOfContributions);
+    rCounts.resize(aSize);
 
     int aLeft, aRight, aCurrentCount, aPixelIndex;
     double aWeight;
@@ -1080,7 +1081,7 @@ void Bitmap::ImplBlurContributions( const int aSize, const int aNumberOfContribu
         aCurrentCount = 0;
         for ( int j = aLeft; j <= aRight; j++ )
         {
-            aWeight = pBlurVector[aCurrentCount];
+            aWeight = rBlurVector[aCurrentCount];
 
             // Mirror edges
             if (j < 0)
@@ -1102,12 +1103,12 @@ void Bitmap::ImplBlurContributions( const int aSize, const int aNumberOfContribu
                 aWeight = 0.0;
             }
 
-            pWeights[ i*aNumberOfContributions + aCurrentCount ] = aWeight;
-            pPixels[ i*aNumberOfContributions + aCurrentCount ] = aPixelIndex;
+            rWeights[ i*aNumberOfContributions + aCurrentCount ] = aWeight;
+            rPixels[ i*aNumberOfContributions + aCurrentCount ] = aPixelIndex;
 
             aCurrentCount++;
         }
-        pCount[ i ] = aCurrentCount;
+        rCounts[ i ] = aCurrentCount;
     }
 }
 
@@ -1126,31 +1127,31 @@ bool Bitmap::ImplSeparableBlurFilter(const double radius)
 
     // Prepare Blur Vector
     int aNumberOfContributions;
-    double* pBlurVector = MakeBlurKernel(radius, aNumberOfContributions);
+    std::vector<double> aBlurVector(MakeBlurKernel(radius, aNumberOfContributions));
 
-    double* pWeights;
-    int* pPixels;
-    int* pCount;
+    std::vector<double> aWeights;
+    std::vector<int> aPixels;
+    std::vector<int> aCounts;
 
     // Do horizontal filtering
-    ImplBlurContributions( nWidth, aNumberOfContributions, pBlurVector, pWeights, pPixels, pCount);
+    ImplBlurContributions( nWidth, aNumberOfContributions, aBlurVector, aWeights, aPixels, aCounts);
 
     ScopedReadAccess pReadAcc(*this);
 
     // switch coordinates as convolution pass transposes result
     Bitmap aNewBitmap( Size( nHeight, nWidth ), 24 );
 
-    bool bResult = ImplConvolutionPass( aNewBitmap, pReadAcc.get(), aNumberOfContributions, pWeights, pPixels, pCount );
+    bool bResult = ImplConvolutionPass( aNewBitmap, pReadAcc.get(), aNumberOfContributions, aWeights, aPixels, aCounts );
 
     // Cleanup
     pReadAcc.reset();
-    delete[] pWeights;
-    delete[] pPixels;
-    delete[] pCount;
+    aWeights.clear();
+    aPixels.clear();
+    aCounts.clear();
 
     if ( !bResult )
     {
-        delete[] pBlurVector;
+        aBlurVector.clear();
         return bResult;
     }
 
@@ -1158,18 +1159,18 @@ bool Bitmap::ImplSeparableBlurFilter(const double radius)
     ImplAssignWithSize( aNewBitmap );
 
     // Do vertical filtering
-    ImplBlurContributions(nHeight, aNumberOfContributions, pBlurVector, pWeights, pPixels, pCount );
+    ImplBlurContributions(nHeight, aNumberOfContributions, aBlurVector, aWeights, aPixels, aCounts );
 
     pReadAcc = ScopedReadAccess(*this);
     aNewBitmap = Bitmap( Size( nWidth, nHeight ), 24 );
-    bResult = ImplConvolutionPass( aNewBitmap, pReadAcc.get(), aNumberOfContributions, pWeights, pPixels, pCount );
+    bResult = ImplConvolutionPass( aNewBitmap, pReadAcc.get(), aNumberOfContributions, aWeights, aPixels, aCounts );
 
     // Cleanup
     pReadAcc.reset();
-    delete[] pWeights;
-    delete[] pCount;
-    delete[] pPixels;
-    delete[] pBlurVector;
+    aWeights.clear();
+    aCounts.clear();
+    aPixels.clear();
+    aBlurVector.clear();
 
     if ( !bResult )
         return bResult;
diff --git a/vcl/source/gdi/pdfwriter_impl.cxx b/vcl/source/gdi/pdfwriter_impl.cxx
index 58711a9d862b..f6eea9242327 100644
--- a/vcl/source/gdi/pdfwriter_impl.cxx
+++ b/vcl/source/gdi/pdfwriter_impl.cxx
@@ -6337,6 +6337,7 @@ void PDFWriterImpl::drawRelief( SalLayout& rLayout, const OUString& rText, bool
         aTextLineColor = Color( COL_WHITE );
     if( aOverlineColor == COL_BLACK )
         aOverlineColor = Color( COL_WHITE );
+    // coverity[copy_paste_error] - aReliefColor depending on aTextColor is correct
     if( aTextColor == COL_WHITE )
         aReliefColor = Color( COL_BLACK );
 
diff --git a/vcl/unx/generic/plugadapt/salplug.cxx b/vcl/unx/generic/plugadapt/salplug.cxx
index a1195dbde18a..b89e7ea4832c 100644
--- a/vcl/unx/generic/plugadapt/salplug.cxx
+++ b/vcl/unx/generic/plugadapt/salplug.cxx
@@ -127,6 +127,7 @@ static SalInstance* tryInstance( const OUString& rModuleBase, bool bForce = fals
         SAL_INFO("vcl.plugadapt", "could not load shared object " << aModule);
     }
 
+    // coverity[leaked_storage] - this is on purpose
     return pInst;
 }
 
diff --git a/wizards/com/sun/star/wizards/agenda/TopicsControl.py b/wizards/com/sun/star/wizards/agenda/TopicsControl.py
index cc42aa95552a..6ba529c1428f 100644
--- a/wizards/com/sun/star/wizards/agenda/TopicsControl.py
+++ b/wizards/com/sun/star/wizards/agenda/TopicsControl.py
@@ -458,8 +458,9 @@ class TopicsControl(ControlScroller):
 
     def rowDown(self, guiRow=None, control=None):
         try:
-            if guiRow is None and control is None:
+            if guiRow is None:
                 guiRow = self.lastFocusRow - self.nscrollvalue
+            if control is None:
                 control = self.lastFocusControl
             # only perform if this is not the last row.
             actuallRow = guiRow + self.nscrollvalue
@@ -490,8 +491,9 @@ class TopicsControl(ControlScroller):
 
     def rowUp(self, guiRow=None, control=None):
         try:
-            if guiRow is None and control is None:
+            if guiRow is None:
                 guiRow = self.lastFocusRow - self.nscrollvalue
+            if control is None:
                 control = self.lastFocusControl
             # only perform if this is not the first row
             actuallRow = guiRow + self.nscrollvalue
diff --git a/wizards/com/sun/star/wizards/document/OfficeDocument.py b/wizards/com/sun/star/wizards/document/OfficeDocument.py
index 3886f1eb1c70..acef6139f737 100644
--- a/wizards/com/sun/star/wizards/document/OfficeDocument.py
+++ b/wizards/com/sun/star/wizards/document/OfficeDocument.py
@@ -234,7 +234,6 @@ class OfficeDocument(object):
                 bState = False
 
         else:
-            xComponent.dispose()
             bState = True
 
         return bState
-- 
2.17.1

