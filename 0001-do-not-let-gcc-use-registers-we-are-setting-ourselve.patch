From 032084d8582ef8eb04724d2488f3e381ac8054d2 Mon Sep 17 00:00:00 2001
From: David Tardon <dtardon@redhat.com>
Date: Mon, 23 Apr 2012 13:19:39 +0200
Subject: [PATCH] do not let gcc use registers we are setting ourselves

gcc uses a register for the function call--and it tried r9 here...
---
 .../source/cpp_uno/gcc3_linux_powerpc/uno2cpp.cxx  |   16 +++++++++++++---
 1 files changed, 13 insertions(+), 3 deletions(-)

diff --git a/bridges/source/cpp_uno/gcc3_linux_powerpc/uno2cpp.cxx b/bridges/source/cpp_uno/gcc3_linux_powerpc/uno2cpp.cxx
index 34e8c63..f409bf7 100644
--- a/bridges/source/cpp_uno/gcc3_linux_powerpc/uno2cpp.cxx
+++ b/bridges/source/cpp_uno/gcc3_linux_powerpc/uno2cpp.cxx
@@ -67,7 +67,6 @@ static void callVirtualMethod(
   // of floating point registers f1 to f8
 
      unsigned long * mfunc;        // actual function to be invoked
-     void (*ptr)();
      int gpr[8];                   // storage for gpregisters, map to r3-r10
      int off;                      // offset used to find function
 #ifndef __NO_FPRS__
@@ -243,7 +242,8 @@ static void callVirtualMethod(
      mfunc = *((unsigned long **)pAdjustedThisPtr);    // get the address of the vtable
      mfunc = (unsigned long *)((char *)mfunc + off); // get the address from the vtable entry at offset
      mfunc = *((unsigned long **)mfunc);                 // the function is stored at the address
-     ptr = (void (*)())mfunc;
+     typedef void (*FunctionCall)(sal_uInt32, sal_uInt32, sal_uInt32, sal_uInt32, sal_uInt32, sal_uInt32, sal_uInt32, sal_uInt32);
+     FunctionCall ptr = (FunctionCall)mfunc;
 
     /* Set up the machine registers and invoke the function */
 
@@ -272,7 +272,17 @@ static void callVirtualMethod(
         : "0", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"
     );
 
-    (*ptr)();
+    // tell gcc that r3 to r10 are not available to it for doing the TOC and exception munge on the func call
+    register sal_uInt32 r3 __asm__("r3");
+    register sal_uInt32 r4 __asm__("r4");
+    register sal_uInt32 r5 __asm__("r5");
+    register sal_uInt32 r6 __asm__("r6");
+    register sal_uInt32 r7 __asm__("r7");
+    register sal_uInt32 r8 __asm__("r8");
+    register sal_uInt32 r9 __asm__("r9");
+    register sal_uInt32 r10 __asm__("r10");
+
+    (*ptr)(r3, r4, r5, r6, r7, r8, r9, r10);
 
     __asm__ __volatile__ (
        "mr     %0,     3\n\t"
-- 
1.7.7.6

