From dfb6ed9c47659a9f840aea81d7b3e344121695db Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Caol=C3=A1n=20McNamara?= <caolanm@redhat.com>
Date: Tue, 13 Jun 2017 18:09:08 +0100
Subject: [PATCH] make opengl transitions under X flicker free on enter/leave
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Change-Id: I109637dc6b3d23c0beca21f3cf0c7ba918ecb4f8
Reviewed-on: https://gerrit.libreoffice.org/38749
Tested-by: Jenkins <ci@libreoffice.org>
Reviewed-by: Caolán McNamara <caolanm@redhat.com>
Tested-by: Caolán McNamara <caolanm@redhat.com>
(cherry picked from commit 277395b6266c57a7709c3c47986f135f6789c8e7)
---
 include/vcl/syschild.hxx                           |  6 ++++
 .../source/engine/opengl/TransitionerImpl.cxx      | 20 +++++++++++
 vcl/inc/salobj.hxx                                 |  4 ++-
 vcl/inc/unx/salobj.h                               |  2 ++
 vcl/source/window/syschild.cxx                     |  6 ++++
 vcl/unx/generic/window/salobj.cxx                  | 39 ++++++++++++++++++++++
 vcl/unx/gtk/gtksalframe.cxx                        |  4 ++-
 7 files changed, 79 insertions(+), 2 deletions(-)

diff --git a/include/vcl/syschild.hxx b/include/vcl/syschild.hxx
index 3f5ed9b..9f5be67 100644
--- a/include/vcl/syschild.hxx
+++ b/include/vcl/syschild.hxx
@@ -49,6 +49,12 @@ public:
     //  however, this might not always be required
     void                    EnableEraseBackground( bool bEnable );
     void                    SetForwardKey( bool bEnable );
+    //To avoid annoying flashing under X entering and leaving slides with opengl effects set the leaving
+    //bitmap as the background pixmap of the opengl child window and the entering bitmap as the background
+    //pixmap of the non-opengl parent window. If any expose events occur around the start and end of
+    //the transition then those windows are default filled by X with the desired start/end image so there's
+    //no visible flash
+    void                    SetLeaveEnterBackgrounds(const css::uno::Sequence<css::uno::Any>& rLeaveArgs, const css::uno::Sequence<css::uno::Any>& rEnterArgs);
     // return the platform specific handle/id of this window;
     sal_IntPtr              GetParentWindowHandle();
 };
diff --git a/slideshow/source/engine/opengl/TransitionerImpl.cxx b/slideshow/source/engine/opengl/TransitionerImpl.cxx
index ef1d385..61a28e9 100644
--- a/slideshow/source/engine/opengl/TransitionerImpl.cxx
+++ b/slideshow/source/engine/opengl/TransitionerImpl.cxx
@@ -367,6 +367,26 @@ void OGLTransitionerImpl::setSlides( const uno::Reference< rendering::XBitmap >&
     SAL_INFO("slideshow.opengl", "leaving bitmap area: " << maSlideSize.Width << "x" << maSlideSize.Height);
     maSlideSize = mxEnteringBitmap->getSize();
     SAL_INFO("slideshow.opengl", "entering bitmap area: " << maSlideSize.Width << "x" << maSlideSize.Height);
+
+    //to avoid annoying flashing under X entering and leaving slides with opengl effects set the leaving
+    //bitmap as the background pixmap of the opengl child window and the entering bitmap as the background
+    //pixmap of the non-opengl parent window. If any expose events occur around the start and end of
+    //the transition then those windows are default filled by X with the desired start/end image so there's
+    //no visible flash
+    if (SystemChildWindow* pChildWindow = mpContext->getChildWindow())
+    {
+        css::uno::Reference<css::beans::XFastPropertySet> xEnteringFastPropertySet(mxEnteringBitmap, css::uno::UNO_QUERY);
+        css::uno::Reference<css::beans::XFastPropertySet> xLeavingFastPropertySet(mxLeavingBitmap, css::uno::UNO_QUERY);
+        css::uno::Sequence<css::uno::Any> aEnteringBitmap;
+        css::uno::Sequence<css::uno::Any> aLeavingBitmap;
+        if (xEnteringFastPropertySet.get() && xLeavingFastPropertySet.get())
+        {
+            xEnteringFastPropertySet->getFastPropertyValue(1) >>= aEnteringBitmap;
+            xLeavingFastPropertySet->getFastPropertyValue(1) >>= aLeavingBitmap;
+        }
+        if (aEnteringBitmap.getLength() == 3 && aLeavingBitmap.getLength() == 3)
+            pChildWindow->SetLeaveEnterBackgrounds(aLeavingBitmap, aEnteringBitmap);
+    }
 }
 
 
diff --git a/vcl/inc/salobj.hxx b/vcl/inc/salobj.hxx
index b1005fb..08d8a39 100644
--- a/vcl/inc/salobj.hxx
+++ b/vcl/inc/salobj.hxx
@@ -21,7 +21,7 @@
 #define INCLUDED_VCL_INC_SALOBJ_HXX
 
 #include <vcl/dllapi.h>
-
+#include <com/sun/star/uno/Sequence.hxx>
 #include "salwtype.hxx"
 
 struct SystemEnvData;
@@ -48,6 +48,8 @@ public:
 
     virtual void                    SetForwardKey( bool /* bEnable */ ) {}
 
+    virtual void                    SetLeaveEnterBackgrounds(const css::uno::Sequence<css::uno::Any>& /*rLeaveArgs*/, const css::uno::Sequence<css::uno::Any>& /*rEnterArgs*/) {}
+
     virtual const SystemEnvData*    GetSystemData() const = 0;
 
     void                            SetCallback( void* pInst, SALOBJECTPROC pProc )
diff --git a/vcl/inc/unx/salobj.h b/vcl/inc/unx/salobj.h
index ffc738a..b3170cb 100644
--- a/vcl/inc/unx/salobj.h
+++ b/vcl/inc/unx/salobj.h
@@ -76,6 +76,8 @@ public:
     virtual void                    Show( bool bVisible ) override;
     virtual void                    GrabFocus() override;
 
+    virtual void                    SetLeaveEnterBackgrounds(const css::uno::Sequence<css::uno::Any>& rLeaveArgs, const css::uno::Sequence<css::uno::Any>& rEnterArgs) override;
+
     virtual const SystemEnvData*    GetSystemData() const override;
 };
 
diff --git a/vcl/source/window/syschild.cxx b/vcl/source/window/syschild.cxx
index d659503..bdeebf1 100644
--- a/vcl/source/window/syschild.cxx
+++ b/vcl/source/window/syschild.cxx
@@ -162,6 +162,12 @@ void SystemChildWindow::EnableEraseBackground( bool bEnable )
         mpWindowImpl->mpSysObj->EnableEraseBackground( bEnable );
 }
 
+void SystemChildWindow::SetLeaveEnterBackgrounds(const css::uno::Sequence<css::uno::Any>& rLeaveArgs, const css::uno::Sequence<css::uno::Any>& rEnterArgs)
+{
+    if (mpWindowImpl->mpSysObj)
+        mpWindowImpl->mpSysObj->SetLeaveEnterBackgrounds(rLeaveArgs, rEnterArgs);
+}
+
 void SystemChildWindow::SetForwardKey( bool bEnable )
 {
     if ( mpWindowImpl->mpSysObj )
diff --git a/vcl/unx/generic/window/salobj.cxx b/vcl/unx/generic/window/salobj.cxx
index 80c0726..2f238b7 100644
--- a/vcl/unx/generic/window/salobj.cxx
+++ b/vcl/unx/generic/window/salobj.cxx
@@ -249,6 +249,9 @@ X11SalObject::~X11SalObject()
     rObjects.remove( this );
 
     GetGenericData()->ErrorTrapPush();
+    const SystemEnvData* pEnv   = mpParent->GetSystemData();
+    ::Window aObjectParent      = (::Window)pEnv->aWindow;
+    XSetWindowBackgroundPixmap(static_cast<Display*>(maSystemChildData.pDisplay), aObjectParent, None);
     if ( maSecondary )
         XDestroyWindow( static_cast<Display*>(maSystemChildData.pDisplay), maSecondary );
     if ( maPrimary )
@@ -474,4 +477,40 @@ bool X11SalObject::Dispatch( XEvent* pEvent )
     return false;
 }
 
+void X11SalObject::SetLeaveEnterBackgrounds(const css::uno::Sequence<css::uno::Any>& rLeaveArgs, const css::uno::Sequence<css::uno::Any>& rEnterArgs)
+{
+    SalDisplay* pSalDisp        = vcl_sal::getSalDisplay(GetGenericData());
+    const SystemEnvData* pEnv   = mpParent->GetSystemData();
+    Display* pDisp              = pSalDisp->GetDisplay();
+    ::Window aObjectParent      = (::Window)pEnv->aWindow;
+
+    bool bFreePixmap = false;
+    Pixmap aPixmap = None;
+    if (rEnterArgs.getLength() == 3)
+    {
+        rEnterArgs[0] >>= bFreePixmap;
+        long pixmapHandle = None;
+        rEnterArgs[1] >>= pixmapHandle;
+        aPixmap = pixmapHandle;
+    }
+
+    XSetWindowBackgroundPixmap(pDisp, aObjectParent, aPixmap);
+    if (bFreePixmap)
+        XFreePixmap(pDisp, aPixmap);
+
+    bFreePixmap = false;
+    aPixmap = None;
+    if (rLeaveArgs.getLength() == 3)
+    {
+        rLeaveArgs[0] >>= bFreePixmap;
+        long pixmapHandle = None;
+        rLeaveArgs[1] >>= pixmapHandle;
+        aPixmap = pixmapHandle;
+    }
+
+    XSetWindowBackgroundPixmap(pDisp, maSecondary, aPixmap);
+    if (bFreePixmap)
+        XFreePixmap(pDisp, aPixmap);
+}
+
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/vcl/unx/gtk/gtksalframe.cxx b/vcl/unx/gtk/gtksalframe.cxx
index 1e28c04..b10994d 100644
--- a/vcl/unx/gtk/gtksalframe.cxx
+++ b/vcl/unx/gtk/gtksalframe.cxx
@@ -2882,7 +2882,9 @@ gboolean GtkSalFrame::signalExpose( GtkWidget*, GdkEventExpose* pEvent, gpointer
 {
     GtkSalFrame* pThis = static_cast<GtkSalFrame*>(frame);
 
-    struct SalPaintEvent aEvent( pEvent->area.x, pEvent->area.y, pEvent->area.width, pEvent->area.height, OpenGLHelper::isVCLOpenGLEnabled() );
+    const bool bImmediate = OpenGLHelper::isVCLOpenGLEnabled() || pThis->m_bFullscreen;
+
+    struct SalPaintEvent aEvent( pEvent->area.x, pEvent->area.y, pEvent->area.width, pEvent->area.height, bImmediate );
 
     pThis->CallCallback( SalEvent::Paint, &aEvent );
 
-- 
2.9.3

