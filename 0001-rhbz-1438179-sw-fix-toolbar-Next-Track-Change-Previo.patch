From 224073a5002df33da673a63db24c19f5a43143c1 Mon Sep 17 00:00:00 2001
From: Michael Stahl <mstahl@redhat.com>
Date: Wed, 5 Apr 2017 16:54:57 +0200
Subject: [PATCH] rhbz#1438179 sw: fix toolbar "Next Track Change" /
 "Previous..."

There's some confusing workarounds in SwView::Execute() that aren't
needed if the SwCursorShell just calls NormalizePam() so it always
makes progress.

(cherry picked from commit 25eb0899227830cca7f28006376962d84f8e9c7a)

Change-Id: I3b014079b19925041234fcd858526148890f560c
Reviewed-on: https://gerrit.libreoffice.org/36167
Tested-by: Jenkins <ci@libreoffice.org>
Reviewed-by: Christian Lohmaier <lohmaier+LibreOffice@googlemail.com>
---
 sw/source/core/crsr/crstrvl.cxx   |  4 ++++
 sw/source/uibase/uiview/view2.cxx | 25 -------------------------
 2 files changed, 4 insertions(+), 25 deletions(-)

diff --git a/sw/source/core/crsr/crstrvl.cxx b/sw/source/core/crsr/crstrvl.cxx
index 1fb7c833..e83e689 100644
--- a/sw/source/core/crsr/crstrvl.cxx
+++ b/sw/source/core/crsr/crstrvl.cxx
@@ -1982,6 +1982,8 @@ const SwRangeRedline* SwCursorShell::SelNextRedline()
         SwCallLink aLk( *this ); // watch Cursor-Moves
         SwCursorSaveState aSaveState( *m_pCurrentCursor );
 
+        // ensure point is at the end so alternating SelNext/SelPrev works
+        NormalizePam(false);
         pFnd = GetDoc()->getIDocumentRedlineAccess().SelNextRedline( *m_pCurrentCursor );
         if( pFnd && !m_pCurrentCursor->IsInProtectTable() && !m_pCurrentCursor->IsSelOvr() )
             UpdateCursor( SwCursorShell::SCROLLWIN|SwCursorShell::CHKRANGE|SwCursorShell::READONLY);
@@ -2000,6 +2002,8 @@ const SwRangeRedline* SwCursorShell::SelPrevRedline()
         SwCallLink aLk( *this ); // watch Cursor-Moves
         SwCursorSaveState aSaveState( *m_pCurrentCursor );
 
+        // ensure point is at the start so alternating SelNext/SelPrev works
+        NormalizePam(true);
         pFnd = GetDoc()->getIDocumentRedlineAccess().SelPrevRedline( *m_pCurrentCursor );
         if( pFnd && !m_pCurrentCursor->IsInProtectTable() && !m_pCurrentCursor->IsSelOvr() )
             UpdateCursor( SwCursorShell::SCROLLWIN|SwCursorShell::CHKRANGE|SwCursorShell::READONLY);
diff --git a/sw/source/uibase/uiview/view2.cxx b/sw/source/uibase/uiview/view2.cxx
index edd8bcc..bdb977e 100644
--- a/sw/source/uibase/uiview/view2.cxx
+++ b/sw/source/uibase/uiview/view2.cxx
@@ -702,18 +702,8 @@ void SwView::Execute(SfxRequest &rReq)
 
         case FN_REDLINE_NEXT_CHANGE:
         {
-            const SwRangeRedline *pCurrent = m_pWrtShell->GetCurrRedline();
             const SwRangeRedline *pNext = m_pWrtShell->SelNextRedline();
 
-            // FN_REDLINE_PREV_CHANGE leaves the selection point at the start of the redline.
-            // In such cases, SelNextRedline (which starts searching from the selection point)
-            // immediately finds the current redline and advances the selection point to its end.
-
-            // This behavior means that PREV_CHANGE followed by NEXT_CHANGE would not change
-            // the current redline, so we detect it and select the next redline again.
-            if (pCurrent && pCurrent == pNext)
-                pNext = m_pWrtShell->SelNextRedline();
-
             if (pNext)
                 m_pWrtShell->SetInSelect();
         }
@@ -721,24 +711,9 @@ void SwView::Execute(SfxRequest &rReq)
 
         case FN_REDLINE_PREV_CHANGE:
         {
-            const SwPaM *pCursor = m_pWrtShell->GetCursor();
-            const SwPosition initialCursorStart = *pCursor->Start();
             const SwRangeRedline *pPrev = m_pWrtShell->SelPrevRedline();
 
             if (pPrev)
-            {
-                // FN_REDLINE_NEXT_CHANGE leaves the selection point at the end of the redline.
-                // In such cases, SelPrevRedline (which starts searching from the selection point)
-                // immediately finds the current redline and advances the selection point to its
-                // start.
-
-                // This behavior means that NEXT_CHANGE followed by PREV_CHANGE would not change
-                // the current redline, so we detect it and move to the previous redline again.
-                if (initialCursorStart == *pPrev->Start())
-                    pPrev = m_pWrtShell->SelPrevRedline();
-            }
-
-            if (pPrev)
                 m_pWrtShell->SetInSelect();
         }
         break;
-- 
2.9.3

