From 00c05a37fa33d20d39a4126ab156de35dc18cafc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Caol=C3=A1n=20McNamara?= <caolanm@redhat.com>
Date: Fri, 12 Apr 2019 15:59:02 +0100
Subject: [PATCH] rhbz#1699347 __glibcxx_requires_subscript enabled in fedora
 release builds

and so triggering a crash and exit on trying to get address of 0th element of a
0 len vector

Change-Id: I205478b6c2878d3758d91812db46fe8ad58e37df
---
 sw/source/filter/ww8/wrtww8.cxx             |  6 +++---
 sw/source/filter/ww8/ww8par3.cxx            |  2 +-
 sw/source/filter/ww8/ww8scan.cxx            |  2 +-
 sw/source/uibase/docvw/edtwin.cxx           |  2 +-
 vcl/source/gdi/pdfwriter_impl.cxx           | 10 ++++-----
 vcl/source/gdi/pdfwriter_impl2.cxx          | 24 ++++++++++-----------
 vcl/source/opengl/OpenGLHelper.cxx          |  6 +++---
 vcl/unx/generic/fontmanager/fontmanager.cxx |  2 +-
 vcl/unx/generic/gdi/gdiimpl.cxx             |  4 ++--
 vcl/unx/generic/print/glyphset.cxx          |  2 +-
 vcl/unx/generic/window/salframe.cxx         |  2 +-
 vcl/unx/gtk/gtksalframe.cxx                 |  4 ++--
 vcl/unx/gtk3/gtk3gtkframe.cxx               |  4 ++--
 13 files changed, 35 insertions(+), 35 deletions(-)

diff --git a/sw/source/filter/ww8/wrtww8.cxx b/sw/source/filter/ww8/wrtww8.cxx
index 655716d9e988..607f21aa3350 100644
--- a/sw/source/filter/ww8/wrtww8.cxx
+++ b/sw/source/filter/ww8/wrtww8.cxx
@@ -1774,7 +1774,7 @@ void SwWW8Writer::WriteString16(SvStream& rStrm, const OUString& rStr,
     //vectors are guaranteed to have contiguous memory, so we can do
     //this while migrating away from WW8Bytes. Meyers Effective STL, item 16
     if (!aBytes.empty())
-        rStrm.WriteBytes(&aBytes[0], aBytes.size());
+        rStrm.WriteBytes(aBytes.data(), aBytes.size());
 }
 
 void SwWW8Writer::WriteString_xstz(SvStream& rStrm, const OUString& rStr, bool bAddZero)
@@ -1784,7 +1784,7 @@ void SwWW8Writer::WriteString_xstz(SvStream& rStrm, const OUString& rStr, bool b
     SwWW8Writer::InsAsString16(aBytes, rStr);
     if (bAddZero)
         SwWW8Writer::InsUInt16(aBytes, 0);
-    rStrm.WriteBytes(&aBytes[0], aBytes.size());
+    rStrm.WriteBytes(aBytes.data(), aBytes.size());
 }
 
 void SwWW8Writer::WriteString8(SvStream& rStrm, const OUString& rStr,
@@ -1797,7 +1797,7 @@ void SwWW8Writer::WriteString8(SvStream& rStrm, const OUString& rStr,
     //vectors are guaranteed to have contiguous memory, so we can do
     ////this while migrating away from WW8Bytes. Meyers Effective STL, item 16
     if (!aBytes.empty())
-        rStrm.WriteBytes(&aBytes[0], aBytes.size());
+        rStrm.WriteBytes(aBytes.data(), aBytes.size());
 }
 
 void WW8Export::WriteStringAsPara( const OUString& rText )
diff --git a/sw/source/filter/ww8/ww8par3.cxx b/sw/source/filter/ww8/ww8par3.cxx
index f4b3a886d5ff..c76ed0eea75c 100644
--- a/sw/source/filter/ww8/ww8par3.cxx
+++ b/sw/source/filter/ww8/ww8par3.cxx
@@ -1871,7 +1871,7 @@ void SwWW8ImplReader::RegisterNumFormatOnTextNode(sal_uInt16 nCurrentLFO,
                 {
                     std::unique_ptr<SfxItemSet> xOldCurrentItemSet(SetCurrentItemSet(xListIndent.release()));
 
-                    sal_uInt8* pSprms1  = &aParaSprms[0];
+                    sal_uInt8* pSprms1  = aParaSprms.data();
                     while (0 < nLen)
                     {
                         sal_uInt16 nL1 = ImportSprm(pSprms1, nLen);
diff --git a/sw/source/filter/ww8/ww8scan.cxx b/sw/source/filter/ww8/ww8scan.cxx
index 16cc14b4132d..4ba675ce7970 100644
--- a/sw/source/filter/ww8/ww8scan.cxx
+++ b/sw/source/filter/ww8/ww8scan.cxx
@@ -2674,7 +2674,7 @@ WW8PLCFx_Fc_FKP::WW8Fkp::WW8Fkp(const WW8Fib& rFib, SvStream* pSt,
                         if (aEntry.mnLen)
                         {
                             aEntry.mpData = new sal_uInt8[aEntry.mnLen];
-                            memcpy(aEntry.mpData, &(aSprms[0]), aEntry.mnLen);
+                            memcpy(aEntry.mpData, aSprms.data(), aEntry.mnLen);
                             aEntry.mbMustDelete = true;
                         }
                     }
diff --git a/sw/source/uibase/docvw/edtwin.cxx b/sw/source/uibase/docvw/edtwin.cxx
index c892f902fed0..59f62324a535 100644
--- a/sw/source/uibase/docvw/edtwin.cxx
+++ b/sw/source/uibase/docvw/edtwin.cxx
@@ -5895,7 +5895,7 @@ void QuickHelpData::Start( SwWrtShell& rSh, sal_uInt16 nWrdLen )
         const ExtTextInputAttr nVal = ExtTextInputAttr::DottedUnderline |
                                 ExtTextInputAttr::Highlight;
         const std::vector<ExtTextInputAttr> aAttrs( nL, nVal );
-        CommandExtTextInputData aCETID( sStr, &aAttrs[0], nL,
+        CommandExtTextInputData aCETID( sStr, aAttrs.data(), nL,
                                         0, false );
 
         //fdo#33092. If the current input language is the default
diff --git a/vcl/source/gdi/pdfwriter_impl.cxx b/vcl/source/gdi/pdfwriter_impl.cxx
index acec33b4ec5c..79662faff35d 100644
--- a/vcl/source/gdi/pdfwriter_impl.cxx
+++ b/vcl/source/gdi/pdfwriter_impl.cxx
@@ -3383,7 +3383,7 @@ bool PDFWriterImpl::emitFonts()
                 sal_Int32 nFontDescriptor = emitFontDescriptor( subset.first, aSubsetInfo, s_subset.m_nFontID, nFontStream );
 
                 if( nToUnicodeStream )
-                    nToUnicodeStream = createToUnicodeCMap( pEncoding, &aCodeUnits[0], pCodeUnitsPerGlyph, pEncToUnicodeIndex, nGlyphs );
+                    nToUnicodeStream = createToUnicodeCMap( pEncoding, aCodeUnits.data(), pCodeUnitsPerGlyph, pEncToUnicodeIndex, nGlyphs );
 
                 sal_Int32 nFontObject = createObject();
                 if ( !updateObject( nFontObject ) ) return false;
@@ -5592,9 +5592,9 @@ sal_Int32 PDFWriterImpl::emitOutputIntent()
     if (!nBytesNeeded)
       return 0;
     std::vector<unsigned char> aBuffer(nBytesNeeded);
-    cmsSaveProfileToMem(hProfile, &aBuffer[0], &nBytesNeeded);
+    cmsSaveProfileToMem(hProfile, aBuffer.data(), &nBytesNeeded);
     cmsCloseProfile(hProfile);
-    bool written = writeBuffer( &aBuffer[0], static_cast<sal_Int32>(aBuffer.size()) );
+    bool written = writeBuffer( aBuffer.data(), static_cast<sal_Int32>(aBuffer.size()) );
     disableStreamEncryption();
     endCompression();
     sal_uInt64 nEndStreamPos = 0;
@@ -5844,9 +5844,9 @@ bool PDFWriterImpl::emitTrailer()
 
             // emit the owner password, must not be encrypted
             aLineS.append( "/O(" );
-            appendLiteralString( reinterpret_cast<char*>(&m_aContext.Encryption.OValue[0]), sal_Int32(m_aContext.Encryption.OValue.size()), aLineS );
+            appendLiteralString( reinterpret_cast<char*>(m_aContext.Encryption.OValue.data()), sal_Int32(m_aContext.Encryption.OValue.size()), aLineS );
             aLineS.append( ")/U(" );
-            appendLiteralString( reinterpret_cast<char*>(&m_aContext.Encryption.UValue[0]), sal_Int32(m_aContext.Encryption.UValue.size()), aLineS );
+            appendLiteralString( reinterpret_cast<char*>(m_aContext.Encryption.UValue.data()), sal_Int32(m_aContext.Encryption.UValue.size()), aLineS );
             aLineS.append( ")/P " );// the permission set
             aLineS.append( m_nAccessPermissions );
             aLineS.append( ">>\nendobj\n\n" );
diff --git a/vcl/source/gdi/pdfwriter_impl2.cxx b/vcl/source/gdi/pdfwriter_impl2.cxx
index 05f7c5620cf6..ef54cee9c5aa 100644
--- a/vcl/source/gdi/pdfwriter_impl2.cxx
+++ b/vcl/source/gdi/pdfwriter_impl2.cxx
@@ -1176,7 +1176,7 @@ void PDFWriterImpl::checkAndEnableStreamEncryption( sal_Int32 nObject )
         // the other location of m_nEncryptionKey is already set to 0, our fixed generation number
         // do the MD5 hash
         ::std::vector<unsigned char> const nMD5Sum(::comphelper::Hash::calculateHash(
-            &m_aContext.Encryption.EncryptionKey[0], i+2, ::comphelper::HashType::MD5));
+            m_aContext.Encryption.EncryptionKey.data(), i+2, ::comphelper::HashType::MD5));
         // the i+2 to take into account the generation number, always zero
         // initialize the RC4 with the key
         // key length: see algorithm 3.1, step 4: (N+5) max 16
@@ -1196,7 +1196,7 @@ void PDFWriterImpl::enableStringEncryption( sal_Int32 nObject )
         // do the MD5 hash
         // the i+2 to take into account the generation number, always zero
         ::std::vector<unsigned char> const nMD5Sum(::comphelper::Hash::calculateHash(
-            &m_aContext.Encryption.EncryptionKey[0], i+2, ::comphelper::HashType::MD5));
+            m_aContext.Encryption.EncryptionKey.data(), i+2, ::comphelper::HashType::MD5));
         // initialize the RC4 with the key
         // key length: see algorithm 3.1, step 4: (N+5) max 16
         rtl_cipher_initARCFOUR( m_aCipher, rtl_Cipher_DirectionEncode, nMD5Sum.data(), m_nRC4KeyLength, nullptr, 0 );
@@ -1334,7 +1334,7 @@ bool PDFWriterImpl::computeEncryptionKey( EncHashTransporter* i_pTransporter, vc
     {
         //step 3
         if( ! io_rProperties.OValue.empty() )
-            pDigest->update(&io_rProperties.OValue[0], io_rProperties.OValue.size());
+            pDigest->update(io_rProperties.OValue.data(), io_rProperties.OValue.size());
         else
             bSuccess = false;
         //Step 4
@@ -1348,7 +1348,7 @@ bool PDFWriterImpl::computeEncryptionKey( EncHashTransporter* i_pTransporter, vc
         pDigest->update(nPerm, sizeof(nPerm));
 
         //step 5, get the document ID, binary form
-        pDigest->update(&io_rProperties.DocumentIdentifier[0], io_rProperties.DocumentIdentifier.size());
+        pDigest->update(io_rProperties.DocumentIdentifier.data(), io_rProperties.DocumentIdentifier.size());
         //get the digest
         nMD5Sum = pDigest->finalize();
 
@@ -1416,7 +1416,7 @@ bool PDFWriterImpl::computeODictionaryValue( const sal_uInt8* i_pPaddedOwnerPass
         {
             // encrypt the user password using the key set above
             rtl_cipher_encodeARCFOUR( aCipher, i_pPaddedUserPassword, ENCRYPTED_PWD_SIZE, // the data to be encrypted
-                                      &io_rOValue[0], sal_Int32(io_rOValue.size()) ); //encrypted data
+                                      io_rOValue.data(), sal_Int32(io_rOValue.size()) ); //encrypted data
             //Step 7, only if 128 bit
             if( i_nKeyLength == SECUR_128BIT_KEY )
             {
@@ -1435,8 +1435,8 @@ bool PDFWriterImpl::computeODictionaryValue( const sal_uInt8* i_pPaddedOwnerPass
                         bSuccess = false;
                         break;
                     }
-                    rtl_cipher_encodeARCFOUR( aCipher, &io_rOValue[0], sal_Int32(io_rOValue.size()), // the data to be encrypted
-                                              &io_rOValue[0], sal_Int32(io_rOValue.size()) ); // encrypted data, can be the same as the input, encrypt "in place"
+                    rtl_cipher_encodeARCFOUR( aCipher, io_rOValue.data(), sal_Int32(io_rOValue.size()), // the data to be encrypted
+                                              io_rOValue.data(), sal_Int32(io_rOValue.size()) ); // encrypted data, can be the same as the input, encrypt "in place"
                     //step 8, store in class data member
                 }
             }
@@ -1485,14 +1485,14 @@ bool PDFWriterImpl::computeUDictionaryValue( EncHashTransporter* i_pTransporter,
                 io_rProperties.UValue[i] = 0;
             //steps 2 and 3
             aDigest.update(s_nPadString, sizeof(s_nPadString));
-            aDigest.update(&io_rProperties.DocumentIdentifier[0], io_rProperties.DocumentIdentifier.size());
+            aDigest.update(io_rProperties.DocumentIdentifier.data(), io_rProperties.DocumentIdentifier.size());
 
             ::std::vector<unsigned char> const nMD5Sum(aDigest.finalize());
             //Step 4
             rtl_cipher_initARCFOUR( aCipher, rtl_Cipher_DirectionEncode,
-                                    &io_rProperties.EncryptionKey[0], SECUR_128BIT_KEY, nullptr, 0 ); //destination data area
+                                    io_rProperties.EncryptionKey.data(), SECUR_128BIT_KEY, nullptr, 0 ); //destination data area
             rtl_cipher_encodeARCFOUR( aCipher, nMD5Sum.data(), nMD5Sum.size(), // the data to be encrypted
-                                      &io_rProperties.UValue[0], SECUR_128BIT_KEY ); //encrypted data, stored in class data member
+                                      io_rProperties.UValue.data(), SECUR_128BIT_KEY ); //encrypted data, stored in class data member
             //step 5
             sal_uInt32 i, y;
             sal_uInt8 nLocalKey[SECUR_128BIT_KEY];
@@ -1505,8 +1505,8 @@ bool PDFWriterImpl::computeUDictionaryValue( EncHashTransporter* i_pTransporter,
                 rtl_cipher_initARCFOUR( aCipher, rtl_Cipher_DirectionEncode,
                                         nLocalKey, SECUR_128BIT_KEY, // key and key length
                                         nullptr, 0 ); //destination data area, on init can be NULL
-                rtl_cipher_encodeARCFOUR( aCipher, &io_rProperties.UValue[0], SECUR_128BIT_KEY, // the data to be encrypted
-                                          &io_rProperties.UValue[0], SECUR_128BIT_KEY ); // encrypted data, can be the same as the input, encrypt "in place"
+                rtl_cipher_encodeARCFOUR( aCipher, io_rProperties.UValue.data(), SECUR_128BIT_KEY, // the data to be encrypted
+                                          io_rProperties.UValue.data(), SECUR_128BIT_KEY ); // encrypted data, can be the same as the input, encrypt "in place"
             }
         }
         else
diff --git a/vcl/source/opengl/OpenGLHelper.cxx b/vcl/source/opengl/OpenGLHelper.cxx
index 3bad4ea44b87..8d4f9cdd5b22 100644
--- a/vcl/source/opengl/OpenGLHelper.cxx
+++ b/vcl/source/opengl/OpenGLHelper.cxx
@@ -123,13 +123,13 @@ namespace {
         {
             std::vector<char> ErrorMessage(InfoLogLength+1);
             if (bShaderNotProgram)
-                glGetShaderInfoLog (nId, InfoLogLength, nullptr, &ErrorMessage[0]);
+                glGetShaderInfoLog (nId, InfoLogLength, nullptr, ErrorMessage.data());
             else
-                glGetProgramInfoLog(nId, InfoLogLength, nullptr, &ErrorMessage[0]);
+                glGetProgramInfoLog(nId, InfoLogLength, nullptr, ErrorMessage.data());
             CHECK_GL_ERROR();
 
             ErrorMessage.push_back('\0');
-            SAL_WARN("vcl.opengl", rDetail << " shader " << nId << " compile for " << rName << " failed : " << &ErrorMessage[0]);
+            SAL_WARN("vcl.opengl", rDetail << " shader " << nId << " compile for " << rName << " failed : " << ErrorMessage.data());
         }
         else
             SAL_WARN("vcl.opengl", rDetail << " shader: " << rName << " compile " << nId << " failed without error log");
diff --git a/vcl/unx/generic/fontmanager/fontmanager.cxx b/vcl/unx/generic/fontmanager/fontmanager.cxx
index 390158e48cf8..86d643ab2e04 100644
--- a/vcl/unx/generic/fontmanager/fontmanager.cxx
+++ b/vcl/unx/generic/fontmanager/fontmanager.cxx
@@ -1127,7 +1127,7 @@ void PrintFontManager::getGlyphWidths( fontID nFont,
         for (int i = 0; i < nGlyphs; i++)
             aGlyphIds[i] = sal_uInt16(i);
         TTSimpleGlyphMetrics* pMetrics = GetTTSimpleGlyphMetrics(pTTFont,
-                                                                 &aGlyphIds[0],
+                                                                 aGlyphIds.data(),
                                                                  nGlyphs,
                                                                  bVertical);
         if (pMetrics)
diff --git a/vcl/unx/generic/gdi/gdiimpl.cxx b/vcl/unx/generic/gdi/gdiimpl.cxx
index b815992e2d4d..a6d15d192db1 100644
--- a/vcl/unx/generic/gdi/gdiimpl.cxx
+++ b/vcl/unx/generic/gdi/gdiimpl.cxx
@@ -1481,7 +1481,7 @@ bool X11SalGraphicsImpl::drawPolyPolygon( const basegfx::B2DPolyPolygon& rOrigPo
     const int nTrapCount = aB2DTrapVector.size();
     if( !nTrapCount )
         return true;
-    const bool bDrawn = drawFilledTrapezoids( &aB2DTrapVector[0], nTrapCount, fTransparency );
+    const bool bDrawn = drawFilledTrapezoids( aB2DTrapVector.data(), nTrapCount, fTransparency );
     return bDrawn;
 }
 
@@ -1557,7 +1557,7 @@ bool X11SalGraphicsImpl::drawFilledTrapezoids( const basegfx::B2DTrapezoid* pB2D
     // render the trapezoids
     const XRenderPictFormat* pMaskFormat = rRenderPeer.GetStandardFormatA8();
     rRenderPeer.CompositeTrapezoids( PictOpOver,
-        rEntry.m_aPicture, aDstPic, pMaskFormat, 0, 0, &aTrapVector[0], aTrapVector.size() );
+        rEntry.m_aPicture, aDstPic, pMaskFormat, 0, 0, aTrapVector.data(), aTrapVector.size() );
 
     return true;
 }
diff --git a/vcl/unx/generic/print/glyphset.cxx b/vcl/unx/generic/print/glyphset.cxx
index e019049f5d4e..37e7924f117d 100644
--- a/vcl/unx/generic/print/glyphset.cxx
+++ b/vcl/unx/generic/print/glyphset.cxx
@@ -235,7 +235,7 @@ static void CreatePSUploadableFont( TrueTypeFont* pSrcFont, FILE* pTmpFile,
     aInfo.LoadFont( pSrcFont );
 
     aInfo.CreateFontSubset( nTargetMask, pTmpFile, pGlyphSetName,
-        &aRequestedGlyphs[0], &aEncoding[0], nGlyphCount );
+        &aRequestedGlyphs[0], aEncoding.data(), nGlyphCount );
 }
 
 void
diff --git a/vcl/unx/generic/window/salframe.cxx b/vcl/unx/generic/window/salframe.cxx
index 88a9c455cbb1..845fcd573105 100644
--- a/vcl/unx/generic/window/salframe.cxx
+++ b/vcl/unx/generic/window/salframe.cxx
@@ -2928,7 +2928,7 @@ bool X11SalFrame::appendUnicodeSequence( sal_Unicode c )
 
             SalExtTextInputEvent aEv;
             aEv.maText          = rSeq;
-            aEv.mpTextAttr      = &attribs[0];
+            aEv.mpTextAttr      = attribs.data();
             aEv.mnCursorPos     = 0;
             aEv.mnCursorFlags   = 0;
 
diff --git a/vcl/unx/gtk/gtksalframe.cxx b/vcl/unx/gtk/gtksalframe.cxx
index 56cb33520443..9d5fd0aced77 100644
--- a/vcl/unx/gtk/gtksalframe.cxx
+++ b/vcl/unx/gtk/gtksalframe.cxx
@@ -3293,7 +3293,7 @@ void GtkSalFrame::IMHandler::endExtTextInput( EndExtTextInputFlags /*nFlags*/ )
         if( ! aDel.isDeleted() )
         {
             // mark previous preedit state again (will e.g. be sent at focus gain)
-            m_aInputEvent.mpTextAttr = &m_aInputFlags[0];
+            m_aInputEvent.mpTextAttr = m_aInputFlags.data();
             if( m_bFocused )
             {
                 // begin preedit again
@@ -3614,7 +3614,7 @@ void GtkSalFrame::IMHandler::signalIMPreeditChanged( GtkIMContext*, gpointer im_
     } while (pango_attr_iterator_next (iter));
     pango_attr_iterator_destroy(iter);
 
-    pThis->m_aInputEvent.mpTextAttr = &pThis->m_aInputFlags[0];
+    pThis->m_aInputEvent.mpTextAttr = pThis->m_aInputFlags.data();
 
     g_free( pText );
     pango_attr_list_unref( pAttrs );
diff --git a/vcl/unx/gtk3/gtk3gtkframe.cxx b/vcl/unx/gtk3/gtk3gtkframe.cxx
index 95e616473608..538ceafcd3a8 100644
--- a/vcl/unx/gtk3/gtk3gtkframe.cxx
+++ b/vcl/unx/gtk3/gtk3gtkframe.cxx
@@ -3849,7 +3849,7 @@ void GtkSalFrame::IMHandler::endExtTextInput( EndExtTextInputFlags /*nFlags*/ )
         if( ! aDel.isDeleted() )
         {
             // mark previous preedit state again (will e.g. be sent at focus gain)
-            m_aInputEvent.mpTextAttr = &m_aInputFlags[0];
+            m_aInputEvent.mpTextAttr = m_aInputFlags.data();
             if( m_bFocused )
             {
                 // begin preedit again
@@ -4161,7 +4161,7 @@ void GtkSalFrame::IMHandler::signalIMPreeditChanged( GtkIMContext*, gpointer im_
     } while (pango_attr_iterator_next (iter));
     pango_attr_iterator_destroy(iter);
 
-    pThis->m_aInputEvent.mpTextAttr = &pThis->m_aInputFlags[0];
+    pThis->m_aInputEvent.mpTextAttr = pThis->m_aInputFlags.data();
 
     g_free( pText );
     pango_attr_list_unref( pAttrs );
-- 
2.21.0

