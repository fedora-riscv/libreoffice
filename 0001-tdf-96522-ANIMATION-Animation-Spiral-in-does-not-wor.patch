From 88aa1e61ad0749aec1298f775c491ef80079e9f3 Mon Sep 17 00:00:00 2001
From: Noel Grandin <noel@peralex.com>
Date: Thu, 24 Dec 2015 09:26:41 +0200
Subject: [PATCH] tdf#96522 - [ANIMATION] Animation Spiral in does not work

blind fix for this since I cannot seem to make it work on my dev box no
matter how far back I go.
This seems to be a regression from commit
c7e8f21a538c409abe70b90d7bba38386e90a876 "loplugin:unusedmethods"

Change-Id: I99f0f0ca662a5fe246057b1bb8da3bd3d3c7bac6
(cherry picked from commit 4dfba3b59021f55957fc486531f8fdc67cc307b0)
---
 .../source/engine/activities/activitiesfactory.cxx | 95 ++++++++++++++++++++++
 1 file changed, 95 insertions(+)

diff --git a/slideshow/source/engine/activities/activitiesfactory.cxx b/slideshow/source/engine/activities/activitiesfactory.cxx
index f982a60..fe3f018 100644
--- a/slideshow/source/engine/activities/activitiesfactory.cxx
+++ b/slideshow/source/engine/activities/activitiesfactory.cxx
@@ -141,6 +141,7 @@ public:
         value, or start fresh each time.
     */
     FromToByActivity(
+        const OptionalValueType&                      rFrom,
         const OptionalValueType&                      rTo,
         const OptionalValueType&                      rBy,
         const ActivityParameters&                     rParms,
@@ -148,6 +149,9 @@ public:
         const Interpolator< ValueType >&              rInterpolator,
         bool                                          bCumulative )
         : BaseType( rParms ),
+          maFrom( rFrom ),
+          maTo( rTo ),
+          maBy( rBy ),
           mpFormula( rParms.mpFormula ),
           maStartValue(),
           maEndValue(),
@@ -166,6 +170,74 @@ public:
             "From and one of To or By, or To or By alone must be valid" );
     }
 
+    virtual void startAnimation()
+    {
+        if (this->isDisposed() || !mpAnim)
+            return;
+        BaseType::startAnimation();
+
+        // start animation
+        mpAnim->start( BaseType::getShape(),
+                       BaseType::getShapeAttributeLayer() );
+
+        // setup start and end value. Determine animation
+        // start value only when animation actually
+        // started up (this order is part of the Animation
+        // interface contract)
+        const ValueType aAnimationStartValue( mpAnim->getUnderlyingValue() );
+
+        // first of all, determine general type of
+        // animation, by inspecting which of the FromToBy values
+        // are actually valid.
+        // See http://www.w3.org/TR/smil20/animation.html#AnimationNS-FromToBy
+        // for a definition
+        if( maFrom )
+        {
+            // From-to or From-by animation. According to
+            // SMIL spec, the To value takes precedence
+            // over the By value, if both are specified
+            if( maTo )
+            {
+                // From-To animation
+                maStartValue = *maFrom;
+                maEndValue = *maTo;
+            }
+            else if( maBy )
+            {
+                // From-By animation
+                maStartValue = *maFrom;
+                maEndValue = maStartValue + *maBy;
+            }
+        }
+        else
+        {
+            maStartValue = aAnimationStartValue;
+            maStartInterpolationValue = maStartValue;
+
+            // By or To animation. According to SMIL spec,
+            // the To value takes precedence over the By
+            // value, if both are specified
+            if( maTo )
+            {
+                // To animation
+
+                // According to the SMIL spec
+                // (http://www.w3.org/TR/smil20/animation.html#animationNS-ToAnimation),
+                // the to animation interpolates between
+                // the _running_ underlying value and the to value (as the end value)
+                mbDynamicStartValue = true;
+                maPreviousValue = maStartValue;
+                maEndValue = *maTo;
+            }
+            else if( maBy )
+            {
+                // By animation
+                maStartValue = aAnimationStartValue;
+                maEndValue = maStartValue + *maBy;
+            }
+        }
+    }
+
     virtual void endAnimation()
     {
         // end animation
@@ -268,7 +340,18 @@ public:
         }
     }
 
+    /// Disposable:
+    virtual void dispose()
+    {
+        mpAnim.reset();
+        BaseType::dispose();
+    }
+
 private:
+    const OptionalValueType                 maFrom;
+    const OptionalValueType                 maTo;
+    const OptionalValueType                 maBy;
+
     ExpressionNodeSharedPtr                 mpFormula;
 
     ValueType                               maStartValue;
@@ -338,6 +421,7 @@ AnimationActivitySharedPtr createFromToByActivity(
 
     return AnimationActivitySharedPtr(
         new FromToByActivity<BaseType, AnimationType>(
+            aFrom,
             aTo,
             aBy,
             rParms,
@@ -439,6 +523,17 @@ public:
         ENSURE_OR_THROW( !rValues.empty(), "Empty value vector" );
     }
 
+    virtual void startAnimation()
+    {
+        if (this->isDisposed() || !mpAnim)
+            return;
+        BaseType::startAnimation();
+
+        // start animation
+        mpAnim->start( BaseType::getShape(),
+                       BaseType::getShapeAttributeLayer() );
+    }
+
     virtual void endAnimation()
     {
         // end animation
-- 
2.9.3

