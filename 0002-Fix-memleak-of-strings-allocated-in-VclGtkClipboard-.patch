From b88646fc68cfc1c3840024fe3a59727c9eb9f95d Mon Sep 17 00:00:00 2001
From: Dennis Francis <dennisfrancis.in@gmail.com>
Date: Fri, 11 Dec 2015 09:19:22 +0530
Subject: [PATCH 2/3] Fix memleak of strings allocated in
 VclGtkClipboard::makeGtkTargetEntry

This leak is produced when copy and paste of text/numbers
is done in Calc/Writer.

Following is the trace produced by valgrind (trimmed)

  malloc (in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
  g_malloc (in /usr/lib64/libglib-2.0.so.0.4600.2)
  g_strdup (in /usr/lib64/libglib-2.0.so.0.4600.2)
  VclGtkClipboard::makeGtkTargetEntry(...) (gtk3gtkinst.cxx:467)
  VclGtkClipboard::setContents(...) (gtk3gtkinst.cxx:557)
  TransferableHelper::CopyToSelection(vcl::Window*) const (transfer.cxx:1019)
  ScTabView::CheckSelectionTransfer() (tabview3.cxx:319)
  ScTabView::UpdateAutoFillMark() (tabview3.cxx:144)
  ScTabView::SelectionChanged() (tabview3.cxx:365)
  ScViewFunc::PostPasteFromClip(ScRangeList const&, ScMarkData const&) (viewfun3.cxx:1753)
  ScViewFunc::PasteFromClip(...) (viewfun3.cxx:1415)
  ScClipUtil::PasteFromClipboard(ScViewData*, ScTabViewShell*, bool) (cliputil.cxx:69)
  ScCellShell::ExecuteEdit(SfxRequest&) (cellsh1.cxx:1285)
  SfxStubScCellShellExecuteEdit(SfxShell*, SfxRequest&) (scslots.hxx:7135)
  SfxShell::CallExec(void (*)(SfxShell*, SfxRequest&), SfxRequest&) (shell.hxx:206)
  SfxDispatcher::Call_Impl(SfxShell&, SfxSlot const&, SfxRequest&, bool) (dispatch.cxx:258)...
  ...

Change-Id: I12468e746f33a64e2b5f05e9ac1c6814c702ffd7
Reviewed-on: https://gerrit.libreoffice.org/20646
Reviewed-by: jan iversen <jani@documentfoundation.org>
Tested-by: jan iversen <jani@documentfoundation.org>
(cherry picked from commit 97df0e601a0d76664b4207d075fa6e2a5a51625c)
---
 vcl/unx/gtk3/gtk3gtkinst.cxx | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/vcl/unx/gtk3/gtk3gtkinst.cxx b/vcl/unx/gtk3/gtk3gtkinst.cxx
index e9210d0..f1a9ddc 100644
--- a/vcl/unx/gtk3/gtk3gtkinst.cxx
+++ b/vcl/unx/gtk3/gtk3gtkinst.cxx
@@ -456,7 +456,7 @@ void VclGtkClipboard::OwnerChanged(GtkClipboard* clipboard, GdkEvent* /*event*/)
 void VclGtkClipboard::ClipboardClear(GtkClipboard * /*clipboard*/)
 {
     for (auto &a : m_aGtkTargets)
-        free(a.target);
+        g_free(a.target);
     m_aGtkTargets.clear();
 }
 
@@ -518,6 +518,7 @@ VclGtkClipboard::~VclGtkClipboard()
     GtkClipboard* clipboard = gtk_clipboard_get(m_nSelection);
     g_signal_handler_disconnect(clipboard, m_nOwnerChangedSignalId);
     g_object_unref(m_pOwner);
+    ClipboardClear(nullptr);
 }
 
 void VclGtkClipboard::setContents(
@@ -577,6 +578,8 @@ void VclGtkClipboard::setContents(
             //if there was a previous gtk_clipboard_set_with_data call then
             //ClipboardClearFunc will be called now
             GtkClipboard* clipboard = gtk_clipboard_get(m_nSelection);
+            if(G_OBJECT(m_pOwner) == gtk_clipboard_get_owner(clipboard))
+                gtk_clipboard_clear(clipboard);
             //use with_owner with m_pOwner so we can distinguish in handle_owner_change
             //if we have gained or lost ownership of the clipboard
             gtk_clipboard_set_with_owner(clipboard, aGtkTargets.data(), aGtkTargets.size(),
-- 
2.5.0

