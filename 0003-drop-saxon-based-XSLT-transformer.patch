From 45928a0bf76f4cd59f4bcb20ac60057e4a786910 Mon Sep 17 00:00:00 2001
From: David Tardon <dtardon@redhat.com>
Date: Wed, 10 Oct 2012 17:33:30 +0200
Subject: [PATCH 3/4] drop saxon-based XSLT transformer

(cherry picked from commit bfc71eb03e2bc6f26d53f70b32f9a8937086808b)

Conflicts:
	filter/Jar_XSLTFilter.mk
	filter/source/xsltfilter/XSLTFilter.jar.component
	filter/source/xsltfilter/com/sun/star/comp/xsltfilter/Base64.java
	filter/source/xsltfilter/com/sun/star/comp/xsltfilter/XSLTFilterOLEExtracter.java
	filter/source/xsltfilter/com/sun/star/comp/xsltfilter/XSLTransformer.java

Change-Id: I2cd4e0965452c376df8c5e43353fbdd6f62fb27d
---
 filter/Extension_xslt2_transformer.mk              |   18 -
 filter/Jar_XSLTFilter.mk                           |   45 -
 filter/Module_filter.mk                            |    2 -
 filter/source/xsltfilter/Manifest                  |    2 -
 filter/source/xsltfilter/XSLTFilter.jar.component  |   34 -
 .../com/sun/star/comp/xsltfilter/Base64.java       | 1835 --------------------
 .../comp/xsltfilter/XSLTFilterOLEExtracter.java    |  395 -----
 .../sun/star/comp/xsltfilter/XSLTransformer.java   |  506 ------
 filter/source/xsltfilter/components.rdb            |    8 -
 filter/source/xsltfilter/description-en-US.txt     |    1 -
 filter/source/xsltfilter/description.xml           |   28 -
 filter/source/xsltfilter/manifest.xml              |    6 -
 12 files changed, 2880 deletions(-)
 delete mode 100644 filter/Extension_xslt2_transformer.mk
 delete mode 100644 filter/Jar_XSLTFilter.mk
 delete mode 100644 filter/source/xsltfilter/Manifest
 delete mode 100644 filter/source/xsltfilter/XSLTFilter.jar.component
 delete mode 100644 filter/source/xsltfilter/com/sun/star/comp/xsltfilter/Base64.java
 delete mode 100644 filter/source/xsltfilter/com/sun/star/comp/xsltfilter/XSLTFilterOLEExtracter.java
 delete mode 100644 filter/source/xsltfilter/com/sun/star/comp/xsltfilter/XSLTransformer.java
 delete mode 100644 filter/source/xsltfilter/components.rdb
 delete mode 100644 filter/source/xsltfilter/description-en-US.txt
 delete mode 100644 filter/source/xsltfilter/description.xml
 delete mode 100644 filter/source/xsltfilter/manifest.xml

diff --git a/filter/Extension_xslt2_transformer.mk b/filter/Extension_xslt2_transformer.mk
deleted file mode 100644
index ab239d8..0000000
--- a/filter/Extension_xslt2_transformer.mk
+++ /dev/null
@@ -1,18 +0,0 @@
-# -*- Mode: makefile-gmake; tab-width: 4; indent-tabs-mode: t -*-
-#
-# This file is part of the LibreOffice project.
-#
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-#
-
-$(eval $(call gb_Extension_Extension,xslt2-transformer,filter/source/xsltfilter))
-
-$(eval $(call gb_Extension_add_files,xslt2-transformer,,\
-    $(call gb_Jar_get_outdir_target,saxon9) \
-    $(call gb_Jar_get_outdir_target,XSLTFilter) \
-	$(SRCDIR)/filter/source/xsltfilter/components.rdb \
-))
-
-# vim: set noet sw=4 ts=4:
diff --git a/filter/Jar_XSLTFilter.mk b/filter/Jar_XSLTFilter.mk
deleted file mode 100644
index 9522c26..0000000
--- a/filter/Jar_XSLTFilter.mk
+++ /dev/null
@@ -1,45 +0,0 @@
-#***************************************************************
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#  http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#***************************************************************
-
-$(eval $(call gb_Jar_Jar,XSLTFilter))
-
-$(eval $(call gb_Jar_use_jars,XSLTFilter,\
-	$(OUTDIR)/bin/ridl.jar \
-	$(OUTDIR)/bin/unoil.jar \
-	$(OUTDIR)/bin/jurt.jar \
-	$(OUTDIR)/bin/juh.jar \
-))
-
-$(eval $(call gb_Jar_use_externals,XSLTFilter,saxon))
-
-$(eval $(call gb_Jar_set_componentfile,XSLTFilter,filter/source/xsltfilter/XSLTFilter.jar,OOO))
-
-$(eval $(call gb_Jar_set_manifest,XSLTFilter,$(SRCDIR)/filter/source/xsltfilter/Manifest))
-
-$(eval $(call gb_Jar_set_jarclasspath,XSLTFilter,saxon9.jar))
-
-$(eval $(call gb_Jar_set_packageroot,XSLTFilter,com))
-
-$(eval $(call gb_Jar_add_sourcefiles,XSLTFilter,\
-	filter/source/xsltfilter/com/sun/star/comp/xsltfilter/Base64 \
-	filter/source/xsltfilter/com/sun/star/comp/xsltfilter/XSLTFilterOLEExtracter \
-	filter/source/xsltfilter/com/sun/star/comp/xsltfilter/XSLTransformer \
-))
-
-# vim: set noet sw=4 ts=4:
diff --git a/filter/Module_filter.mk b/filter/Module_filter.mk
index 9c18157..c372862 100644
--- a/filter/Module_filter.mk
+++ b/filter/Module_filter.mk
@@ -72,8 +72,6 @@ $(eval $(call gb_Module_add_targets,filter,\
 
 ifneq ($(SOLAR_JAVA),)
 $(eval $(call gb_Module_add_targets,filter,\
-	Extension_xslt2_transformer \
-	Jar_XSLTFilter \
 	Jar_XSLTValidate \
 ))
 endif
diff --git a/filter/source/xsltfilter/Manifest b/filter/source/xsltfilter/Manifest
deleted file mode 100644
index 1bd3102..0000000
--- a/filter/source/xsltfilter/Manifest
+++ /dev/null
@@ -1,2 +0,0 @@
-RegistrationClassName: com.sun.star.comp.xsltfilter.XSLTransformer
-UNO-Type-Path: 
diff --git a/filter/source/xsltfilter/XSLTFilter.jar.component b/filter/source/xsltfilter/XSLTFilter.jar.component
deleted file mode 100644
index d4ecd66..0000000
--- a/filter/source/xsltfilter/XSLTFilter.jar.component
+++ /dev/null
@@ -1,34 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--**********************************************************************
-*
-* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-*
-* Copyright 2000, 2010 Oracle and/or its affiliates.
-*
-* OpenOffice.org - a multi-platform office productivity suite
-*
-* This file is part of OpenOffice.org.
-*
-* OpenOffice.org is free software: you can redistribute it and/or modify
-* it under the terms of the GNU Lesser General Public License version 3
-* only, as published by the Free Software Foundation.
-*
-* OpenOffice.org is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU Lesser General Public License version 3 for more details
-* (a copy is included in the LICENSE file that accompanied this code).
-*
-* You should have received a copy of the GNU Lesser General Public License
-* version 3 along with OpenOffice.org.  If not, see
-* <http://www.openoffice.org/license.html>
-* for a copy of the LGPLv3 License.
-*
-**********************************************************************-->
-
-<component loader="com.sun.star.loader.Java2"
-    xmlns="http://openoffice.org/2010/uno-components">
-  <implementation name="XSLTransformer">
-    <service name="com.sun.star.comp.JAXTHelper"/>
-  </implementation>
-</component>
diff --git a/filter/source/xsltfilter/com/sun/star/comp/xsltfilter/Base64.java b/filter/source/xsltfilter/com/sun/star/comp/xsltfilter/Base64.java
deleted file mode 100644
index f92012e..0000000
--- a/filter/source/xsltfilter/com/sun/star/comp/xsltfilter/Base64.java
+++ /dev/null
@@ -1,1835 +0,0 @@
-package com.sun.star.comp.xsltfilter;
-
-/************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2000, 2010 Oracle and/or its affiliates.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-/**
- * <p>Encodes and decodes to and from Base64 notation.</p>
- * <p>Homepage: <a href="http://iharder.net/base64">http://iharder.net/base64</a>.</p>
- *
- * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass
- * several pieces of information to the encoder. In the "higher level" methods such as
- * encodeBytes( bytes, options ) the options parameter can be used to indicate such
- * things as first gzipping the bytes before encoding them, not inserting linefeeds
- * (though that breaks strict Base64 compatibility), and encoding using the URL-safe
- * and Ordered dialects.</p>
- *
- * <p>The constants defined in Base64 can be OR-ed together to combine options, so you
- * might make a call like this:</p>
- *
- * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DONT_BREAK_LINES );</code>
- *
- * <p>to compress the data before encoding it and then making the output have no newline characters.</p>
- *
- *
- * <p>
- * Change Log:
- * </p>
- * <ul>
- *  <li>v2.2.2 - Fixed encodeFileToFile and decodeFileToFile to use the
- *   Base64.InputStream class to encode and decode on the fly which uses
- *   less memory than encoding/decoding an entire file into memory before writing.</li>
- *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug
- *   when using very small files (~< 40 bytes).</li>
- *  <li>v2.2 - Added some helper methods for encoding/decoding directly from
- *   one file to the next. Also added a main() method to support command line
- *   encoding/decoding from one file to the next. Also added these Base64 dialects:
- *   <ol>
- *   <li>The default is RFC3548 format.</li>
- *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates
- *   URL and file name friendly format as described in Section 4 of RFC3548.
- *   http://www.faqs.org/rfcs/rfc3548.html</li>
- *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates
- *   URL and file name friendly format that preserves lexical ordering as described
- *   in http://www.faqs.org/qa/rfcc-1940.html</li>
- *   </ol>
- *   Special thanks to Jim Kellerman at <a href="http://www.powerset.com/">http://www.powerset.com/</a>
- *   for contributing the new Base64 dialects.
- *  </li>
- *
- *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added
- *   some convenience methods for reading and writing to and from files.</li>
- *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems
- *   with other encodings (like EBCDIC).</li>
- *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the
- *   encoded data was a single byte.</li>
- *  <li>v2.0 - I got rid of methods that used booleans to set options.
- *   Now everything is more consolidated and cleaner. The code now detects
- *   when data that's being decoded is gzip-compressed and will decompress it
- *   automatically. Generally things are cleaner. You'll probably have to
- *   change some method calls that you were making to support the new
- *   options format (<tt>int</tt>s that you "OR" together).</li>
- *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a
- *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.
- *   Added the ability to "suspend" encoding in the Output Stream so
- *   you can turn on and off the encoding if you need to embed base64
- *   data in an otherwise "normal" stream (like an XML file).</li>
- *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.
- *      This helps when using GZIP streams.
- *      Added the ability to GZip-compress objects before encoding them.</li>
- *  <li>v1.4 - Added helper methods to read/write files.</li>
- *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>
- *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream
- *      where last buffer being read, if not completely full, was not returned.</li>
- *  <li>v1.3.4 - Fixed when "improperly padded stream" error was thrown at the wrong time.</li>
- *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>
- * </ul>
- *
- * <p>
- * I am placing this code in the Public Domain. Do with it as you will.
- * This software comes with no guarantees or warranties but with
- * plenty of well-wishing instead!
- * Please visit <a href="http://iharder.net/base64">http://iharder.net/base64</a>
- * periodically to check for updates or to contribute improvements.
- * </p>
- *
- * @author Robert Harder
- * @author rob@iharder.net
- * @version 2.2.2
- */
-public class Base64
-{
-
-/* ********  P U B L I C   F I E L D S  ******** */
-
-
-    /** No options specified. Value is zero. */
-    public final static int NO_OPTIONS = 0;
-
-    /** Specify encoding. */
-    public final static int ENCODE = 1;
-
-
-    /** Specify decoding. */
-    public final static int DECODE = 0;
-
-
-    /** Specify that data should be gzip-compressed. */
-    public final static int GZIP = 2;
-
-
-    /** Don't break lines when encoding (violates strict Base64 specification) */
-    public final static int DONT_BREAK_LINES = 8;
-
-    /**
-     * Encode using Base64-like encoding that is URL- and Filename-safe as described
-     * in Section 4 of RFC3548:
-     * <a href="http://www.faqs.org/rfcs/rfc3548.html">http://www.faqs.org/rfcs/rfc3548.html</a>.
-     * It is important to note that data encoded this way is <em>not</em> officially valid Base64,
-     * or at the very least should not be called Base64 without also specifying that is
-     * was encoded using the URL- and Filename-safe dialect.
-     */
-     public final static int URL_SAFE = 16;
-
-
-     /**
-      * Encode using the special "ordered" dialect of Base64 described here:
-      * <a href="http://www.faqs.org/qa/rfcc-1940.html">http://www.faqs.org/qa/rfcc-1940.html</a>.
-      */
-     public final static int ORDERED = 32;
-
-
-/* ********  P R I V A T E   F I E L D S  ******** */
-
-
-    /** Maximum line length (76) of Base64 output. */
-    private final static int MAX_LINE_LENGTH = 76;
-
-
-    /** The equals sign (=) as a byte. */
-    private final static byte EQUALS_SIGN = (byte)'=';
-
-
-    /** The new line character (\n) as a byte. */
-    private final static byte NEW_LINE = (byte)'\n';
-
-
-    /** Preferred encoding. */
-    private final static String PREFERRED_ENCODING = "UTF-8";
-
-
-    // I think I end up not using the BAD_ENCODING indicator.
-    //private final static byte BAD_ENCODING    = -9; // Indicates error in encoding
-    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding
-    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding
-
-
-/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */
-
-    /** The 64 valid Base64 values. */
-    //private final static byte[] ALPHABET;
-    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */
-    private final static byte[] _STANDARD_ALPHABET =
-    {
-        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',
-        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',
-        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',
-        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',
-        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',
-        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',
-        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',
-        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',
-        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5',
-        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'
-    };
-
-
-    /**
-     * Translates a Base64 value to either its 6-bit reconstruction value
-     * or a negative number indicating some other meaning.
-     **/
-    private final static byte[] _STANDARD_DECODABET =
-    {
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8
-        -5,-5,                                      // Whitespace: Tab and Linefeed
-        -9,-9,                                      // Decimal 11 - 12
-        -5,                                         // Whitespace: Carriage Return
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26
-        -9,-9,-9,-9,-9,                             // Decimal 27 - 31
-        -5,                                         // Whitespace: Space
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42
-        62,                                         // Plus sign at decimal 43
-        -9,-9,-9,                                   // Decimal 44 - 46
-        63,                                         // Slash at decimal 47
-        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine
-        -9,-9,-9,                                   // Decimal 58 - 60
-        -1,                                         // Equals sign at decimal 61
-        -9,-9,-9,                                      // Decimal 62 - 64
-        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'
-        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'
-        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96
-        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'
-        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'
-        -9,-9,-9,-9                                 // Decimal 123 - 126
-        /*,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 127 - 139
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
-    };
-
-
-/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */
-
-    /**
-     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548:
-     * <a href="http://www.faqs.org/rfcs/rfc3548.html">http://www.faqs.org/rfcs/rfc3548.html</a>.
-     * Notice that the last two bytes become "hyphen" and "underscore" instead of "plus" and "slash."
-     */
-    private final static byte[] _URL_SAFE_ALPHABET =
-    {
-      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',
-      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',
-      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',
-      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',
-      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',
-      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',
-      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',
-      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',
-      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5',
-      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'
-    };
-
-    /**
-     * Used in decoding URL- and Filename-safe dialects of Base64.
-     */
-    private final static byte[] _URL_SAFE_DECODABET =
-    {
-      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8
-      -5,-5,                                      // Whitespace: Tab and Linefeed
-      -9,-9,                                      // Decimal 11 - 12
-      -5,                                         // Whitespace: Carriage Return
-      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26
-      -9,-9,-9,-9,-9,                             // Decimal 27 - 31
-      -5,                                         // Whitespace: Space
-      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42
-      -9,                                         // Plus sign at decimal 43
-      -9,                                         // Decimal 44
-      62,                                         // Minus sign at decimal 45
-      -9,                                         // Decimal 46
-      -9,                                         // Slash at decimal 47
-      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine
-      -9,-9,-9,                                   // Decimal 58 - 60
-      -1,                                         // Equals sign at decimal 61
-      -9,-9,-9,                                   // Decimal 62 - 64
-      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'
-      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'
-      -9,-9,-9,-9,                                // Decimal 91 - 94
-      63,                                         // Underscore at decimal 95
-      -9,                                         // Decimal 96
-      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'
-      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'
-      -9,-9,-9,-9                                 // Decimal 123 - 126
-      /*,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 127 - 139
-      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
-      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
-      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
-      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
-      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
-      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
-      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
-      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
-      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
-    };
-
-
-
-/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */
-
-    /**
-     * I don't get the point of this technique, but it is described here:
-     * <a href="http://www.faqs.org/qa/rfcc-1940.html">http://www.faqs.org/qa/rfcc-1940.html</a>.
-     */
-    private final static byte[] _ORDERED_ALPHABET =
-    {
-      (byte)'-',
-      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',
-      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',
-      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',
-      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',
-      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',
-      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',
-      (byte)'_',
-      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',
-      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',
-      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',
-      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'
-    };
-
-    /**
-     * Used in decoding the "ordered" dialect of Base64.
-     */
-    private final static byte[] _ORDERED_DECODABET =
-    {
-      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8
-      -5,-5,                                      // Whitespace: Tab and Linefeed
-      -9,-9,                                      // Decimal 11 - 12
-      -5,                                         // Whitespace: Carriage Return
-      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26
-      -9,-9,-9,-9,-9,                             // Decimal 27 - 31
-      -5,                                         // Whitespace: Space
-      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42
-      -9,                                         // Plus sign at decimal 43
-      -9,                                         // Decimal 44
-      0,                                          // Minus sign at decimal 45
-      -9,                                         // Decimal 46
-      -9,                                         // Slash at decimal 47
-      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine
-      -9,-9,-9,                                   // Decimal 58 - 60
-      -1,                                         // Equals sign at decimal 61
-      -9,-9,-9,                                   // Decimal 62 - 64
-      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'
-      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'
-      -9,-9,-9,-9,                                // Decimal 91 - 94
-      37,                                         // Underscore at decimal 95
-      -9,                                         // Decimal 96
-      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'
-      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'
-      -9,-9,-9,-9                                 // Decimal 123 - 126
-      /*,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 127 - 139
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
-    };
-
-
-/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */
-
-
-    /**
-     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on
-     * the options specified.
-     * It's possible, though silly, to specify ORDERED and URLSAFE
-     * in which case one of them will be picked, though there is
-     * no guarantee as to which one will be picked.
-     */
-    private final static byte[] getAlphabet( int options )
-    {
-        if( (options & URL_SAFE) == URL_SAFE ) return _URL_SAFE_ALPHABET;
-        else if( (options & ORDERED) == ORDERED ) return _ORDERED_ALPHABET;
-        else return _STANDARD_ALPHABET;
-
-    }   // end getAlphabet
-
-
-    /**
-     * Returns one of the _SOMETHING_DECODABET byte arrays depending on
-     * the options specified.
-     * It's possible, though silly, to specify ORDERED and URL_SAFE
-     * in which case one of them will be picked, though there is
-     * no guarantee as to which one will be picked.
-     */
-    private final static byte[] getDecodabet( int options )
-    {
-        if( (options & URL_SAFE) == URL_SAFE ) return _URL_SAFE_DECODABET;
-        else if( (options & ORDERED) == ORDERED ) return _ORDERED_DECODABET;
-        else return _STANDARD_DECODABET;
-
-    }   // end getAlphabet
-
-
-
-    /** Defeats instantiation. */
-    private Base64(){}
-
-
-    /**
-     * Encodes or decodes two files from the command line;
-     * <strong>feel free to delete this method (in fact you probably should)
-     * if you're embedding this code into a larger program.</strong>
-     */
-    public final static void main( String[] args )
-    {
-        if( args.length < 3 ){
-            usage("Not enough arguments.");
-        }   // end if: args.length < 3
-        else {
-            String flag = args[0];
-            String infile = args[1];
-            String outfile = args[2];
-            if( flag.equals( "-e" ) ){
-                Base64.encodeFileToFile( infile, outfile );
-            }   // end if: encode
-            else if( flag.equals( "-d" ) ) {
-                Base64.decodeFileToFile( infile, outfile );
-            }   // end else if: decode
-            else {
-                usage( "Unknown flag: " + flag );
-            }   // end else
-        }   // end else
-    }   // end main
-
-    /**
-     * Prints command line usage.
-     *
-     * @param msg A message to include with usage info.
-     */
-    private final static void usage( String msg )
-    {
-        System.err.println( msg );
-        System.err.println( "Usage: java Base64 -e|-d inputfile outputfile" );
-    }   // end usage
-
-
-/* ********  E N C O D I N G   M E T H O D S  ******** */
-
-
-    /**
-     * Encodes up to the first three bytes of array <var>threeBytes</var>
-     * and returns a four-byte array in Base64 notation.
-     * The actual number of significant bytes in your array is
-     * given by <var>numSigBytes</var>.
-     * The array <var>threeBytes</var> needs only be as big as
-     * <var>numSigBytes</var>.
-     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.
-     *
-     * @param b4 A reusable byte array to reduce array instantiation
-     * @param threeBytes the array to convert
-     * @param numSigBytes the number of significant bytes in your array
-     * @return four byte array in Base64 notation.
-     * @since 1.5.1
-     */
-    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options )
-    {
-        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );
-        return b4;
-    }   // end encode3to4
-
-
-    /**
-     * <p>Encodes up to three bytes of the array <var>source</var>
-     * and writes the resulting four Base64 bytes to <var>destination</var>.
-     * The source and destination arrays can be manipulated
-     * anywhere along their length by specifying
-     * <var>srcOffset</var> and <var>destOffset</var>.
-     * This method does not check to make sure your arrays
-     * are large enough to accomodate <var>srcOffset</var> + 3 for
-     * the <var>source</var> array or <var>destOffset</var> + 4 for
-     * the <var>destination</var> array.
-     * The actual number of significant bytes in your array is
-     * given by <var>numSigBytes</var>.</p>
-     * <p>This is the lowest level of the encoding methods with
-     * all possible parameters.</p>
-     *
-     * @param source the array to convert
-     * @param srcOffset the index where conversion begins
-     * @param numSigBytes the number of significant bytes in your array
-     * @param destination the array to hold the conversion
-     * @param destOffset the index where output will be put
-     * @return the <var>destination</var> array
-     * @since 1.3
-     */
-    private static byte[] encode3to4(
-     byte[] source, int srcOffset, int numSigBytes,
-     byte[] destination, int destOffset, int options )
-    {
-        byte[] ALPHABET = getAlphabet( options );
-
-        //           1         2         3
-        // 01234567890123456789012345678901 Bit position
-        // --------000000001111111122222222 Array position from threeBytes
-        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET
-        //          >>18  >>12  >> 6  >> 0  Right shift necessary
-        //                0x3f  0x3f  0x3f  Additional AND
-
-        // Create buffer with zero-padding if there are only one or two
-        // significant bytes passed in the array.
-        // We have to shift left 24 in order to flush out the 1's that appear
-        // when Java treats a value as negative that is cast from a byte to an int.
-        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )
-                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )
-                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );
-
-        switch( numSigBytes )
-        {
-            case 3:
-                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];
-                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];
-                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];
-                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];
-                return destination;
-
-            case 2:
-                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];
-                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];
-                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];
-                destination[ destOffset + 3 ] = EQUALS_SIGN;
-                return destination;
-
-            case 1:
-                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];
-                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];
-                destination[ destOffset + 2 ] = EQUALS_SIGN;
-                destination[ destOffset + 3 ] = EQUALS_SIGN;
-                return destination;
-
-            default:
-                return destination;
-        }   // end switch
-    }   // end encode3to4
-
-
-
-    /**
-     * Serializes an object and returns the Base64-encoded
-     * version of that serialized object. If the object
-     * cannot be serialized or there is another error,
-     * the method will return <tt>null</tt>.
-     * The object is not GZip-compressed before being encoded.
-     *
-     * @param serializableObject The object to encode
-     * @return The Base64-encoded object
-     * @since 1.4
-     */
-    public static String encodeObject( java.io.Serializable serializableObject )
-    {
-        return encodeObject( serializableObject, NO_OPTIONS );
-    }   // end encodeObject
-
-
-
-    /**
-     * Serializes an object and returns the Base64-encoded
-     * version of that serialized object. If the object
-     * cannot be serialized or there is another error,
-     * the method will return <tt>null</tt>.
-     * <p>
-     * Valid options:<pre>
-     *   GZIP: gzip-compresses object before encoding it.
-     *   DONT_BREAK_LINES: don't break lines at 76 characters
-     *     <i>Note: Technically, this makes your encoding non-compliant.</i>
-     * </pre>
-     * <p>
-     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or
-     * <p>
-     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DONT_BREAK_LINES )</code>
-     *
-     * @param serializableObject The object to encode
-     * @param options Specified options
-     * @return The Base64-encoded object
-     * @see Base64#GZIP
-     * @see Base64#DONT_BREAK_LINES
-     * @since 2.0
-     */
-    public static String encodeObject( java.io.Serializable serializableObject, int options )
-    {
-        // Streams
-        java.io.ByteArrayOutputStream  baos  = null;
-        java.io.OutputStream           b64os = null;
-        java.io.ObjectOutputStream     oos   = null;
-        java.util.zip.GZIPOutputStream gzos  = null;
-
-        // Isolate options
-        int gzip           = (options & GZIP);
-        int dontBreakLines = (options & DONT_BREAK_LINES);
-
-        try
-        {
-            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream
-            baos  = new java.io.ByteArrayOutputStream();
-            b64os = new Base64.OutputStream( baos, ENCODE | options );
-
-            // GZip?
-            if( gzip == GZIP )
-            {
-                gzos = new java.util.zip.GZIPOutputStream( b64os );
-                oos  = new java.io.ObjectOutputStream( gzos );
-            }   // end if: gzip
-            else
-                oos   = new java.io.ObjectOutputStream( b64os );
-
-            oos.writeObject( serializableObject );
-        }   // end try
-        catch( java.io.IOException e )
-        {
-            e.printStackTrace();
-            return null;
-        }   // end catch
-        finally
-        {
-            try{ oos.close();   } catch( Exception e ){}
-            try{ gzos.close();  } catch( Exception e ){}
-            try{ b64os.close(); } catch( Exception e ){}
-            try{ baos.close();  } catch( Exception e ){}
-        }   // end finally
-
-        // Return value according to relevant encoding.
-        try
-        {
-            return new String( baos.toByteArray(), PREFERRED_ENCODING );
-        }   // end try
-        catch (java.io.UnsupportedEncodingException uue)
-        {
-            return new String( baos.toByteArray() );
-        }   // end catch
-
-    }   // end encode
-
-
-
-    /**
-     * Encodes a byte array into Base64 notation.
-     * Does not GZip-compress data.
-     *
-     * @param source The data to convert
-     * @since 1.4
-     */
-    public static String encodeBytes( byte[] source )
-    {
-        return encodeBytes( source, 0, source.length, NO_OPTIONS );
-    }   // end encodeBytes
-
-
-
-    /**
-     * Encodes a byte array into Base64 notation.
-     * <p>
-     * Valid options:<pre>
-     *   GZIP: gzip-compresses object before encoding it.
-     *   DONT_BREAK_LINES: don't break lines at 76 characters
-     *     <i>Note: Technically, this makes your encoding non-compliant.</i>
-     * </pre>
-     * <p>
-     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or
-     * <p>
-     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )</code>
-     *
-     *
-     * @param source The data to convert
-     * @param options Specified options
-     * @see Base64#GZIP
-     * @see Base64#DONT_BREAK_LINES
-     * @since 2.0
-     */
-    public static String encodeBytes( byte[] source, int options )
-    {
-        return encodeBytes( source, 0, source.length, options );
-    }   // end encodeBytes
-
-
-    /**
-     * Encodes a byte array into Base64 notation.
-     * Does not GZip-compress data.
-     *
-     * @param source The data to convert
-     * @param off Offset in array where conversion should begin
-     * @param len Length of data to convert
-     * @since 1.4
-     */
-    public static String encodeBytes( byte[] source, int off, int len )
-    {
-        return encodeBytes( source, off, len, NO_OPTIONS );
-    }   // end encodeBytes
-
-
-
-    /**
-     * Encodes a byte array into Base64 notation.
-     * <p>
-     * Valid options:<pre>
-     *   GZIP: gzip-compresses object before encoding it.
-     *   DONT_BREAK_LINES: don't break lines at 76 characters
-     *     <i>Note: Technically, this makes your encoding non-compliant.</i>
-     * </pre>
-     * <p>
-     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or
-     * <p>
-     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )</code>
-     *
-     *
-     * @param source The data to convert
-     * @param off Offset in array where conversion should begin
-     * @param len Length of data to convert
-     * @param options Specified options
-     * @param options alphabet type is pulled from this (standard, url-safe, ordered)
-     * @see Base64#GZIP
-     * @see Base64#DONT_BREAK_LINES
-     * @since 2.0
-     */
-    public static String encodeBytes( byte[] source, int off, int len, int options )
-    {
-        // Isolate options
-        int dontBreakLines = ( options & DONT_BREAK_LINES );
-        int gzip           = ( options & GZIP   );
-
-        // Compress?
-        if( gzip == GZIP )
-        {
-            java.io.ByteArrayOutputStream  baos  = null;
-            java.util.zip.GZIPOutputStream gzos  = null;
-            Base64.OutputStream            b64os = null;
-
-
-            try
-            {
-                // GZip -> Base64 -> ByteArray
-                baos = new java.io.ByteArrayOutputStream();
-                b64os = new Base64.OutputStream( baos, ENCODE | options );
-                gzos  = new java.util.zip.GZIPOutputStream( b64os );
-
-                gzos.write( source, off, len );
-                gzos.close();
-            }   // end try
-            catch( java.io.IOException e )
-            {
-                e.printStackTrace();
-                return null;
-            }   // end catch
-            finally
-            {
-                try{ gzos.close();  } catch( Exception e ){}
-                try{ b64os.close(); } catch( Exception e ){}
-                try{ baos.close();  } catch( Exception e ){}
-            }   // end finally
-
-            // Return value according to relevant encoding.
-            try
-            {
-                return new String( baos.toByteArray(), PREFERRED_ENCODING );
-            }   // end try
-            catch (java.io.UnsupportedEncodingException uue)
-            {
-                return new String( baos.toByteArray() );
-            }   // end catch
-        }   // end if: compress
-
-        // Else, don't compress. Better not to use streams at all then.
-        else
-        {
-            // Convert option to boolean in way that code likes it.
-            boolean breakLines = dontBreakLines == 0;
-
-            int    len43   = len * 4 / 3;
-            byte[] outBuff = new byte[   ( len43 )                      // Main 4:3
-                                       + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding
-                                       + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines
-            int d = 0;
-            int e = 0;
-            int len2 = len - 2;
-            int lineLength = 0;
-            for( ; d < len2; d+=3, e+=4 )
-            {
-                encode3to4( source, d+off, 3, outBuff, e, options );
-
-                lineLength += 4;
-                if( breakLines && lineLength == MAX_LINE_LENGTH )
-                {
-                    outBuff[e+4] = NEW_LINE;
-                    e++;
-                    lineLength = 0;
-                }   // end if: end of line
-            }   // en dfor: each piece of array
-
-            if( d < len )
-            {
-                encode3to4( source, d+off, len - d, outBuff, e, options );
-                e += 4;
-            }   // end if: some padding needed
-
-
-            // Return value according to relevant encoding.
-            try
-            {
-                return new String( outBuff, 0, e, PREFERRED_ENCODING );
-            }   // end try
-            catch (java.io.UnsupportedEncodingException uue)
-            {
-                return new String( outBuff, 0, e );
-            }   // end catch
-
-        }   // end else: don't compress
-
-    }   // end encodeBytes
-
-
-
-
-
-/* ********  D E C O D I N G   M E T H O D S  ******** */
-
-
-    /**
-     * Decodes four bytes from array <var>source</var>
-     * and writes the resulting bytes (up to three of them)
-     * to <var>destination</var>.
-     * The source and destination arrays can be manipulated
-     * anywhere along their length by specifying
-     * <var>srcOffset</var> and <var>destOffset</var>.
-     * This method does not check to make sure your arrays
-     * are large enough to accomodate <var>srcOffset</var> + 4 for
-     * the <var>source</var> array or <var>destOffset</var> + 3 for
-     * the <var>destination</var> array.
-     * This method returns the actual number of bytes that
-     * were converted from the Base64 encoding.
-     * <p>This is the lowest level of the decoding methods with
-     * all possible parameters.</p>
-     *
-     *
-     * @param source the array to convert
-     * @param srcOffset the index where conversion begins
-     * @param destination the array to hold the conversion
-     * @param destOffset the index where output will be put
-     * @param options alphabet type is pulled from this (standard, url-safe, ordered)
-     * @return the number of decoded bytes converted
-     * @since 1.3
-     */
-    private static int decode4to3( byte[] source, int srcOffset, byte[] destination, int destOffset, int options )
-    {
-        byte[] DECODABET = getDecodabet( options );
-
-        // Example: Dk==
-        if( source[ srcOffset + 2] == EQUALS_SIGN )
-        {
-            // Two ways to do the same thing. Don't know which way I like best.
-            //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )
-            //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );
-            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )
-                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );
-
-            destination[ destOffset ] = (byte)( outBuff >>> 16 );
-            return 1;
-        }
-
-        // Example: DkL=
-        else if( source[ srcOffset + 3 ] == EQUALS_SIGN )
-        {
-            // Two ways to do the same thing. Don't know which way I like best.
-            //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )
-            //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )
-            //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );
-            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )
-                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )
-                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );
-
-            destination[ destOffset     ] = (byte)( outBuff >>> 16 );
-            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );
-            return 2;
-        }
-
-        // Example: DkLE
-        else
-        {
-            try{
-            // Two ways to do the same thing. Don't know which way I like best.
-            //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )
-            //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )
-            //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )
-            //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );
-            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )
-                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )
-                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)
-                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );
-
-
-            destination[ destOffset     ] = (byte)( outBuff >> 16 );
-            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );
-            destination[ destOffset + 2 ] = (byte)( outBuff       );
-
-            return 3;
-            }catch( Exception e){
-                System.out.println(""+source[srcOffset]+ ": " + ( DECODABET[ source[ srcOffset     ] ]  ) );
-                System.out.println(""+source[srcOffset+1]+  ": " + ( DECODABET[ source[ srcOffset + 1 ] ]  ) );
-                System.out.println(""+source[srcOffset+2]+  ": " + ( DECODABET[ source[ srcOffset + 2 ] ]  ) );
-                System.out.println(""+source[srcOffset+3]+  ": " + ( DECODABET[ source[ srcOffset + 3 ] ]  ) );
-                return -1;
-            }   // end catch
-        }
-    }   // end decodeToBytes
-
-
-
-
-    /**
-     * Very low-level access to decoding ASCII characters in
-     * the form of a byte array. Does not support automatically
-     * gunzipping or any other "fancy" features.
-     *
-     * @param source The Base64 encoded data
-     * @param off    The offset of where to begin decoding
-     * @param len    The length of characters to decode
-     * @return decoded data
-     * @since 1.3
-     */
-    public static byte[] decode( byte[] source, int off, int len, int options )
-    {
-        byte[] DECODABET = getDecodabet( options );
-
-        int    len34   = len * 3 / 4;
-        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output
-        int    outBuffPosn = 0;
-
-        byte[] b4        = new byte[4];
-        int    b4Posn    = 0;
-        int    i         = 0;
-        byte   sbiCrop   = 0;
-        byte   sbiDecode = 0;
-        for( i = off; i < off+len; i++ )
-        {
-            sbiCrop = (byte)(source[i] & 0x7f); // Only the low seven bits
-            sbiDecode = DECODABET[ sbiCrop ];
-
-            if( sbiDecode >= WHITE_SPACE_ENC ) // White space, Equals sign or better
-            {
-                if( sbiDecode >= EQUALS_SIGN_ENC )
-                {
-                    b4[ b4Posn++ ] = sbiCrop;
-                    if( b4Posn > 3 )
-                    {
-                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );
-                        b4Posn = 0;
-
-                        // If that was the equals sign, break out of 'for' loop
-                        if( sbiCrop == EQUALS_SIGN )
-                            break;
-                    }   // end if: quartet built
-
-                }   // end if: equals sign or better
-
-            }   // end if: white space, equals sign or better
-            else
-            {
-                System.err.println( "Bad Base64 input character at " + i + ": " + source[i] + "(decimal)" );
-                return null;
-            }   // end else:
-        }   // each input character
-
-        byte[] out = new byte[ outBuffPosn ];
-        System.arraycopy( outBuff, 0, out, 0, outBuffPosn );
-        return out;
-    }   // end decode
-
-
-
-
-    /**
-     * Decodes data from Base64 notation, automatically
-     * detecting gzip-compressed data and decompressing it.
-     *
-     * @param s the string to decode
-     * @return the decoded data
-     * @since 1.4
-     */
-    public static byte[] decode( String s )
-    {
-        return decode( s, NO_OPTIONS );
-    }
-
-
-    /**
-     * Decodes data from Base64 notation, automatically
-     * detecting gzip-compressed data and decompressing it.
-     *
-     * @param s the string to decode
-     * @param options encode options such as URL_SAFE
-     * @return the decoded data
-     * @since 1.4
-     */
-    public static byte[] decode( String s, int options )
-    {
-        byte[] bytes;
-        try
-        {
-            bytes = s.getBytes( PREFERRED_ENCODING );
-        }   // end try
-        catch( java.io.UnsupportedEncodingException uee )
-        {
-            bytes = s.getBytes();
-        }   // end catch
-        //</change>
-
-        // Decode
-        bytes = decode( bytes, 0, bytes.length, options );
-
-
-        // Check to see if it's gzip-compressed
-        // GZIP Magic Two-Byte Number: 0x8b1f (35615)
-        if( bytes != null && bytes.length >= 4 )
-        {
-
-            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);
-            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )
-            {
-                java.io.ByteArrayInputStream  bais = null;
-                java.util.zip.GZIPInputStream gzis = null;
-                java.io.ByteArrayOutputStream baos = null;
-                byte[] buffer = new byte[2048];
-                int    length = 0;
-
-                try
-                {
-                    baos = new java.io.ByteArrayOutputStream();
-                    bais = new java.io.ByteArrayInputStream( bytes );
-                    gzis = new java.util.zip.GZIPInputStream( bais );
-
-                    while( ( length = gzis.read( buffer ) ) >= 0 )
-                    {
-                        baos.write(buffer,0,length);
-                    }   // end while: reading input
-
-                    // No error? Get new bytes.
-                    bytes = baos.toByteArray();
-
-                }   // end try
-                catch( java.io.IOException e )
-                {
-                    // Just return originally-decoded bytes
-                }   // end catch
-                finally
-                {
-                    try{ baos.close(); } catch( Exception e ){}
-                    try{ gzis.close(); } catch( Exception e ){}
-                    try{ bais.close(); } catch( Exception e ){}
-                }   // end finally
-
-            }   // end if: gzipped
-        }   // end if: bytes.length >= 2
-
-        return bytes;
-    }   // end decode
-
-
-
-
-    /**
-     * Attempts to decode Base64 data and deserialize a Java
-     * Object within. Returns <tt>null</tt> if there was an error.
-     *
-     * @param encodedObject The Base64 data to decode
-     * @return The decoded and deserialized object
-     * @since 1.5
-     */
-    public static Object decodeToObject( String encodedObject )
-    {
-        // Decode and gunzip if necessary
-        byte[] objBytes = decode( encodedObject );
-
-        java.io.ByteArrayInputStream  bais = null;
-        java.io.ObjectInputStream     ois  = null;
-        Object obj = null;
-
-        try
-        {
-            bais = new java.io.ByteArrayInputStream( objBytes );
-            ois  = new java.io.ObjectInputStream( bais );
-
-            obj = ois.readObject();
-        }   // end try
-        catch( java.io.IOException e )
-        {
-            e.printStackTrace();
-            obj = null;
-        }   // end catch
-        catch( java.lang.ClassNotFoundException e )
-        {
-            e.printStackTrace();
-            obj = null;
-        }   // end catch
-        finally
-        {
-            try{ bais.close(); } catch( Exception e ){}
-            try{ ois.close();  } catch( Exception e ){}
-        }   // end finally
-
-        return obj;
-    }   // end decodeObject
-
-
-
-    /**
-     * Convenience method for encoding data to a file.
-     *
-     * @param dataToEncode byte array of data to encode in base64 form
-     * @param filename Filename for saving encoded data
-     * @return <tt>true</tt> if successful, <tt>false</tt> otherwise
-     *
-     * @since 2.1
-     */
-    public static boolean encodeToFile( byte[] dataToEncode, String filename )
-    {
-        boolean success = false;
-        Base64.OutputStream bos = null;
-        try
-        {
-            bos = new Base64.OutputStream(
-                      new java.io.FileOutputStream( filename ), Base64.ENCODE );
-            bos.write( dataToEncode );
-            success = true;
-        }   // end try
-        catch( java.io.IOException e )
-        {
-
-            success = false;
-        }   // end catch: IOException
-        finally
-        {
-            try{ bos.close(); } catch( Exception e ){}
-        }   // end finally
-
-        return success;
-    }   // end encodeToFile
-
-
-    /**
-     * Convenience method for decoding data to a file.
-     *
-     * @param dataToDecode Base64-encoded data as a string
-     * @param filename Filename for saving decoded data
-     * @return <tt>true</tt> if successful, <tt>false</tt> otherwise
-     *
-     * @since 2.1
-     */
-    public static boolean decodeToFile( String dataToDecode, String filename )
-    {
-        boolean success = false;
-        Base64.OutputStream bos = null;
-        try
-        {
-                bos = new Base64.OutputStream(
-                          new java.io.FileOutputStream( filename ), Base64.DECODE );
-                bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );
-                success = true;
-        }   // end try
-        catch( java.io.IOException e )
-        {
-            success = false;
-        }   // end catch: IOException
-        finally
-        {
-                try{ bos.close(); } catch( Exception e ){}
-        }   // end finally
-
-        return success;
-    }   // end decodeToFile
-
-
-
-
-    /**
-     * Convenience method for reading a base64-encoded
-     * file and decoding it.
-     *
-     * @param filename Filename for reading encoded data
-     * @return decoded byte array or null if unsuccessful
-     *
-     * @since 2.1
-     */
-    public static byte[] decodeFromFile( String filename )
-    {
-        byte[] decodedData = null;
-        Base64.InputStream bis = null;
-        try
-        {
-            // Set up some useful variables
-            java.io.File file = new java.io.File( filename );
-            byte[] buffer = null;
-            int length   = 0;
-            int numBytes = 0;
-
-            // Check for size of file
-            if( file.length() > Integer.MAX_VALUE )
-            {
-                System.err.println( "File is too big for this convenience method (" + file.length() + " bytes)." );
-                return null;
-            }   // end if: file too big for int index
-            buffer = new byte[ (int)file.length() ];
-
-            // Open a stream
-            bis = new Base64.InputStream(
-                      new java.io.BufferedInputStream(
-                      new java.io.FileInputStream( file ) ), Base64.DECODE );
-
-            // Read until done
-            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 )
-                length += numBytes;
-
-            // Save in a variable to return
-            decodedData = new byte[ length ];
-            System.arraycopy( buffer, 0, decodedData, 0, length );
-
-        }   // end try
-        catch( java.io.IOException e )
-        {
-            System.err.println( "Error decoding from file " + filename );
-        }   // end catch: IOException
-        finally
-        {
-            try{ bis.close(); } catch( Exception e) {}
-        }   // end finally
-
-        return decodedData;
-    }   // end decodeFromFile
-
-
-
-    /**
-     * Convenience method for reading a binary file
-     * and base64-encoding it.
-     *
-     * @param filename Filename for reading binary data
-     * @return base64-encoded string or null if unsuccessful
-     *
-     * @since 2.1
-     */
-    public static String encodeFromFile( String filename )
-    {
-        String encodedData = null;
-        Base64.InputStream bis = null;
-        try
-        {
-            // Set up some useful variables
-            java.io.File file = new java.io.File( filename );
-            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4),40) ]; // Need max() for math on small files (v2.2.1)
-            int length   = 0;
-            int numBytes = 0;
-
-            // Open a stream
-            bis = new Base64.InputStream(
-                      new java.io.BufferedInputStream(
-                      new java.io.FileInputStream( file ) ), Base64.ENCODE );
-
-            // Read until done
-            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 )
-                length += numBytes;
-
-            // Save in a variable to return
-            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );
-
-        }   // end try
-        catch( java.io.IOException e )
-        {
-            System.err.println( "Error encoding from file " + filename );
-        }   // end catch: IOException
-        finally
-        {
-            try{ bis.close(); } catch( Exception e) {}
-        }   // end finally
-
-        return encodedData;
-        }   // end encodeFromFile
-
-
-
-
-    /**
-     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.
-     *
-     * @param infile Input file
-     * @param outfile Output file
-     * @return true if the operation is successful
-     * @since 2.2
-     */
-    public static boolean encodeFileToFile( String infile, String outfile )
-    {
-        boolean success = false;
-        java.io.InputStream in = null;
-        java.io.OutputStream out = null;
-        try{
-            in  = new Base64.InputStream(
-                      new java.io.BufferedInputStream(
-                      new java.io.FileInputStream( infile ) ),
-                      Base64.ENCODE );
-            out = new java.io.BufferedOutputStream( new java.io.FileOutputStream( outfile ) );
-            byte[] buffer = new byte[65536]; // 64K
-            int read = -1;
-            while( ( read = in.read(buffer) ) >= 0 ){
-                out.write( buffer,0,read );
-            }   // end while: through file
-            success = true;
-        } catch( java.io.IOException exc ){
-            exc.printStackTrace();
-        } finally{
-            try{ in.close();  } catch( Exception exc ){}
-            try{ out.close(); } catch( Exception exc ){}
-        }   // end finally
-
-        return success;
-    }   // end encodeFileToFile
-
-
-
-    /**
-     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.
-     *
-     * @param infile Input file
-     * @param outfile Output file
-     * @return true if the operation is successful
-     * @since 2.2
-     */
-    public static boolean decodeFileToFile( String infile, String outfile )
-    {
-        boolean success = false;
-        java.io.InputStream in = null;
-        java.io.OutputStream out = null;
-        try{
-            in  = new Base64.InputStream(
-                      new java.io.BufferedInputStream(
-                      new java.io.FileInputStream( infile ) ),
-                      Base64.DECODE );
-            out = new java.io.BufferedOutputStream( new java.io.FileOutputStream( outfile ) );
-            byte[] buffer = new byte[65536]; // 64K
-            int read = -1;
-            while( ( read = in.read(buffer) ) >= 0 ){
-                out.write( buffer,0,read );
-            }   // end while: through file
-            success = true;
-        } catch( java.io.IOException exc ){
-            exc.printStackTrace();
-        } finally{
-            try{ in.close();  } catch( Exception exc ){}
-            try{ out.close(); } catch( Exception exc ){}
-        }   // end finally
-
-        return success;
-    }   // end decodeFileToFile
-
-
-    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */
-
-
-
-    /**
-     * A {@link Base64.InputStream} will read data from another
-     * <tt>java.io.InputStream</tt>, given in the constructor,
-     * and encode/decode to/from Base64 notation on the fly.
-     *
-     * @see Base64
-     * @since 1.3
-     */
-    public static class InputStream extends java.io.FilterInputStream
-    {
-        private boolean encode;         // Encoding or decoding
-        private int     position;       // Current position in the buffer
-        private byte[]  buffer;         // Small buffer holding converted data
-        private int     bufferLength;   // Length of buffer (3 or 4)
-        private int     numSigBytes;    // Number of meaningful bytes in the buffer
-        private int     lineLength;
-        private boolean breakLines;     // Break lines at less than 80 characters
-        private int     options;        // Record options used to create the stream.
-        private byte[]  alphabet;       // Local copies to avoid extra method calls
-        private byte[]  decodabet;      // Local copies to avoid extra method calls
-
-
-        /**
-         * Constructs a {@link Base64.InputStream} in DECODE mode.
-         *
-         * @param in the <tt>java.io.InputStream</tt> from which to read data.
-         * @since 1.3
-         */
-        public InputStream( java.io.InputStream in )
-        {
-            this( in, DECODE );
-        }   // end constructor
-
-
-        /**
-         * Constructs a {@link Base64.InputStream} in
-         * either ENCODE or DECODE mode.
-         * <p>
-         * Valid options:<pre>
-         *   ENCODE or DECODE: Encode or Decode as data is read.
-         *   DONT_BREAK_LINES: don't break lines at 76 characters
-         *     (only meaningful when encoding)
-         *     <i>Note: Technically, this makes your encoding non-compliant.</i>
-         * </pre>
-         * <p>
-         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>
-         *
-         *
-         * @param in the <tt>java.io.InputStream</tt> from which to read data.
-         * @param options Specified options
-         * @see Base64#ENCODE
-         * @see Base64#DECODE
-         * @see Base64#DONT_BREAK_LINES
-         * @since 2.0
-         */
-        public InputStream( java.io.InputStream in, int options )
-        {
-            super( in );
-            this.breakLines   = (options & DONT_BREAK_LINES) != DONT_BREAK_LINES;
-            this.encode       = (options & ENCODE) == ENCODE;
-            this.bufferLength = encode ? 4 : 3;
-            this.buffer       = new byte[ bufferLength ];
-            this.position     = -1;
-            this.lineLength   = 0;
-            this.options      = options; // Record for later, mostly to determine which alphabet to use
-            this.alphabet     = getAlphabet(options);
-            this.decodabet    = getDecodabet(options);
-        }   // end constructor
-
-        /**
-         * Reads enough of the input stream to convert
-         * to/from Base64 and returns the next byte.
-         *
-         * @return next byte
-         * @since 1.3
-         */
-        public int read() throws java.io.IOException
-        {
-            // Do we need to get data?
-            if( position < 0 )
-            {
-                if( encode )
-                {
-                    byte[] b3 = new byte[3];
-                    int numBinaryBytes = 0;
-                    for( int i = 0; i < 3; i++ )
-                    {
-                        try
-                        {
-                            int b = in.read();
-
-                            // If end of stream, b is -1.
-                            if( b >= 0 )
-                            {
-                                b3[i] = (byte)b;
-                                numBinaryBytes++;
-                            }   // end if: not end of stream
-
-                        }   // end try: read
-                        catch( java.io.IOException e )
-                        {
-                            // Only a problem if we got no data at all.
-                            if( i == 0 )
-                                throw e;
-
-                        }   // end catch
-                    }   // end for: each needed input byte
-
-                    if( numBinaryBytes > 0 )
-                    {
-                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );
-                        position = 0;
-                        numSigBytes = 4;
-                    }   // end if: got data
-                    else
-                    {
-                        return -1;
-                    }   // end else
-                }   // end if: encoding
-
-                // Else decoding
-                else
-                {
-                    byte[] b4 = new byte[4];
-                    int i = 0;
-                    for( i = 0; i < 4; i++ )
-                    {
-                        // Read four "meaningful" bytes:
-                        int b = 0;
-                        do{ b = in.read(); }
-                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );
-
-                        if( b < 0 )
-                            break; // Reads a -1 if end of stream
-
-                        b4[i] = (byte)b;
-                    }   // end for: each needed input byte
-
-                    if( i == 4 )
-                    {
-                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );
-                        position = 0;
-                    }   // end if: got four characters
-                    else if( i == 0 ){
-                        return -1;
-                    }   // end else if: also padded correctly
-                    else
-                    {
-                        // Must have broken out from above.
-                        throw new java.io.IOException( "Improperly padded Base64 input." );
-                    }   // end
-
-                }   // end else: decode
-            }   // end else: get data
-
-            // Got data?
-            if( position >= 0 )
-            {
-                // End of relevant data?
-                if( /*!encode &&*/ position >= numSigBytes )
-                    return -1;
-
-                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH )
-                {
-                    lineLength = 0;
-                    return '\n';
-                }   // end if
-                else
-                {
-                    lineLength++;   // This isn't important when decoding
-                                    // but throwing an extra "if" seems
-                                    // just as wasteful.
-
-                    int b = buffer[ position++ ];
-
-                    if( position >= bufferLength )
-                        position = -1;
-
-                    return b & 0xFF; // This is how you "cast" a byte that's
-                                     // intended to be unsigned.
-                }   // end else
-            }   // end if: position >= 0
-
-            // Else error
-            else
-            {
-                // When JDK1.4 is more accepted, use an assertion here.
-                throw new java.io.IOException( "Error in Base64 code reading stream." );
-            }   // end else
-        }   // end read
-
-
-        /**
-         * Calls {@link #read()} repeatedly until the end of stream
-         * is reached or <var>len</var> bytes are read.
-         * Returns number of bytes read into array or -1 if
-         * end of stream is encountered.
-         *
-         * @param dest array to hold values
-         * @param off offset for array
-         * @param len max number of bytes to read into array
-         * @return bytes read into array or -1 if end of stream is encountered.
-         * @since 1.3
-         */
-        public int read( byte[] dest, int off, int len ) throws java.io.IOException
-        {
-            int i;
-            int b;
-            for( i = 0; i < len; i++ )
-            {
-                b = read();
-
-                //if( b < 0 && i == 0 )
-                //    return -1;
-
-                if( b >= 0 )
-                    dest[off + i] = (byte)b;
-                else if( i == 0 )
-                    return -1;
-                else
-                    break; // Out of 'for' loop
-            }   // end for: each byte read
-            return i;
-        }   // end read
-
-    }   // end inner class InputStream
-
-
-
-
-
-
-    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */
-
-
-
-    /**
-     * A {@link Base64.OutputStream} will write data to another
-     * <tt>java.io.OutputStream</tt>, given in the constructor,
-     * and encode/decode to/from Base64 notation on the fly.
-     *
-     * @see Base64
-     * @since 1.3
-     */
-    public static class OutputStream extends java.io.FilterOutputStream
-    {
-        private boolean encode;
-        private int     position;
-        private byte[]  buffer;
-        private int     bufferLength;
-        private int     lineLength;
-        private boolean breakLines;
-        private byte[]  b4; // Scratch used in a few places
-        private boolean suspendEncoding;
-        private int options; // Record for later
-        private byte[]  alphabet;       // Local copies to avoid extra method calls
-        private byte[]  decodabet;      // Local copies to avoid extra method calls
-
-        /**
-         * Constructs a {@link Base64.OutputStream} in ENCODE mode.
-         *
-         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.
-         * @since 1.3
-         */
-        public OutputStream( java.io.OutputStream out )
-        {
-            this( out, ENCODE );
-        }   // end constructor
-
-
-        /**
-         * Constructs a {@link Base64.OutputStream} in
-         * either ENCODE or DECODE mode.
-         * <p>
-         * Valid options:<pre>
-         *   ENCODE or DECODE: Encode or Decode as data is read.
-         *   DONT_BREAK_LINES: don't break lines at 76 characters
-         *     (only meaningful when encoding)
-         *     <i>Note: Technically, this makes your encoding non-compliant.</i>
-         * </pre>
-         * <p>
-         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>
-         *
-         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.
-         * @param options Specified options.
-         * @see Base64#ENCODE
-         * @see Base64#DECODE
-         * @see Base64#DONT_BREAK_LINES
-         * @since 1.3
-         */
-        public OutputStream( java.io.OutputStream out, int options )
-        {
-            super( out );
-            this.breakLines   = (options & DONT_BREAK_LINES) != DONT_BREAK_LINES;
-            this.encode       = (options & ENCODE) == ENCODE;
-            this.bufferLength = encode ? 3 : 4;
-            this.buffer       = new byte[ bufferLength ];
-            this.position     = 0;
-            this.lineLength   = 0;
-            this.suspendEncoding = false;
-            this.b4           = new byte[4];
-            this.options      = options;
-            this.alphabet     = getAlphabet(options);
-            this.decodabet    = getDecodabet(options);
-        }   // end constructor
-
-
-        /**
-         * Writes the byte to the output stream after
-         * converting to/from Base64 notation.
-         * When encoding, bytes are buffered three
-         * at a time before the output stream actually
-         * gets a write() call.
-         * When decoding, bytes are buffered four
-         * at a time.
-         *
-         * @param theByte the byte to write
-         * @since 1.3
-         */
-        public void write(int theByte) throws java.io.IOException
-        {
-            // Encoding suspended?
-            if( suspendEncoding )
-            {
-                super.out.write( theByte );
-                return;
-            }   // end if: supsended
-
-            // Encode?
-            if( encode )
-            {
-                buffer[ position++ ] = (byte)theByte;
-                if( position >= bufferLength )  // Enough to encode.
-                {
-                    out.write( encode3to4( b4, buffer, bufferLength, options ) );
-
-                    lineLength += 4;
-                    if( breakLines && lineLength >= MAX_LINE_LENGTH )
-                    {
-                        out.write( NEW_LINE );
-                        lineLength = 0;
-                    }   // end if: end of line
-
-                    position = 0;
-                }   // end if: enough to output
-            }   // end if: encoding
-
-            // Else, Decoding
-            else
-            {
-                // Meaningful Base64 character?
-                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC )
-                {
-                    buffer[ position++ ] = (byte)theByte;
-                    if( position >= bufferLength )  // Enough to output.
-                    {
-                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );
-                        out.write( b4, 0, len );
-                        //out.write( Base64.decode4to3( buffer ) );
-                        position = 0;
-                    }   // end if: enough to output
-                }   // end if: meaningful base64 character
-                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC )
-                {
-                    throw new java.io.IOException( "Invalid character in Base64 data." );
-                }   // end else: not white space either
-            }   // end else: decoding
-        }   // end write
-
-
-
-        /**
-         * Calls {@link #write(int)} repeatedly until <var>len</var>
-         * bytes are written.
-         *
-         * @param theBytes array from which to read bytes
-         * @param off offset for array
-         * @param len max number of bytes to read into array
-         * @since 1.3
-         */
-        public void write( byte[] theBytes, int off, int len ) throws java.io.IOException
-        {
-            // Encoding suspended?
-            if( suspendEncoding )
-            {
-                super.out.write( theBytes, off, len );
-                return;
-            }   // end if: supsended
-
-            for( int i = 0; i < len; i++ )
-            {
-                write( theBytes[ off + i ] );
-            }   // end for: each byte written
-
-        }   // end write
-
-
-
-        /**
-         * Method added by PHIL. [Thanks, PHIL. -Rob]
-         * This pads the buffer without closing the stream.
-         */
-        public void flushBase64() throws java.io.IOException
-        {
-            if( position > 0 )
-            {
-                if( encode )
-                {
-                    out.write( encode3to4( b4, buffer, position, options ) );
-                    position = 0;
-                }   // end if: encoding
-                else
-                {
-                    throw new java.io.IOException( "Base64 input not properly padded." );
-                }   // end else: decoding
-            }   // end if: buffer partially full
-
-        }   // end flush
-
-
-        /**
-         * Flushes and closes (I think, in the superclass) the stream.
-         *
-         * @since 1.3
-         */
-        public void close() throws java.io.IOException
-        {
-            // 1. Ensure that pending characters are written
-            flushBase64();
-
-            // 2. Actually close the stream
-            // Base class both flushes and closes.
-            super.close();
-
-            buffer = null;
-            out    = null;
-        }   // end close
-
-
-
-        /**
-         * Suspends encoding of the stream.
-         * May be helpful if you need to embed a piece of
-         * base640-encoded data in a stream.
-         *
-         * @since 1.5.1
-         */
-        public void suspendEncoding() throws java.io.IOException
-        {
-            flushBase64();
-            this.suspendEncoding = true;
-        }   // end suspendEncoding
-
-
-        /**
-         * Resumes encoding of the stream.
-         * May be helpful if you need to embed a piece of
-         * base640-encoded data in a stream.
-         *
-         * @since 1.5.1
-         */
-        public void resumeEncoding()
-        {
-            this.suspendEncoding = false;
-        }   // end resumeEncoding
-
-
-
-    }   // end inner class OutputStream
-
-
-}   // end class Base64
diff --git a/filter/source/xsltfilter/com/sun/star/comp/xsltfilter/XSLTFilterOLEExtracter.java b/filter/source/xsltfilter/com/sun/star/comp/xsltfilter/XSLTFilterOLEExtracter.java
deleted file mode 100644
index 078e031..0000000
--- a/filter/source/xsltfilter/com/sun/star/comp/xsltfilter/XSLTFilterOLEExtracter.java
+++ /dev/null
@@ -1,395 +0,0 @@
-package com.sun.star.comp.xsltfilter;
-
-/************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2000, 2010 Oracle and/or its affiliates.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-//Standard Java classes
-import java.io.FileWriter;
-import java.util.zip.Inflater;
-import java.util.zip.Deflater;
-
-//StarOffice Interfaces and UNO
-import com.sun.star.bridge.XBridgeFactory;
-import com.sun.star.bridge.XBridge;
-import com.sun.star.connection.XConnector;
-import com.sun.star.connection.XConnection;
-import com.sun.star.container.XNameContainer;
-import com.sun.star.embed.XTransactedObject;
-import com.sun.star.io.XStream;
-import com.sun.star.io.XSeekable;
-import com.sun.star.io.XInputStream;
-import com.sun.star.io.XOutputStream;
-import com.sun.star.lang.XMultiServiceFactory;
-import com.sun.star.lang.XComponent;
-import com.sun.star.uno.XComponentContext;
-import com.sun.star.uno.UnoRuntime;
-
-/** This class is an xalan extension class. It provider 2 elements
- *  and 2 functions to used in xslt script. With this elements and functions
- *  we can convert between oledata between Wordml and OOo flat.
- *  To use it, we need a running OOo. There are two ways to get the XMultiServiceFactory.
- *  When called by OOo xslt filter, an XMultiServiceFactory will be add to the transformer
- *  by setParameter(), then we can get it using getParameter(). Another way is using an
- *  XConnection to connect to a running OOo. We connect to a running OOo, we need know the
- *  uno url. It can be set in the xslt script. The default uno url is:
- *  "uno:socket,host=localhost,port=8100;urp;StarOffice.ServiceManager"
- *  see XSLTXalanOLEExtracter.java
- */
-public class XSLTFilterOLEExtracter {
-
-    protected XMultiServiceFactory m_xMSF;
-    protected XNameContainer m_Storage;
-    protected XStream m_RootStream;
-    protected XConnection m_Connection;
-    protected String sConnectionString;
-    private static final String UNO_URL = "uno:socket,host=localhost,port=8100;urp;StarOffice.ServiceManager";
-
-    public XSLTFilterOLEExtracter() {
-    }
-
-    public void init(String unoUrl) {
-        if (unoUrl == null || unoUrl.equals("")) {
-            unoUrl = UNO_URL;
-        }
-        debugln("Init with uno url=" + unoUrl);
-        if (null == m_xMSF) {
-            try {
-                m_xMSF = connectAwareGetServiceFactory();
-            } catch (Exception ex) {
-                System.err.println("Could not connect to the office '" + unoUrl + "'\n" + ex.getMessage());
-            }
-        }
-    }
-
-    public void exit() {
-        m_Storage = null;
-        m_xMSF = null;
-        if (null != m_Connection) {
-            try {
-                m_Connection.close();
-            } catch (Exception ex) {
-                System.err.println("Could not close connection to the office.\n" + ex.getMessage());
-            }
-        }
-    }
-    //If aName = "oledata.mso" then we load the root storage from the given base64 string
-    //Otherwise we compress the stream and add it to the root storage under the name of aName
-    public void insertByName(String aName, String aBase64) {
-        debugln("insertByName(" + aName + " : " + aBase64 + ")");
-        if (aName.equals("oledata.mso")) {
-            loadRootStorageFromBase64(aBase64);
-        } else {
-            ensureCreateRootStorage();
-            insertSubStorage(aName, aBase64);
-        }
-    }
-    //If aName = "oledata.mso" then we return the base64 encoded string of the root storage
-    //Otherwise we return the base64 encoded string of the sub stream under the name of aName
-    public String getByName(String aName) {
-        if (aName.equals("oledata.mso")) {
-            try {
-                //get the length and seek to 0
-                XSeekable xSeek = (XSeekable) UnoRuntime.queryInterface(XSeekable.class, m_RootStream);
-                int oleLength = (int) xSeek.getLength();
-                xSeek.seek(0);
-                xSeek = null;
-                //read all bytes
-                XInputStream xInput = m_RootStream.getInputStream();
-                byte oledata[][] = new byte[1][oleLength];
-                xInput.readBytes(oledata, oleLength);
-                //return the base64 encoded string
-                return Base64.encodeBytes(oledata[0]);
-            } catch (Exception ex) {
-                ex.printStackTrace();
-            }
-        } else {
-            return getEncodedSubStorage(aName);
-        }
-        return "";
-    }
-    //get the sub stream which name = aName, decompress it and return the base64 encoded string
-    public String getEncodedSubStorage(String aName) {
-        debugln("getByName(" + aName + ")");
-        try {
-            if (!m_Storage.hasByName(aName)) {
-                return "Not Found:" + aName;
-            }
-            Object oSubStream = m_Storage.getByName(aName);
-            if (oSubStream == null) {
-                return "Not Found:" + aName;
-            }
-            XInputStream xSubStream = (XInputStream) UnoRuntime.queryInterface(XInputStream.class,
-                    oSubStream);
-            if (xSubStream == null) {
-                return "Not Found:" + aName;
-            }
-            //The first four byte are the length of the uncompressed data
-            byte pLength[][] = new byte[1][4];
-            XSeekable xSeek = (XSeekable) UnoRuntime.queryInterface(XSeekable.class, xSubStream);
-            xSeek.seek(0);
-            xSeek = null;
-            //Get the uncompressed length
-            int readbytes = xSubStream.readBytes(pLength, 4);
-            if (4 != readbytes) {
-                System.out.println("readbytes:" + readbytes);
-                return "Can not read the length.";
-            }
-            int oleLength = (pLength[0][0] << 0) + (pLength[0][1] << 8) + (pLength[0][2] << 16) + (pLength[0][3] << 24);
-            byte pContents[][] = new byte[1][oleLength];
-            //Read all bytes. The compressed length should less then the uncompressed length
-            readbytes = xSubStream.readBytes(pContents, oleLength);
-            if (oleLength < readbytes) {
-                return "oleLength :" + oleLength + " readbytes: " + readbytes;
-            }
-
-            // Decompress the bytes
-            Inflater decompresser = new Inflater();
-            decompresser.setInput(pContents[0], 0, readbytes);
-            byte[] result = new byte[oleLength];
-            int resultLength = decompresser.inflate(result);
-            decompresser.end();
-
-            //return the base64 string of the uncompressed data
-            return Base64.encodeBytes(result);
-        } catch (Exception ex) {
-            ex.printStackTrace();
-        }
-        return "";
-    }
-
-    public XStream CreateTempFileStream(XMultiServiceFactory xMSF) {
-        // try to get temporary file representation
-        XStream xTempFileStream = null;
-        try {
-            Object oTempFile = xMSF.createInstance("com.sun.star.io.TempFile");
-            xTempFileStream = (XStream) UnoRuntime.queryInterface(XStream.class, oTempFile);
-        } catch (Exception e) {
-        }
-
-        if (xTempFileStream == null) {
-            System.out.println("Can't create temporary file!");
-        }
-
-        return xTempFileStream;
-    }
-    //decode the base64 string and create an com.sun.star.embed.OLESimpleStorage from it
-    public void loadRootStorageFromBase64(String aBase64) {
-        try {
-            //Decode and write the data to an temp stream
-            byte[] oledata = Base64.decode(aBase64);
-            m_RootStream = CreateTempFileStream(m_xMSF);
-            XOutputStream xOutput = m_RootStream.getOutputStream();
-            xOutput.writeBytes(oledata);
-            xOutput.flush();
-            //Get the input stream and seek to begin
-            XInputStream xInput = m_RootStream.getInputStream();
-            XSeekable xSeek = (XSeekable) UnoRuntime.queryInterface(XSeekable.class, xInput);
-            xSeek.seek(0);
-            oledata = null;
-            xSeek = null;
-
-            //create an com.sun.star.embed.OLESimpleStorage from the temp stream
-            Object pArgs[] = new Object[1];
-            pArgs[0] = (Object) xInput;
-            Object oTempStorage = m_xMSF.createInstanceWithArguments("com.sun.star.embed.OLESimpleStorage", pArgs);
-            pArgs = null;
-
-            m_Storage = (XNameContainer) UnoRuntime.queryInterface(XNameContainer.class, oTempStorage);
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-    //Create a empty OLESimpleStorage if there is not one
-    public void ensureCreateRootStorage() {
-        if (null == m_RootStream || null == m_Storage) {
-            try {
-                m_RootStream = CreateTempFileStream(m_xMSF);
-
-                Object pArgs[] = new Object[1];
-                pArgs[0] = (Object) m_RootStream;
-                Object oTempStorage = m_xMSF.createInstanceWithArguments("com.sun.star.embed.OLESimpleStorage", pArgs);
-                pArgs = null;
-
-                m_Storage = (XNameContainer) UnoRuntime.queryInterface(XNameContainer.class, oTempStorage);
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-        }
-    }
-    //decode the base64 string and insert the length and the compressed data of it to
-    //the root storage as a sub stream under aName
-    public void insertSubStorage(String aName, String aBase64) {
-        try {
-            //decode the base64 string
-            byte[] oledata = Base64.decode(aBase64);
-            //create a temp stream to write data to
-            XStream subStream = CreateTempFileStream(m_xMSF);
-            XInputStream xInput = subStream.getInputStream();
-            XOutputStream xOutput = subStream.getOutputStream();
-            //write the length to the temp stream
-            byte oleHead[] = new byte[4];
-            oleHead[0] = (byte) ((oledata.length >>> 0) & 0xFF);
-            oleHead[1] = (byte) ((oledata.length >>> 8) & 0xFF);
-            oleHead[2] = (byte) ((oledata.length >>> 16) & 0xFF);
-            oleHead[3] = (byte) ((oledata.length >>> 24) & 0xFF);
-            xOutput.writeBytes(oleHead);
-
-            // Compress the bytes
-            byte[] output = new byte[oledata.length];
-            Deflater compresser = new Deflater();
-            compresser.setInput(oledata);
-            compresser.finish();
-            int compressedDataLength = compresser.deflate(output);
-            //realloc the data length
-            byte[] compressedBytes = new byte[compressedDataLength];
-            for (int i = 0; i < compressedDataLength; i++) {
-                compressedBytes[i] = output[i];
-            }
-
-            //write the compressed data to the temp stream
-            xOutput.writeBytes(compressedBytes);
-            //seek to 0
-            XSeekable xSeek = (XSeekable) UnoRuntime.queryInterface(XSeekable.class, xInput);
-            xSeek.seek(0);
-            xSeek = null;
-            oledata = null;
-
-            //insert the temp stream as a sub stream and use an XTransactedObject to commit it immediately
-            XTransactedObject xTransact = (XTransactedObject) UnoRuntime.queryInterface(XTransactedObject.class, m_Storage);
-            m_Storage.insertByName(aName, xInput);
-            xTransact.commit();
-            xTransact = null;
-
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-
-    /** separtates the uno-url into 3 different parts.
-     */
-    protected static String[] parseUnoUrl(String url) {
-        String[] aRet = new String[3];
-
-        if (!url.startsWith("uno:")) {
-            return null;
-        }
-
-        int semicolon = url.indexOf(';');
-        if (semicolon == -1) {
-            return null;
-        }
-
-        aRet[0] = url.substring(4, semicolon);
-        int nextSemicolon = url.indexOf(';', semicolon + 1);
-
-        if (semicolon == -1) {
-            return null;
-        }
-        aRet[1] = url.substring(semicolon + 1, nextSemicolon);
-
-        aRet[2] = url.substring(nextSemicolon + 1);
-        return aRet;
-    }
-    //connect to running OOo and keep an XConnection object so that we can disconnect from OOo as we wish
-    protected XMultiServiceFactory connectAwareGetServiceFactory() throws com.sun.star.uno.Exception,
-            com.sun.star.uno.RuntimeException,
-            Exception {
-
-        // Get component context
-        XComponentContext xComponentContext =
-                com.sun.star.comp.helper.Bootstrap.createInitialComponentContext(null);
-
-        // instantiate connector service
-        Object x = xComponentContext.getServiceManager().createInstanceWithContext(
-                "com.sun.star.connection.Connector", xComponentContext);
-
-        XConnector xConnector = (XConnector) UnoRuntime.queryInterface(XConnector.class, x);
-
-        String a[] = parseUnoUrl(sConnectionString);
-        if (null == a) {
-            throw new com.sun.star.uno.Exception("Couldn't parse uno-url " + sConnectionString);
-        }
-
-        // connect using the connection string part of the uno-url only.
-        m_Connection = xConnector.connect(a[0]);
-
-        x = xComponentContext.getServiceManager().createInstanceWithContext(
-                "com.sun.star.bridge.BridgeFactory", xComponentContext);
-
-        XBridgeFactory xBridgeFactory = (XBridgeFactory) UnoRuntime.queryInterface(
-                XBridgeFactory.class, x);
-
-        // create a nameless bridge with no instance provider
-        // using the middle part of the uno-url
-        XBridge bridge = xBridgeFactory.createBridge("", a[1], m_Connection, null);
-
-        // query for the XComponent interface and add this as event listener
-        XComponent xComponent = (XComponent) UnoRuntime.queryInterface(
-                XComponent.class, bridge);
-
-        // get the remote instance
-        x = bridge.getInstance(a[2]);
-
-        // Did the remote server export this object ?
-        if (null == x) {
-            throw new com.sun.star.uno.Exception(
-                    "Server didn't provide an instance for" + a[2], null);
-        }
-
-        XMultiServiceFactory xFac = (XMultiServiceFactory) UnoRuntime.queryInterface(XMultiServiceFactory.class, x);
-        return xFac;
-    }
-    protected static boolean DEBUG = false;
-    protected static boolean DEBUGCHK = false;
-    protected static String debugfile;
-
-    protected static void debugln(String s) {
-        debug(s + "\n");
-    }
-
-    protected static void debug(String s) {
-        if (!DEBUGCHK) {
-            if (System.getProperty("xsltfilter.debug") == null) {
-                DEBUGCHK = true;
-                return;
-            } else {
-                debugfile = System.getProperty("xsltfilter.debug");
-                DEBUG = true;
-            }
-        }
-        if (!DEBUG) {
-            return;
-        }
-        try {
-            FileWriter dbgwriter = new FileWriter(debugfile, true);
-            dbgwriter.write(s);
-            dbgwriter.close();
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-}
diff --git a/filter/source/xsltfilter/com/sun/star/comp/xsltfilter/XSLTransformer.java b/filter/source/xsltfilter/com/sun/star/comp/xsltfilter/XSLTransformer.java
deleted file mode 100644
index 7036646..0000000
--- a/filter/source/xsltfilter/com/sun/star/comp/xsltfilter/XSLTransformer.java
+++ /dev/null
@@ -1,506 +0,0 @@
-package com.sun.star.comp.xsltfilter;
-
-/************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * Copyright 2000, 2010 Oracle and/or its affiliates.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-//Standard Java classes
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.InputStream;
-import java.io.PrintStream;
-import java.io.StringReader;
-import java.net.URL;
-import java.net.URLConnection;
-import java.util.Enumeration;
-import java.util.Hashtable;
-import java.util.Vector;
-
-// Imported TraX classes
-import javax.xml.parsers.SAXParserFactory;
-import javax.xml.transform.Source;
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.URIResolver;
-import javax.xml.transform.sax.SAXSource;
-import javax.xml.transform.stream.StreamResult;
-import javax.xml.transform.stream.StreamSource;
-import org.xml.sax.EntityResolver;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
-
-//StarOffice Interfaces and UNO
-import com.sun.star.beans.NamedValue;
-import com.sun.star.comp.loader.FactoryHelper;
-import com.sun.star.io.XActiveDataControl;
-import com.sun.star.io.XActiveDataSink;
-import com.sun.star.io.XActiveDataSource;
-import com.sun.star.io.XInputStream;
-import com.sun.star.io.XOutputStream;
-import com.sun.star.io.XSeekable;
-import com.sun.star.io.XStreamListener;
-import com.sun.star.lang.XInitialization;
-import com.sun.star.lang.XMultiServiceFactory;
-import com.sun.star.lang.XServiceInfo;
-import com.sun.star.lang.XServiceName;
-import com.sun.star.lang.XSingleServiceFactory;
-import com.sun.star.lang.XTypeProvider;
-import com.sun.star.registry.XRegistryKey;
-import com.sun.star.uno.AnyConverter;
-import com.sun.star.uno.Type;
-import com.sun.star.uno.UnoRuntime;
-import com.sun.star.xml.xslt.XXSLTTransformer;
-
-//Uno to java Adaptor
-import com.sun.star.lib.uno.adapter.XInputStreamToInputStreamAdapter;
-import com.sun.star.lib.uno.adapter.XOutputStreamToOutputStreamAdapter;
-import javax.xml.transform.Templates;
-
-import net.sf.saxon.FeatureKeys;
-
-/** This outer class provides an inner class to implement the service
- * description and a method to instantiate the
- * component on demand (__getServiceFactory()).
- */
-public class XSLTransformer
-        implements XTypeProvider, XServiceName, XServiceInfo, XXSLTTransformer,
-        URIResolver, EntityResolver {
-
-    /**
-     * This component provides java based XSL transformations
-     * A SAX based interface is not feasible when crossing language bordes
-     * since too much time would be wasted by bridging the events between environments
-     * example: 190 pages document, 82000 events 8seconds transform 40(!) sec. bridging
-     *
-     */
-    private XInputStream m_xis;
-    private XOutputStream m_xos;    // private static HashMap templatecache;
-    private static final String STATSPROP = "XSLTransformer.statsfile";
-    private static PrintStream statsp;
-    private String stylesheeturl;
-    private String targeturl;
-    private String targetbaseurl;
-    private String sourceurl;
-    private String sourcebaseurl;
-    private String pubtype = new String();
-    private String systype = new String();    // processing thread
-    private Thread t;    // listeners
-    private Vector listeners = new Vector();    //
-    private XMultiServiceFactory svcfactory;    // cache for transformations by stylesheet
-    private static Hashtable xsltReferences = new Hashtable();
-    // struct for cached stylesheets
-    private static class Transformation {
-
-        public Templates cachedXSLT;
-        public long lastmod;
-    }
-    // Resolve URIs to an empty source
-    public Source resolve(String href, String base) {
-        return new StreamSource(new StringReader(""));
-    }
-
-    public InputSource resolveEntity(String publicId, String systemId) throws SAXException, java.io.IOException {
-        return new InputSource(new StringReader(""));
-    }
-    // --- Initialization ---
-    public XSLTransformer(XMultiServiceFactory msf) {
-        svcfactory = msf;
-    }
-
-    public void initialize(Object[] args) throws com.sun.star.uno.Exception {
-        // some configurable debugging
-        String statsfilepath = null;
-        if ((statsfilepath = System.getProperty(STATSPROP)) != null) {
-            try {
-                File statsfile = new File(statsfilepath);
-                statsp = new PrintStream(new FileOutputStream(statsfile.getPath(), false));
-            } catch (java.lang.Exception e) {
-                System.err.println("XSLTransformer: could not open statsfile'" + statsfilepath + "'");
-                System.err.println("   " + e.getClass().getName() + ": " + e.getMessage());
-                System.err.println("   output disabled");
-            }
-        }
-
-        Object[] values = (Object[]) args[0];
-
-        // reading the values
-        NamedValue nv = null;
-        debug("The transformation's parameters as 'name = value' pairs:\n");
-
-        for (int i = 0; i < values.length; i++) {
-            nv = (NamedValue) AnyConverter.toObject(new Type(NamedValue.class), values[i]);
-
-            if (nv.Name != null && !nv.Name.equals("")) {
-                debug(nv.Name + " = " + nv.Value);
-            }
-
-            if (nv.Name.equals("StylesheetURL")) {
-                stylesheeturl = (String) AnyConverter.toObject(
-                        new Type(String.class), nv.Value);
-            } else if (nv.Name.equals("SourceURL")) {
-                sourceurl = (String) AnyConverter.toObject(
-                        new Type(String.class), nv.Value);
-            } else if (nv.Name.equals("TargetURL")) {
-                targeturl = (String) AnyConverter.toObject(
-                        new Type(String.class), nv.Value);
-            } else if (nv.Name.equals("SourceBaseURL")) {
-                sourcebaseurl = (String) AnyConverter.toObject(
-                        new Type(String.class), nv.Value);
-            } else if (nv.Name.equals("TargetBaseURL")) {
-                targetbaseurl = (String) AnyConverter.toObject(
-                        new Type(String.class), nv.Value);
-            } else if (nv.Name.equals("SystemType")) {
-                systype = (String) AnyConverter.toObject(
-                        new Type(String.class), nv.Value);
-            } else if (nv.Name.equals("PublicType")) {
-                pubtype = (String) AnyConverter.toObject(
-                        new Type(String.class), nv.Value);
-            }
-        }
-    }
-
-    // --- XActiveDataSink        xistream = aStream;
-    public void setInputStream(XInputStream aStream) {
-        m_xis = aStream;
-    }
-
-    public com.sun.star.io.XInputStream getInputStream() {
-        return m_xis;
-    }
-
-    // --- XActiveDataSource
-    public void setOutputStream(XOutputStream aStream) {
-        m_xos = aStream;
-    }
-
-    public com.sun.star.io.XOutputStream getOutputStream() {
-        return m_xos;
-    }
-
-    // --- XActiveDataControl
-    public void addListener(XStreamListener aListener) {
-        if (aListener != null && !listeners.contains(aListener)) {
-            listeners.add(aListener);
-        }
-    }
-
-    public void removeListener(XStreamListener aListener) {
-        if (aListener != null) {
-            listeners.removeElement(aListener);
-        }
-
-    }
-
-    public void start() {
-        // notify listeners
-        t = new Thread() {
-
-            @Override
-            public void run() {
-
-                // Local variabes used outside try block in finally block
-                InputStream is = null;
-                Source source = null;
-                BufferedOutputStream os = null;
-                PrintStream origOut = System.out;
-                PrintStream origErr = System.err;
-                if (statsp != null) {
-                    System.setErr(statsp);
-                    System.setOut(statsp);
-                }
-                try {
-                    debug("\n\nStarting transformation...");
-
-                    // Set up context class loader for SAXParserFactory and
-                    // TransformerFactory calls below:
-                    setContextClassLoader(this.getClass().getClassLoader());
-
-                    for (Enumeration e = listeners.elements(); e.hasMoreElements();) {
-                        XStreamListener l = (XStreamListener) e.nextElement();
-                        l.started();
-                    }
-
-                    XSeekable xseek = (XSeekable) UnoRuntime.queryInterface(XSeekable.class, m_xis);
-                    if (xseek != null) {
-                        xseek.seek(0);
-                    }
-
-                    is = new BufferedInputStream(
-                            new XInputStreamToInputStreamAdapter(m_xis));
-                    //Source xmlsource = new StreamSource(xmlinput);
-                    SAXParserFactory spf = SAXParserFactory.newInstance();
-                    spf.setValidating(false);
-                    spf.setNamespaceAware(true);
-                    XMLReader xmlReader = spf.newSAXParser().getXMLReader();
-                    xmlReader.setEntityResolver(XSLTransformer.this);
-                    source = new SAXSource(xmlReader, new InputSource(is));
-
-                    // in order to help performance and to remedy a a possible memory
-                    // leak in xalan, where it seems, that Transformer instances cannot
-                    // be reclaimed though they are no longer referenced here, we use
-                    // a cache of weak references (ie. xsltReferences) created for specific
-                    // style sheet URLs see also #i48384#
-
-                    Templates xsltTemplate = null;
-                    Transformer transformer = null;
-                    Transformation transformation = null;
-                    // File stylefile = new File(new URI(stylesheeturl));
-                    long lastmod = 0;
-                    try {
-                        URL uStyle = new URL(stylesheeturl);
-                        URLConnection c = uStyle.openConnection();
-                        lastmod = c.getLastModified();
-                    } catch (java.lang.Exception ex) {
-                        // lastmod will remain at 0;
-                        if (statsp != null) {
-                            statsp.println(ex.getClass().getName() + ": " + ex.getMessage());
-                            ex.printStackTrace(statsp);
-                        }
-                    }
-
-                    synchronized (xsltReferences) {
-                        java.lang.ref.WeakReference ref = null;
-                        // try to get the xsltTemplate reference from the cache
-                        if ((ref = (java.lang.ref.WeakReference) xsltReferences.get(stylesheeturl)) == null ||
-                                (transformation = ((Transformation) ref.get())) == null ||
-                                ((Transformation) ref.get()).lastmod < lastmod) {
-                            // we cannot find a valid reference for this stylesheet
-                            // or the stylsheet was updated
-                            if (ref != null) {
-                                xsltReferences.remove(stylesheeturl);
-                            }
-                            // create new xsltTemplate for this stylesheet
-                            TransformerFactory tfactory = TransformerFactory.newInstance();
-                            debug("TransformerFactory is '" + tfactory.getClass().getName() + "'");
-                // some external saxons (Debian, Ubuntu, ...) have this disabled
-                // per default
-                tfactory.setAttribute(FeatureKeys.ALLOW_EXTERNAL_FUNCTIONS, new Boolean(true));
-                            xsltTemplate = tfactory.newTemplates(new StreamSource(stylesheeturl));
-
-                            // store the transformation into the cache
-                            transformation = new Transformation();
-                            transformation.lastmod = lastmod;
-                            transformation.cachedXSLT = xsltTemplate;
-                            ref = new java.lang.ref.WeakReference(transformation);
-                            xsltReferences.put(stylesheeturl, ref);
-                        }
-                    }
-                    xsltTemplate = transformation.cachedXSLT;
-                            transformer = xsltTemplate.newTransformer();
-                            transformer.setOutputProperty("encoding", "UTF-8");
-                            // transformer.setURIResolver(XSLTransformer.this);
-
-                    // invalid to set 'null' as parameter as 'null' is not a valid Java object
-                    if (sourceurl != null) {
-                        transformer.setParameter("sourceURL", sourceurl);
-                    }
-                    if (sourcebaseurl != null) {
-                        transformer.setParameter("sourceBaseURL", sourcebaseurl);
-                    }
-                    if (targeturl != null) {
-                        transformer.setParameter("targetURL", targeturl);
-                    }
-                    if (targetbaseurl != null) {
-                        transformer.setParameter("targetBaseURL", targetbaseurl);
-                    }
-                    if (pubtype != null) {
-                        transformer.setParameter("publicType", pubtype);
-                    }
-                    if (systype != null) {
-                        transformer.setParameter("systemType", systype);
-                    }
-                    if (svcfactory != null) {
-                        transformer.setParameter("XMultiServiceFactory", svcfactory);
-                    }
-                    os = new BufferedOutputStream(
-                            new XOutputStreamToOutputStreamAdapter(m_xos));
-                    StreamResult sr = new StreamResult(os);
-                    long tstart = System.currentTimeMillis();
-                    transformer.transform(source, sr);
-                    debug("finished transformation in " + (System.currentTimeMillis() - tstart) + "ms");
-
-                } catch (java.lang.Throwable ex) {
-                    // notify any listeners about close
-                    for (Enumeration e = listeners.elements(); e.hasMoreElements();) {
-
-                        XStreamListener l = (XStreamListener) e.nextElement();
-                        l.error(new com.sun.star.uno.Exception(ex.getClass().getName() + ": " + ex.getMessage()));
-                    }
-                    if (statsp != null) {
-                        statsp.println(ex.getClass().getName() + ": " + ex.getMessage());
-                        ex.printStackTrace(statsp);
-                    }
-                } finally {
-                    // dereference input buffer
-                    source = null;
-                    try {
-                        if (is != null) {
-                            is.close();
-                        }
-                    } catch (java.lang.Throwable ex) {
-                        if (statsp != null) {
-                            statsp.println(ex.getClass().getName() + ": " + ex.getMessage());
-                            ex.printStackTrace(statsp);
-                        }
-                    }
-                    try {
-                        if (os != null) {
-                            os.close();
-                        }
-                    } catch (java.lang.Throwable ex) {
-                        if (statsp != null) {
-                            statsp.println(ex.getClass().getName() + ": " + ex.getMessage());
-                            ex.printStackTrace(statsp);
-                        }
-                    }
-                    try {
-                        if (m_xis != null) {
-                            m_xis.closeInput();
-                        }
-                    } catch (java.lang.Throwable ex) {
-                        if (statsp != null) {
-                            statsp.println(ex.getClass().getName() + ": " + ex.getMessage());
-                            ex.printStackTrace(statsp);
-                        }
-                    }
-                    try {
-                        if (m_xos != null) {
-                            m_xos.closeOutput();
-                        }
-                    } catch (java.lang.Throwable ex) {
-                        if (statsp != null) {
-                            statsp.println(ex.getClass().getName() + ": " + ex.getMessage());
-                            ex.printStackTrace(statsp);
-                        }
-                    }
-
-                    // resetting standard input/error streams from logfile to default
-                    if (statsp != null) {
-                        System.setErr(origErr);
-                        System.setOut(origOut);
-                    }
-                    // try to release references asap...
-                    m_xos = null;
-                    m_xis = null;
-                    is = null;
-                    os = null;
-                    // notify any listeners about close
-                    if (listeners != null) {
-                        for (Enumeration e = listeners.elements(); e.hasMoreElements();) {
-                            XStreamListener l = (XStreamListener) e.nextElement();
-                            l.closed();
-                        }
-                    }
-                }
-            }
-        };
-        t.start();
-    } /* a statsfile have to be created as precondition to use this function */
-
-
-    private static final void debug(String s) {
-        if (statsp != null) {
-            statsp.println(s);
-        }
-    }
-
-    public void terminate() {
-        try {
-            debug("terminate called");
-            if (t.isAlive()) {
-                t.interrupt();
-                for (Enumeration e = listeners.elements(); e.hasMoreElements();) {
-                    XStreamListener l = (XStreamListener) e.nextElement();
-                    l.terminated();
-                }
-            }
-        } catch (java.lang.Exception ex) {
-            if (statsp != null) {
-                statsp.println(ex.getClass().getName() + ": " + ex.getMessage());
-                ex.printStackTrace(statsp);
-            }
-        }
-    }    // --- component management interfaces... ---
-    private final static String _serviceName = "com.sun.star.xml.xslt.XSLT2Transformer";
-
-    // Implement methods from interface XTypeProvider
-    public byte[] getImplementationId() {
-        byte[] byteReturn = {};
-        byteReturn = new String("" + this.hashCode()).getBytes();
-        return (byteReturn);
-    }
-
-    public com.sun.star.uno.Type[] getTypes() {
-        Type[] typeReturn = {};
-        try {
-            typeReturn = new Type[]{
-                        new Type(XTypeProvider.class),
-                        new Type(XServiceName.class),
-                        new Type(XServiceInfo.class),
-                        new Type(XActiveDataSource.class),
-                        new Type(XActiveDataSink.class),
-                        new Type(XActiveDataControl.class),
-                        new Type(XInitialization.class)
-                    };
-        } catch (java.lang.Exception exception) {
-        }
-
-        return (typeReturn);
-    }
-
-    // --- Implement method from interface XServiceName ---
-    public String getServiceName() {
-        return (_serviceName);
-    }
-
-    // --- Implement methods from interface XServiceInfo ---
-    public boolean supportsService(String stringServiceName) {
-        return (stringServiceName.equals(_serviceName));
-    }
-
-    public String getImplementationName() {
-        return (XSLTransformer.class.getName());
-    }
-
-    public String[] getSupportedServiceNames() {
-        String[] stringSupportedServiceNames = {_serviceName};
-        return stringSupportedServiceNames;
-    }
-
-    // --- component registration methods ---
-    public static XSingleServiceFactory __getServiceFactory(
-            String implName, XMultiServiceFactory multiFactory, XRegistryKey regKey) {
-        XSingleServiceFactory xSingleServiceFactory = null;
-        if (implName.equals(XSLTransformer.class.getName())) {
-            xSingleServiceFactory = FactoryHelper.getServiceFactory(XSLTransformer.class,
-                    _serviceName, multiFactory, regKey);
-        }
-        return xSingleServiceFactory;
-    }
-}
diff --git a/filter/source/xsltfilter/components.rdb b/filter/source/xsltfilter/components.rdb
deleted file mode 100644
index 6014b82..0000000
--- a/filter/source/xsltfilter/components.rdb
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0"?>
-<components xmlns="http://openoffice.org/2010/uno-components">
-    <component loader="com.sun.star.loader.Java2" uri="./XSLTFilter.jar">
-        <implementation name="com.sun.star.comp.xsltfilter.XSLTransformer">
-            <service name="com.sun.star.xml.xslt.XSLT2Transformer"/>
-        </implementation>
-    </component>
-</components>
diff --git a/filter/source/xsltfilter/description-en-US.txt b/filter/source/xsltfilter/description-en-US.txt
deleted file mode 100644
index 88c8abf..0000000
--- a/filter/source/xsltfilter/description-en-US.txt
+++ /dev/null
@@ -1 +0,0 @@
-The xslt2-transformer implements a transformer for XSLT import/export filters with support for XSLT 2.0.
diff --git a/filter/source/xsltfilter/description.xml b/filter/source/xsltfilter/description.xml
deleted file mode 100644
index ae6abcb..0000000
--- a/filter/source/xsltfilter/description.xml
+++ /dev/null
@@ -1,28 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<description
-
-    xmlns="http://openoffice.org/extensions/description/2006"
-    xmlns:dep="http://libreoffice.org/extensions/description/2011"
-    xmlns:xlink="http://www.w3.org/1999/xlink">
-
-    <identifier value="org.libreoffice.JavaXSLT2Transformer"/>
-
-    <dependencies>
-        <dep:LibreOffice-minimal-version value="3.7"/>
-    </dependencies>
-
-    <version value="1.0.0"/>
-
-    <publisher>
-        <name xlink:href="http://www.documentfoundation.org" lang="en-US">The Document Foundation</name>
-    </publisher>
-
-    <display-name>
-        <name lang="en-US">XSLT 2.0 transformer</name>
-    </display-name>
-
-    <extension-description>
-      <src xlink:href="description-en-US.txt" lang="en-US" />
-    </extension-description>
-
-</description>
diff --git a/filter/source/xsltfilter/manifest.xml b/filter/source/xsltfilter/manifest.xml
deleted file mode 100644
index a443e65..0000000
--- a/filter/source/xsltfilter/manifest.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE manifest:manifest PUBLIC "-//OpenOffice.org//DTD Manifest 1.0//EN" "Manifest.dtd">
-<manifest:manifest xmlns:manifest="http://openoffice.org/2001/manifest">
-  <manifest:file-entry manifest:media-type="application/vnd.sun.star.uno-components"
-                       manifest:full-path="components.rdb"/>
-</manifest:manifest>
-- 
1.7.11.7

