From 67d1d0061c1cf5bb8aba0de75776435150c8559e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Caol=C3=A1n=20McNamara?= <caolanm@redhat.com>
Date: Tue, 23 Feb 2016 14:42:29 +0000
Subject: [PATCH 3/8] gtk3: vcl popups flush any unexecuted Select events on
 popdown

so if the gtksalmenu integration wants to drive popups by setting a selection
on the vcl popup, then the same flush is needed after ShowNativePopupMenu

(cherry picked from commit 3cb62eacae001df546c2a8f39ae4d37c33791d0b)

Change-Id: I59be60de5742d1e382cabefcbf0d8cdd5fc30b00
---
 include/vcl/menu.hxx       |  1 +
 vcl/source/window/menu.cxx | 24 +++++++++++++++---------
 2 files changed, 16 insertions(+), 9 deletions(-)

diff --git a/include/vcl/menu.hxx b/include/vcl/menu.hxx
index 1dbd85e..f10141b 100644
--- a/include/vcl/menu.hxx
+++ b/include/vcl/menu.hxx
@@ -515,6 +515,7 @@ private:
 
 protected:
     SAL_DLLPRIVATE sal_uInt16 ImplExecute( vcl::Window* pWindow, const Rectangle& rRect, FloatWinPopupFlags nPopupFlags, Menu* pStaredFrom, bool bPreSelectFirst );
+    SAL_DLLPRIVATE void ImplFlushPendingSelect();
     SAL_DLLPRIVATE long ImplCalcHeight( sal_uInt16 nEntries ) const;
     SAL_DLLPRIVATE sal_uInt16 ImplCalcVisEntries( long nMaxHeight, sal_uInt16 nStartEntry = 0, sal_uInt16* pLastVisible = nullptr ) const;
 
diff --git a/vcl/source/window/menu.cxx b/vcl/source/window/menu.cxx
index 999085e..b753fac 100644
--- a/vcl/source/window/menu.cxx
+++ b/vcl/source/window/menu.cxx
@@ -2933,6 +2933,19 @@ sal_uInt16 PopupMenu::Execute( vcl::Window* pExecWindow, const Rectangle& rRect,
     return ImplExecute( pExecWindow, rRect, nPopupModeFlags, nullptr, false );
 }
 
+void PopupMenu::ImplFlushPendingSelect()
+{
+    // is there still Select?
+    Menu* pSelect = ImplFindSelectMenu();
+    if (pSelect)
+    {
+        // Select should be called prior to leaving execute in a popup menu!
+        Application::RemoveUserEvent( pSelect->nEventId );
+        pSelect->nEventId = nullptr;
+        pSelect->Select();
+    }
+}
+
 sal_uInt16 PopupMenu::ImplExecute( vcl::Window* pW, const Rectangle& rRect, FloatWinPopupFlags nPopupModeFlags, Menu* pSFrom, bool bPreSelectFirst )
 {
     if ( !pSFrom && ( PopupMenu::IsInExecute() || !GetItemCount() ) )
@@ -3097,6 +3110,7 @@ sal_uInt16 PopupMenu::ImplExecute( vcl::Window* pW, const Rectangle& rRect, Floa
         SalMenu* pMenu = ImplGetSalMenu();
         if( pMenu && bRealExecute && pMenu->ShowNativePopupMenu( pWin, aRect, nPopupModeFlags | FloatWinPopupFlags::GrabFocus ) )
         {
+            ImplFlushPendingSelect();
             pWin->StopExecute();
             pWin->doShutdown();
             pWindow->doLazyDelete();
@@ -3180,15 +3194,7 @@ sal_uInt16 PopupMenu::ImplExecute( vcl::Window* pW, const Rectangle& rRect, Floa
         pWindow->doLazyDelete();
         pWindow = nullptr;
 
-        // is there still Select?
-        Menu* pSelect = ImplFindSelectMenu();
-        if ( pSelect )
-        {
-            // Select should be called prior to leaving execute in a popup menu!
-            Application::RemoveUserEvent( pSelect->nEventId );
-            pSelect->nEventId = nullptr;
-            pSelect->Select();
-        }
+        ImplFlushPendingSelect();
     }
 
     return bRealExecute ? nSelectedId : 0;
-- 
2.7.1

