From 3902c13d2cfcf903c8475fb9f72bccf6f604d2f5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Caol=C3=A1n=20McNamara?= <caolanm@redhat.com>
Date: Sun, 20 Dec 2015 10:57:12 +0200
Subject: [PATCH 5/5] gtk3+wayland: play video via gtksink gstreamer element

(cherry picked from commit 8543fbc72fafc0d71a8760752ca2ef5b7119cb5c)

Change-Id: Ib371fa06eda73962cbe94739e69a68b46c26e4bf
---
 avmedia/Library_avmediagst.mk          |  16 ++-
 avmedia/source/gstreamer/gstplayer.cxx | 226 ++++++++++++++++++---------------
 avmedia/source/gstreamer/gstplayer.hxx |   8 ++
 include/vcl/sysdata.hxx                |   2 +
 vcl/unx/gtk/gtkobject.cxx              |   1 +
 vcl/unx/gtk/gtksalframe.cxx            |   1 +
 vcl/unx/gtk3/gtk3gtkframe.cxx          |   1 +
 vcl/unx/gtk3/gtk3gtkobject.cxx         |   7 +-
 8 files changed, 157 insertions(+), 105 deletions(-)

diff --git a/avmedia/Library_avmediagst.mk b/avmedia/Library_avmediagst.mk
index a20a32b..35a56ac 100644
--- a/avmedia/Library_avmediagst.mk
+++ b/avmedia/Library_avmediagst.mk
@@ -16,7 +16,21 @@ $(eval $(call gb_Library_set_include,avmediagst,\
 	-I$(SRCDIR)/avmedia/source/inc \
 	$(GSTREAMER_1_0_CFLAGS) \
 ))
-$(eval $(call gb_Library_add_libs,avmediagst,$(GSTREAMER_1_0_LIBS)))
+
+$(eval $(call gb_Library_add_libs,avmediagst,\
+    $(GSTREAMER_1_0_LIBS) \
+))
+
+ifneq ($(ENABLE_GTK3),)
+$(eval $(call gb_Library_add_cxxflags,avmediagst,\
+    $$(GTK3_CFLAGS) \
+    -DENABLE_GTKSINK \
+))
+
+$(eval $(call gb_Library_add_libs,avmediagst,\
+    $(GTK3_LIBS) \
+))
+endif
 
 $(eval $(call gb_Library_use_external,avmediagst,boost_headers))
 
diff --git a/avmedia/source/gstreamer/gstplayer.cxx b/avmedia/source/gstreamer/gstplayer.cxx
index 6dd0f5c..0a97c14 100644
--- a/avmedia/source/gstreamer/gstplayer.cxx
+++ b/avmedia/source/gstreamer/gstplayer.cxx
@@ -53,18 +53,11 @@
 #include <gst/pbutils/missing-plugins.h>
 #include <gst/pbutils/pbutils.h>
 
-#if !defined DBG
-# if OSL_DEBUG_LEVEL > 2
 #ifdef AVMEDIA_GST_0_10
 #  define AVVERSION "gst 0.10: "
 #else
 #  define AVVERSION "gst 1.0: "
 #endif
-#define DBG(...) do { fprintf (stderr, "%s", AVVERSION); fprintf (stderr, __VA_ARGS__); fprintf (stderr, "\n"); } while (0);
-# else
-#define DBG(...)
-# endif
-#endif
 
 using namespace ::com::sun::star;
 
@@ -289,6 +282,10 @@ Player::Player( const uno::Reference< lang::XMultiServiceFactory >& rxMgr ) :
     GstPlayer_BASE( m_aMutex ),
     mxMgr( rxMgr ),
     mpPlaybin( nullptr ),
+#if defined(ENABLE_GTKSINK)
+    mpGtkWidget( nullptr ),
+#endif
+    mbUseGtkSink( false ),
     mbFakeVideo (false ),
     mnUnmutedVolume( 0 ),
     mbPlayPending ( false ),
@@ -312,12 +309,12 @@ Player::Player( const uno::Reference< lang::XMultiServiceFactory >& rxMgr ) :
 
     mbInitialized = gst_init_check( &argc, &argv, &pError );
 
-    DBG( "%p Player::Player", this );
+    SAL_INFO( "avmedia.gstreamer", AVVERSION << this << " Player::Player" );
 
     if (pError != nullptr)
     {
         // TODO: throw an exception?
-        DBG( "%p Player::Player error '%s'", this, pError->message );
+        SAL_INFO( "avmedia.gstreamer", AVVERSION << this << " Player::Player error '" << pError->message << "'" );
         g_error_free (pError);
     }
 }
@@ -326,7 +323,7 @@ Player::Player( const uno::Reference< lang::XMultiServiceFactory >& rxMgr ) :
 
 Player::~Player()
 {
-    DBG( "%p Player::~Player", this );
+    SAL_INFO( "avmedia.gstreamer", AVVERSION << this << " Player::~Player" );
     if( mbInitialized )
         disposing();
 }
@@ -339,11 +336,19 @@ void SAL_CALL Player::disposing()
 
     stop();
 
-    DBG( "%p Player::disposing", this );
+    SAL_INFO( "avmedia.gstreamer", AVVERSION << this << " Player::disposing" );
 
     // Release the elements and pipeline
     if( mbInitialized )
     {
+#if defined(ENABLE_GTKSINK)
+        if (mpGtkWidget)
+        {
+            gtk_widget_destroy(mpGtkWidget);
+            mpGtkWidget = nullptr;
+        }
+#endif
+
         if( mpPlaybin )
         {
             gst_element_set_state( mpPlaybin, GST_STATE_NULL );
@@ -391,18 +396,20 @@ void Player::processMessage( GstMessage *message )
             start();
         break;
     case GST_MESSAGE_STATE_CHANGED:
-        if( message->src == GST_OBJECT( mpPlaybin ) ) {
+        if (message->src == GST_OBJECT(mpPlaybin))
+        {
             GstState newstate, pendingstate;
 
             gst_message_parse_state_changed (message, nullptr, &newstate, &pendingstate);
 
-            if( newstate == GST_STATE_PAUSED &&
-                pendingstate == GST_STATE_VOID_PENDING &&
-                mpXOverlay )
-                gst_video_overlay_expose( mpXOverlay );
+            if (!mbUseGtkSink && newstate == GST_STATE_PAUSED &&
+                pendingstate == GST_STATE_VOID_PENDING && mpXOverlay)
+            {
+                gst_video_overlay_expose(mpXOverlay);
+            }
 
-        if (mbPlayPending)
-            mbPlayPending = ((newstate == GST_STATE_READY) || (newstate == GST_STATE_PAUSED));
+            if (mbPlayPending)
+                mbPlayPending = ((newstate == GST_STATE_READY) || (newstate == GST_STATE_PAUSED));
         }
     default:
         break;
@@ -431,8 +438,6 @@ static gboolean wrap_element_query_duration (GstElement *element, GstFormat form
 
 GstBusSyncReply Player::processSyncMessage( GstMessage *message )
 {
-//    DBG( "%p processSyncMessage has handle: %s", this, GST_MESSAGE_TYPE_NAME( message ) );
-
 #if OSL_DEBUG_LEVEL > 0
     if ( GST_MESSAGE_TYPE( message ) == GST_MESSAGE_ERROR )
     {
@@ -441,29 +446,32 @@ GstBusSyncReply Player::processSyncMessage( GstMessage *message )
 
         gst_message_parse_error( message, &error, &error_debug );
         SAL_WARN(
-            "avmedia",
-            "gstreamer error: '" << error->message << "' debug: '"
+            "avmedia.gstreamer",
+            "error: '" << error->message << "' debug: '"
                 << error_debug << "'");
     }
 #endif
 
+    if (!mbUseGtkSink)
+    {
 #ifdef AVMEDIA_GST_0_10
-    if (message->structure &&
-        !strcmp( gst_structure_get_name( message->structure ), "prepare-xwindow-id" ) )
+        if (message->structure &&
+            !strcmp( gst_structure_get_name( message->structure ), "prepare-xwindow-id" ) )
 #else
-    if (gst_is_video_overlay_prepare_window_handle_message (message) )
+        if (gst_is_video_overlay_prepare_window_handle_message (message) )
 #endif
-    {
-        DBG( "%p processSyncMessage prepare window id: %s %d", this,
-             GST_MESSAGE_TYPE_NAME( message ), (int)mnWindowID );
-        if( mpXOverlay )
-            g_object_unref( G_OBJECT ( mpXOverlay ) );
-        g_object_set( GST_MESSAGE_SRC( message ), "force-aspect-ratio", FALSE, NULL );
-        mpXOverlay = GST_VIDEO_OVERLAY( GST_MESSAGE_SRC( message ) );
-        g_object_ref( G_OBJECT ( mpXOverlay ) );
-        if ( mnWindowID != 0 )
-            gst_video_overlay_set_window_handle( mpXOverlay, mnWindowID );
-        return GST_BUS_DROP;
+        {
+            SAL_INFO( "avmedia.gstreamer", AVVERSION << this << " processSyncMessage prepare window id: " <<
+                      GST_MESSAGE_TYPE_NAME( message ) << " " << (int)mnWindowID );
+            if( mpXOverlay )
+                g_object_unref( G_OBJECT ( mpXOverlay ) );
+            g_object_set( GST_MESSAGE_SRC( message ), "force-aspect-ratio", FALSE, nullptr );
+            mpXOverlay = GST_VIDEO_OVERLAY( GST_MESSAGE_SRC( message ) );
+            g_object_ref( G_OBJECT ( mpXOverlay ) );
+            if ( mnWindowID != 0 )
+                gst_video_overlay_set_window_handle( mpXOverlay, mnWindowID );
+            return GST_BUS_DROP;
+        }
     }
 
 #ifdef AVMEDIA_GST_0_10
@@ -473,12 +481,11 @@ GstBusSyncReply Player::processSyncMessage( GstMessage *message )
 
             gst_message_parse_state_changed (message, nullptr, &newstate, &pendingstate);
 
-            DBG( "%p state change received, new state %d pending %d", this,
-                 (int)newstate, (int)pendingstate );
+            SAL_INFO( "avmedia.gstreamer", AVVERSION << this << " state change received, new state " << (int)newState << " pending " << (int)pendingstate );
             if( newstate == GST_STATE_PAUSED &&
                 pendingstate == GST_STATE_VOID_PENDING ) {
 
-                DBG( "%p change to paused received", this );
+                SAL_INFO( "avmedia.gstreamer", AVVERSION << this << " change to paused received" );
 
                 if( mnDuration == 0) {
                     gint64 gst_duration = 0L;
@@ -489,7 +496,7 @@ GstBusSyncReply Player::processSyncMessage( GstMessage *message )
                 if( mnWidth == 0 ) {
                     GList *pStreamInfo = nullptr;
 
-                    g_object_get( G_OBJECT( mpPlaybin ), "stream-info", &pStreamInfo, NULL );
+                    g_object_get( G_OBJECT( mpPlaybin ), "stream-info", &pStreamInfo, nullptr );
 
                     for ( ; pStreamInfo != nullptr; pStreamInfo = pStreamInfo->next) {
                         GObject *pInfo = G_OBJECT( pStreamInfo->data );
@@ -498,7 +505,7 @@ GstBusSyncReply Player::processSyncMessage( GstMessage *message )
                             continue;
 
                         int nType;
-                        g_object_get( pInfo, "type", &nType, NULL );
+                        g_object_get( pInfo, "type", &nType, nullptr );
                         GEnumValue *pValue = g_enum_get_value( G_PARAM_SPEC_ENUM( g_object_class_find_property( G_OBJECT_GET_CLASS( pInfo ), "type" ) )->enum_class,
                                                                nType );
 
@@ -506,12 +513,12 @@ GstBusSyncReply Player::processSyncMessage( GstMessage *message )
                             GstStructure *pStructure;
                             GstPad *pPad;
 
-                            g_object_get( pInfo, "object", &pPad, NULL );
+                            g_object_get( pInfo, "object", &pPad, nullptr );
                             pStructure = gst_caps_get_structure( GST_PAD_CAPS( pPad ), 0 );
                             if( pStructure ) {
                                 gst_structure_get_int( pStructure, "width", &mnWidth );
                                 gst_structure_get_int( pStructure, "height", &mnHeight );
-                                DBG( "queried size: %d x %d", mnWidth, mnHeight );
+                                SAL_INFO( "avmedia.gstreamer", AVVERSION "queried size: " << mnWidth << "x" << mnHeight );
                             }
                             g_object_unref (pPad);
                         }
@@ -542,11 +549,11 @@ GstBusSyncReply Player::processSyncMessage( GstMessage *message )
                 if( gst_structure_get( gst_caps_get_structure( caps, 0 ),
                                        "width", G_TYPE_INT, &w,
                                        "height", G_TYPE_INT, &h,
-                                       NULL ) ) {
+                                       nullptr ) ) {
                     mnWidth = w;
                     mnHeight = h;
 
-                    DBG( "queried size: %d x %d", mnWidth, mnHeight );
+                    SAL_INFO( "avmedia.gstreamer", AVVERSION "queried size: " << mnWidth << "x" << mnHeight );
 
                     maSizeCondition.set();
                 }
@@ -562,7 +569,6 @@ GstBusSyncReply Player::processSyncMessage( GstMessage *message )
             maSizeCondition.set();
         }
     } else if( GST_MESSAGE_TYPE( message ) == GST_MESSAGE_ERROR ) {
-        DBG( "Error !\n" );
         if( mnWidth == 0 ) {
             // an error occurred, set condition so that OOo thread doesn't wait for us
             maSizeCondition.set();
@@ -574,41 +580,48 @@ GstBusSyncReply Player::processSyncMessage( GstMessage *message )
 
 void Player::preparePlaybin( const OUString& rURL, GstElement *pSink )
 {
-        GstBus *pBus;
+#if defined(ENABLE_GTKSINK)
+    if (mpGtkWidget)
+    {
+        gtk_widget_destroy(mpGtkWidget);
+        mpGtkWidget = nullptr;
+    }
+#endif
 
-        if( mpPlaybin != nullptr ) {
-            gst_element_set_state( mpPlaybin, GST_STATE_NULL );
-            mbPlayPending = false;
-            g_object_unref( mpPlaybin );
-        }
+    if (mpPlaybin != nullptr)
+    {
+        gst_element_set_state( mpPlaybin, GST_STATE_NULL );
+        mbPlayPending = false;
+        g_object_unref( mpPlaybin );
+    }
 
-        mpPlaybin = gst_element_factory_make( "playbin", nullptr );
-        if( pSink != nullptr ) // used for getting preferred size etc.
-        {
-            g_object_set( G_OBJECT( mpPlaybin ), "video-sink", pSink, NULL );
-            mbFakeVideo = true;
-        }
-        else
-            mbFakeVideo = false;
+    mpPlaybin = gst_element_factory_make( "playbin", nullptr );
+    if( pSink != nullptr ) // used for getting preferred size etc.
+    {
+        g_object_set( G_OBJECT( mpPlaybin ), "video-sink", pSink, nullptr );
+        mbFakeVideo = true;
+    }
+    else
+        mbFakeVideo = false;
 
-        OString ascURL = OUStringToOString( rURL, RTL_TEXTENCODING_UTF8 );
-        g_object_set( G_OBJECT( mpPlaybin ), "uri", ascURL.getStr() , NULL );
+    OString ascURL = OUStringToOString( rURL, RTL_TEXTENCODING_UTF8 );
+    g_object_set( G_OBJECT( mpPlaybin ), "uri", ascURL.getStr() , nullptr );
 
-        pBus = gst_element_get_bus( mpPlaybin );
-        if (mbWatchID)
-        {
-            g_source_remove(mnWatchID);
-            mbWatchID = false;
-        }
-        mnWatchID = gst_bus_add_watch( pBus, pipeline_bus_callback, this );
-        mbWatchID = true;
-        DBG( "%p set sync handler", this );
+    GstBus *pBus = gst_element_get_bus( mpPlaybin );
+    if (mbWatchID)
+    {
+        g_source_remove(mnWatchID);
+        mbWatchID = false;
+    }
+    mnWatchID = gst_bus_add_watch( pBus, pipeline_bus_callback, this );
+    mbWatchID = true;
+    SAL_INFO( "avmedia.gstreamer", AVVERSION << this << " set sync handler" );
 #ifdef AVMEDIA_GST_0_10
-        gst_bus_set_sync_handler( pBus, pipeline_bus_sync_handler, this );
+    gst_bus_set_sync_handler( pBus, pipeline_bus_sync_handler, this );
 #else
-        gst_bus_set_sync_handler( pBus, pipeline_bus_sync_handler, this, nullptr );
+    gst_bus_set_sync_handler( pBus, pipeline_bus_sync_handler, this, nullptr );
 #endif
-        g_object_unref( pBus );
+    g_object_unref( pBus );
 }
 
 bool Player::create( const OUString& rURL )
@@ -617,7 +630,7 @@ bool Player::create( const OUString& rURL )
 
     // create all the elements and link them
 
-    DBG("create player, URL: %s", OUStringToOString( rURL, RTL_TEXTENCODING_UTF8 ).getStr());
+    SAL_INFO( "avmedia.gstreamer", "create player, URL: '" << rURL << "'" );
 
     if( mbInitialized && !rURL.isEmpty() )
     {
@@ -665,7 +678,7 @@ void SAL_CALL Player::stop()
         gst_element_set_state( mpPlaybin, GST_STATE_PAUSED );
 
     mbPlayPending = false;
-    DBG( "stop %p", mpPlaybin );
+    SAL_INFO( "avmedia.gstreamer", AVVERSION "stop " << mpPlaybin );
 }
 
 
@@ -683,7 +696,7 @@ sal_Bool SAL_CALL Player::isPlaying()
         bRet = GST_STATE_PLAYING == GST_STATE( mpPlaybin );
     }
 
-    DBG( "isPlaying %d", bRet );
+    SAL_INFO( "avmedia.gstreamer", AVVERSION "isPlaying " << bRet );
 
     return bRet;
 }
@@ -723,7 +736,7 @@ void SAL_CALL Player::setMediaTime( double fTime )
         if( !isPlaying() )
             gst_element_set_state( mpPlaybin, GST_STATE_PAUSED );
 
-        DBG( "seek to: %" SAL_PRIdINT64 " ns original: %lf s", gst_position, fTime );
+        SAL_INFO( "avmedia.gstreamer", AVVERSION "seek to: " << gst_position << " ns original: " << fTime << " s" );
     }
 }
 
@@ -771,7 +784,7 @@ void SAL_CALL Player::setMute( sal_Bool bSet )
 {
     ::osl::MutexGuard aGuard(m_aMutex);
 
-    DBG( "set mute: %d muted: %d unmuted volume: %lf", bSet, mbMuted, mnUnmutedVolume );
+    SAL_INFO( "avmedia.gstreamer", AVVERSION "set mute: " << bSet << " muted: " << mbMuted << " unmuted volume: " << mnUnmutedVolume );
 
     // change the volume to 0 or the unmuted volume
     if(  mpPlaybin && mbMuted != bool(bSet) )
@@ -782,7 +795,7 @@ void SAL_CALL Player::setMute( sal_Bool bSet )
             nVolume = 0.0;
         }
 
-        g_object_set( G_OBJECT( mpPlaybin ), "volume", nVolume, NULL );
+        g_object_set( G_OBJECT( mpPlaybin ), "volume", nVolume, nullptr );
 
         mbMuted = bSet;
     }
@@ -807,12 +820,12 @@ void SAL_CALL Player::setVolumeDB( sal_Int16 nVolumeDB )
 
     mnUnmutedVolume = pow( 10.0, nVolumeDB / 20.0 );
 
-    DBG( "set volume: %d gst volume: %lf", nVolumeDB, mnUnmutedVolume );
+    SAL_INFO( "avmedia.gstreamer", AVVERSION "set volume: " << nVolumeDB << " gst volume: " << mnUnmutedVolume );
 
     // change volume
      if( !mbMuted && mpPlaybin )
      {
-         g_object_set( G_OBJECT( mpPlaybin ), "volume", (gdouble) mnUnmutedVolume, NULL );
+         g_object_set( G_OBJECT( mpPlaybin ), "volume", (gdouble) mnUnmutedVolume, nullptr );
      }
 }
 
@@ -828,7 +841,7 @@ sal_Int16 SAL_CALL Player::getVolumeDB()
     if( mpPlaybin ) {
         double nGstVolume = 0.0;
 
-        g_object_get( G_OBJECT( mpPlaybin ), "volume", &nGstVolume, NULL );
+        g_object_get( G_OBJECT( mpPlaybin ), "volume", &nGstVolume, nullptr );
 
         nVolumeDB = (sal_Int16) ( 20.0*log10 ( nGstVolume ) );
     }
@@ -847,18 +860,15 @@ awt::Size SAL_CALL Player::getPreferredPlayerWindowSize()
 
     if( maURL.isEmpty() )
     {
-        DBG( "%p Player::getPreferredPlayerWindowSize - empty URL => 0x0", this );
+        SAL_INFO( "avmedia.gstreamer", AVVERSION << this << " Player::getPreferredPlayerWindowSize - empty URL => 0x0" );
         return aSize;
     }
 
-    DBG( "%p pre-Player::getPreferredPlayerWindowSize, member %d x %d", this, mnWidth, mnHeight );
+    SAL_INFO( "avmedia.gstreamer", AVVERSION << this << " pre-Player::getPreferredPlayerWindowSize, member " << mnWidth << "x" << mnHeight );
 
-#if OSL_DEBUG_LEVEL > 2
-    osl::Condition::Result aResult =
-#endif
-                                 maSizeCondition.wait( std::chrono::seconds(10) );
+    osl::Condition::Result aResult = maSizeCondition.wait( std::chrono::seconds(10) );
 
-    DBG( "%p Player::getPreferredPlayerWindowSize after waitCondition %d, member %d x %d", this, aResult, mnWidth, mnHeight );
+    SAL_INFO( "avmedia.gstreamer", AVVERSION << this << " Player::getPreferredPlayerWindowSize after waitCondition " << aResult << ", member " << mnWidth << "x" << mnHeight );
 
     if( mnWidth != 0 && mnHeight != 0 ) {
         aSize.Width = mnWidth;
@@ -881,7 +891,7 @@ uno::Reference< ::media::XPlayerWindow > SAL_CALL Player::createPlayerWindow( co
     if( mbFakeVideo )
         preparePlaybin( maURL, nullptr );
 
-    DBG( "Player::createPlayerWindow %d %d length: %d", aSize.Width, aSize.Height, rArguments.getLength() );
+    SAL_INFO( "avmedia.gstreamer", AVVERSION << "Player::createPlayerWindow " << aSize.Width << "x" << aSize.Height << " length: " << rArguments.getLength() );
 
     if( aSize.Width > 0 && aSize.Height > 0 )
     {
@@ -898,11 +908,31 @@ uno::Reference< ::media::XPlayerWindow > SAL_CALL Player::createPlayerWindow( co
             OSL_ASSERT(pEnvData);
             if (pEnvData)
             {
-                mnWindowID = pEnvData->aWindow;
-                DBG( "set window id to %d XOverlay %p\n", (int)mnWindowID, mpXOverlay);
-                gst_element_set_state( mpPlaybin, GST_STATE_PAUSED );
-                if ( mpXOverlay != nullptr )
-                    gst_video_overlay_set_window_handle( mpXOverlay, mnWindowID );
+#if defined(ENABLE_GTKSINK)
+                GstElement *pVideosink = g_strcmp0(pEnvData->pToolkit, "gtk3") == 0 ?
+                                           gst_element_factory_make("gtksink", "gtksink") : nullptr;
+                if (pVideosink)
+                {
+                    mbUseGtkSink = true;
+                    g_object_get(pVideosink, "widget", &mpGtkWidget, nullptr);
+                    GtkWidget *pParent = (GtkWidget*)(pEnvData->pWidget);
+                    gtk_container_add (GTK_CONTAINER(pParent), mpGtkWidget);
+
+                    g_object_set( G_OBJECT( mpPlaybin ), "video-sink", pVideosink, nullptr);
+                    g_object_set( G_OBJECT( mpPlaybin ), "force-aspect-ratio", FALSE, nullptr);
+
+                    gtk_widget_show_all (pParent);
+                }
+                else
+#endif
+                {
+                    mbUseGtkSink = false;
+                    mnWindowID = pEnvData->aWindow;
+                    SAL_INFO( "avmedia.gstreamer", AVVERSION "set window id to " << (int)mnWindowID << " XOverlay " << mpXOverlay);
+                    gst_element_set_state( mpPlaybin, GST_STATE_PAUSED );
+                    if ( mpXOverlay != nullptr )
+                        gst_video_overlay_set_window_handle( mpXOverlay, mnWindowID );
+                }
             }
         }
     }
@@ -910,8 +940,6 @@ uno::Reference< ::media::XPlayerWindow > SAL_CALL Player::createPlayerWindow( co
     return xRet;
 }
 
-
-
 uno::Reference< media::XFrameGrabber > SAL_CALL Player::createFrameGrabber()
     throw (uno::RuntimeException, std::exception)
 {
@@ -921,7 +949,7 @@ uno::Reference< media::XFrameGrabber > SAL_CALL Player::createFrameGrabber()
 
     if( ( aPrefSize.Width > 0 ) && ( aPrefSize.Height > 0 ) )
         pFrameGrabber = FrameGrabber::create( maURL );
-    DBG( "created FrameGrabber %p", pFrameGrabber );
+    SAL_INFO( "avmedia.gstreamer", AVVERSION << "created FrameGrabber " << pFrameGrabber );
 
     return pFrameGrabber;
 }
diff --git a/avmedia/source/gstreamer/gstplayer.hxx b/avmedia/source/gstreamer/gstplayer.hxx
index 52095b0..ffc5133 100644
--- a/avmedia/source/gstreamer/gstplayer.hxx
+++ b/avmedia/source/gstreamer/gstplayer.hxx
@@ -27,6 +27,10 @@
 #include <cppuhelper/compbase.hxx>
 #include <cppuhelper/basemutex.hxx>
 
+#if defined(ENABLE_GTKSINK)
+#    include <gtk/gtk.h>
+#endif
+
 typedef struct _GstVideoOverlay GstVideoOverlay;
 
 namespace avmedia { namespace gstreamer {
@@ -83,6 +87,10 @@ protected:
 
     // Add elements and pipeline here
     GstElement*             mpPlaybin;  // the playbin is also a pipeline
+#if defined(ENABLE_GTKSINK)
+    GtkWidget*              mpGtkWidget;
+#endif
+    bool                    mbUseGtkSink;
     bool                    mbFakeVideo;
 
     gdouble                 mnUnmutedVolume;
diff --git a/include/vcl/sysdata.hxx b/include/vcl/sysdata.hxx
index 5ae9947..02e0c1e 100644
--- a/include/vcl/sysdata.hxx
+++ b/include/vcl/sysdata.hxx
@@ -72,6 +72,7 @@ struct SystemEnvData
     void*               pAppContext;    // the application context in use
     long                aShellWindow;   // the window of the frame's shell
     void*               pShellWidget;   // the frame's shell widget
+    const char*         pToolkit;       // the toolkit in use (gtk2 vs gtk3)
 #endif
 
     SystemEnvData()
@@ -95,6 +96,7 @@ struct SystemEnvData
         , pAppContext(nullptr)
         , aShellWindow(0)
         , pShellWidget(nullptr)
+        , pToolkit(nullptr)
 #endif
     {
     }
diff --git a/vcl/unx/gtk/gtkobject.cxx b/vcl/unx/gtk/gtkobject.cxx
index cc78ff5..18aa63a 100644
--- a/vcl/unx/gtk/gtkobject.cxx
+++ b/vcl/unx/gtk/gtkobject.cxx
@@ -63,6 +63,7 @@ GtkSalObject::GtkSalObject( GtkSalFrame* pParent, bool bShow )
         m_aSystemData.nScreen       = pParent->getXScreenNumber().getXScreen();
         m_aSystemData.pAppContext   = nullptr;
         m_aSystemData.pShellWidget  = GTK_WIDGET(pParent->getWindow());
+        m_aSystemData.pToolkit      = "gtk2";
 
         g_signal_connect( G_OBJECT(m_pSocket), "button-press-event", G_CALLBACK(signalButton), this );
         g_signal_connect( G_OBJECT(m_pSocket), "button-release-event", G_CALLBACK(signalButton), this );
diff --git a/vcl/unx/gtk/gtksalframe.cxx b/vcl/unx/gtk/gtksalframe.cxx
index d44207e..7a7c293 100644
--- a/vcl/unx/gtk/gtksalframe.cxx
+++ b/vcl/unx/gtk/gtksalframe.cxx
@@ -1022,6 +1022,7 @@ void GtkSalFrame::InitCommon()
     m_aSystemData.nScreen       = m_nXScreen.getXScreen();
     m_aSystemData.pAppContext   = nullptr;
     m_aSystemData.pShellWidget  = m_aSystemData.pWidget;
+    m_aSystemData.pToolkit      = "gtk2";
 
     m_bGraphics = false;
     m_pGraphics = NULL;
diff --git a/vcl/unx/gtk3/gtk3gtkframe.cxx b/vcl/unx/gtk3/gtk3gtkframe.cxx
index 925b185..3b34385 100644
--- a/vcl/unx/gtk3/gtk3gtkframe.cxx
+++ b/vcl/unx/gtk3/gtk3gtkframe.cxx
@@ -1097,6 +1097,7 @@ void GtkSalFrame::InitCommon()
     m_aSystemData.nScreen       = m_nXScreen.getXScreen();
     m_aSystemData.pAppContext   = nullptr;
     m_aSystemData.pShellWidget  = m_aSystemData.pWidget;
+    m_aSystemData.pToolkit      = "gtk3";
 
     m_bGraphics = false;
     m_pGraphics = nullptr;
diff --git a/vcl/unx/gtk3/gtk3gtkobject.cxx b/vcl/unx/gtk3/gtk3gtkobject.cxx
index 1154033..8f1c032 100644
--- a/vcl/unx/gtk3/gtk3gtkobject.cxx
+++ b/vcl/unx/gtk3/gtk3gtkobject.cxx
@@ -36,7 +36,7 @@ GtkSalObject::GtkSalObject( GtkSalFrame* pParent, bool bShow )
     if( pParent )
     {
         // our plug window
-        m_pSocket = gtk_drawing_area_new();
+        m_pSocket = gtk_grid_new();
         Show( bShow );
         // insert into container
         gtk_fixed_put( pParent->getFixedContainer(),
@@ -45,10 +45,6 @@ GtkSalObject::GtkSalObject( GtkSalFrame* pParent, bool bShow )
         // realize so we can get a window id
         gtk_widget_realize( m_pSocket );
 
-        // make it transparent; some plugins may not insert
-        // their own window here but use the socket window itself
-        gtk_widget_set_app_paintable( m_pSocket, TRUE );
-
         // system data
         m_aSystemData.nSize         = sizeof( SystemEnvData );
         m_aSystemData.aWindow       = pParent->GetNativeWindowHandle(m_pSocket);
@@ -58,6 +54,7 @@ GtkSalObject::GtkSalObject( GtkSalFrame* pParent, bool bShow )
         m_aSystemData.nScreen       = pParent->getXScreenNumber().getXScreen();
         m_aSystemData.pAppContext   = nullptr;
         m_aSystemData.pShellWidget  = GTK_WIDGET(pParent->getWindow());
+        m_aSystemData.pToolkit      = "gtk3";
 
         g_signal_connect( G_OBJECT(m_pSocket), "button-press-event", G_CALLBACK(signalButton), this );
         g_signal_connect( G_OBJECT(m_pSocket), "button-release-event", G_CALLBACK(signalButton), this );
-- 
2.7.1

