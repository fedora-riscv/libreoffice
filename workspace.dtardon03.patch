Index: filter/source/xslt/odf2xhtml/export/xhtml/body.xsl
===================================================================
--- filter/source/xslt/odf2xhtml/export/xhtml/body.xsl	(revision 276736)
+++ filter/source/xslt/odf2xhtml/export/xhtml/body.xsl	(working copy)
@@ -102,8 +102,8 @@
 				</xsl:when>
 				<xsl:otherwise>
 					<!-- As CSS writing-mode is not implemented by all browsers, a heuristic is done -->
-					<xsl:variable name="writingMode" select="key('writingModeStyles', 'test')"/>
-					<xsl:if test="contains($writingMode, 'rl')">
+					<xsl:variable name="writingModeTest" select="key('writingModeStyles', 'test')"/>
+					<xsl:if test="contains($writingModeTest, 'rl')">
 						<xsl:attribute name="dir">rtl</xsl:attribute>
 					</xsl:if>
 				</xsl:otherwise>
@@ -579,13 +579,13 @@
 		</xsl:variable>
 		<xsl:choose>
 			<xsl:when test="$tabIndent='NaN'">
-				<xsl:variable name="tabPosition">
+				<xsl:variable name="tabPositionTmp">
 					<xsl:call-template name="convert2cm">
 						<xsl:with-param name="value" select="$tabStops/style:tab-stop[last()]/@style:position"/>
 					</xsl:call-template>
 				</xsl:variable>
 					<!-- Heuristic: for every tab that is more than specified give a further 1 cm -->
-				<xsl:value-of select="$parentMarginLeft + $tabPosition + count($tabStops/style:tab-stop) - $tabCount"/>
+				<xsl:value-of select="$parentMarginLeft + $tabPositionTmp + count($tabStops/style:tab-stop) - $tabCount"/>
 			</xsl:when>
 			<xsl:otherwise>
 				<xsl:value-of select="$tabIndent"/>
diff -ru filter.orig/source/xslt/export/uof/odf2uof_text.xsl filter/source/xslt/export/uof/odf2uof_text.xsl
--- filter.orig/source/xslt/export/uof/odf2uof_text.xsl	2009-04-24 09:31:14.000000000 +0100
+++ filter/source/xslt/export/uof/odf2uof_text.xsl	2009-04-24 09:32:29.000000000 +0100
@@ -4029,13 +4029,7 @@
 									<xsl:element name="字:文本串">
 										<xsl:attribute name="uof:locID">t0109</xsl:attribute>
 										<xsl:attribute name="uof:attrList">标识符</xsl:attribute>
-										<xsl:variable name="stt">
-											<xsl:value-of select="./text:a"/>
-										</xsl:variable>
-										<xsl:variable name="end">
-											<xsl:value-of select="."/>
-										</xsl:variable>
-										<xsl:value-of select="substring-after($end,$stt)"/>
+										<xsl:value-of select="$bijiao"/>
 									</xsl:element>
 								</xsl:if>
 							</字:句>
Index: filter/source/xslt/odf2xhtml/export/xhtml/body.xsl
===================================================================
--- filter/source/xslt/odf2xhtml/export/xhtml/body.xsl	(revision 270524)
+++ filter/source/xslt/odf2xhtml/export/xhtml/body.xsl	(working copy)
@@ -1767,6 +1767,11 @@
 		<xsl:param name="minLabelWidth"/>
 		<xsl:param name="listIndent" />
 
+        <!-- The text:list-header shall not be labeled. According to ODF specification (sect. 4.3.2):
+            "The <text:list-header> element represents a list header and is a special kind of list item. It
+            contains one or more paragraphs that are displayed before a list. The paragraphs are formatted
+            like list items but they do not have a preceding number or bullet." -->
+        <xsl:variable name="isListHeader" select="boolean(self::text:list-header)"/>
 
 		<xsl:variable name="listIndentNew">
 			<xsl:choose>
@@ -1785,13 +1790,15 @@
 		<xsl:variable name="itemNumberNew">
 			<xsl:if test="$listStyle/text:list-style/text:list-level-style-number">
 				<xsl:choose>
-					<xsl:when test="$isEmptyList">
+					<xsl:when test="$isListHeader">0</xsl:when>
 						<!--  An empty list item (no text:h/text:p as child), will not count as item and does not increment the count.  -->
 						<xsl:variable name="tempItemNumber">
 							<xsl:choose>
 								<!-- siblings will be incremented by one -->
 								<xsl:when test="$itemNumber">
-									<xsl:value-of select="$itemNumber + 1"/>
+									<xsl:if test="not($isListHeader)">
+									    <xsl:value-of select="$itemNumber + 1"/>
+									</xsl:if>
 								</xsl:when>
 								<!-- if a higher list level had content the numbering starts with 1 -->
 								<xsl:when test="$isListNumberingReset and $listLevel &gt; 1">
@@ -1866,6 +1873,7 @@
 							<xsl:when test="$display">
 								<xsl:value-of select="$display"/>
 							</xsl:when>
+							<xsl:when test="$isListHeader">0</xsl:when>
 							<xsl:otherwise>1</xsl:otherwise>
 						</xsl:choose>
 					</xsl:with-param>
@@ -1876,9 +1884,10 @@
 		</xsl:variable>
 		<xsl:element name="li">
 			<xsl:choose>
-				<xsl:when test="$isEmptyList">
+				<xsl:when test="$isEmptyList or $isListHeader">
 					<xsl:apply-templates>
 						<xsl:with-param name="globalData" select="$globalData"/>
+						<xsl:with-param name="isNextLevelNumberingReset" select="$isListHeader or $isNextLevelNumberingReset"/>
 						<xsl:with-param name="itemLabel" select="$itemLabelNew"/>
 						<xsl:with-param name="listLevel" select="$listLevel + 1"/>
 						<xsl:with-param name="listStyleName" select="$listStyleName"/>
@@ -1889,7 +1898,7 @@
 					<xsl:apply-templates mode="list-item-children" select="*[1]">
 						<xsl:with-param name="globalData" select="$globalData"/>
 						<xsl:with-param name="isEmptyList" select="$isEmptyList"/>
-						<xsl:with-param name="isNextLevelNumberingReset" select="$isNextLevelNumberingReset"/>
+						<xsl:with-param name="isNextLevelNumberingReset" select="$isListHeader or $isNextLevelNumberingReset"/>
 						<!-- The new created label is given to the children -->
 						<xsl:with-param name="itemLabel" select="$itemLabelNew"/>
 						<xsl:with-param name="listLabelElement">
@@ -2088,7 +2097,7 @@
 
 
 	<!-- The Numbering start value (or offset from regular counteing) is used at the first item of offset,
-	but have to be reused on following item/headers with no text:start-value -->
+	but have to be reused on following items with no text:start-value -->
 	<xsl:template name="getItemNumber">
 		<xsl:param name="listLevel"/>
 		<xsl:param name="listLevelStyle"/>
@@ -2122,6 +2131,8 @@
 		<!-- E.g.: If a list level 2 number is searched, a level 3 with content found with only a level 1 parent with content,
 			the level 3 gets a 'pseudoLevel' -->
 		<xsl:param name="pseudoLevel" select="0" />
+		<xsl:variable name="isListHeader" select="boolean(self::text:list-header)"/>
+		<xsl:variable name="isEmptyList" select="not(*[name() = 'text:h' or name() = 'text:p'])"/>
 
 		<!-- set the next of preceding list items. Starting from the current to the next previous text:list-item -->
 		<xsl:variable name="precedingListItemOfSameLevelAndStyle" select="$precedingListItemsOfSameLevelAndStyle[$precedingListItemsOfSameLevelAndStyleCount - $IteratorSameLevelAndStyle + 1]"/>
@@ -2155,7 +2166,7 @@
 								<xsl:when test="$currentListLevel &lt; $listLevel">
 									<xsl:choose>
 										<!-- if it has content the counting is ended -->
-										<xsl:when test="*[name() = 'text:h' or name() = 'text:p']">
+										<xsl:when test="not($isEmptyList or $isListHeader)">
 											<!-- 2DO: Perhaps the children still have to be processed -->
 											<xsl:value-of select="$itemNumber + $pseudoLevel"/>
 										</xsl:when>
@@ -2210,7 +2221,7 @@
 										<xsl:with-param name="pseudoLevel">
 											<xsl:choose>
 												<!-- empty list item does not count -->
-												<xsl:when test="not(*[name() = 'text:h' or name() = 'text:p'])">
+												<xsl:when test="$isEmptyList or $isListHeader">
 													<xsl:value-of select="$pseudoLevel"/>
 												</xsl:when>
 												<xsl:otherwise>1</xsl:otherwise>
@@ -2243,11 +2254,14 @@
 		<xsl:param name="precedingListItemsOfSameStyleCount"/>
 		<xsl:param name="pseudoLevel" />
 
+		<xsl:variable name="isListHeader" select="boolean(self::text:list-header)"/>
+		<xsl:variable name="isEmptyList" select="not(*[name() = 'text:h' or name() = 'text:p'])"/>
+
 		<xsl:choose>
 			<xsl:when test="@text:start-value">
 				<xsl:choose>
-					<xsl:when test="not(*[name() = 'text:h' or name() = 'text:p'])">
-						<!-- empty list item does not count -->
+					<xsl:when test="$isEmptyList or $isListHeader">
+						<!-- empty list item does not count. neither does list header -->
 						<xsl:call-template name="countListItemTillStartValue">
 							<xsl:with-param name="IteratorSameLevelAndStyle" select="$IteratorSameLevelAndStyle + 1" />
 							<xsl:with-param name="IteratorSameStyle" select="$IteratorSameStyle + 1"/>
@@ -2269,8 +2283,8 @@
 			</xsl:when>
 			<xsl:when test="$listLevelStyle/@text:start-value">
 				<xsl:choose>
-					<xsl:when test="not(*[name() = 'text:h' or name() = 'text:p'])">
-						<!-- empty list item does not count -->
+					<xsl:when test="$isEmptyList or $isListHeader">
+						<!-- empty list item does not count. neither does list header -->
 						<xsl:call-template name="countListItemTillStartValue">
 							<xsl:with-param name="IteratorSameLevelAndStyle" select="$IteratorSameLevelAndStyle + 1" />
 							<xsl:with-param name="IteratorSameStyle" select="$IteratorSameStyle + 1"/>
@@ -2292,8 +2306,8 @@
 			</xsl:when>
 			<xsl:otherwise>
 				<xsl:choose>
-					<xsl:when test="not(*[name() = 'text:h' or name() = 'text:p'])">
-						<!-- empty list item does not count -->
+					<xsl:when test="$isEmptyList or $isListHeader">
+						<!-- empty list item does not count. neither does list header -->
 						<xsl:call-template name="countListItemTillStartValue">
 							<xsl:with-param name="IteratorSameLevelAndStyle" select="$IteratorSameLevelAndStyle + 1" />
 							<xsl:with-param name="IteratorSameStyle" select="$IteratorSameStyle + 1"/>
Index: filter/source/docbook/sofftodocbookheadings.xsl
===================================================================
--- filter/source/docbook/sofftodocbookheadings.xsl	(revision 270724)
+++ filter/source/docbook/sofftodocbookheadings.xsl	(working copy)
@@ -73,11 +73,6 @@
 			 match="text:h"
 			 use="generate-id(preceding::text:h[@text:level &lt; current()/@text:level][1])"/>
 
-	<!-- All those headings have not the lowest outline level (mapped to section1), but come before the first heading mapped to section1  -->
-	<xsl:key name="preludingHeadings"
-			 match="text:h"
-			 use="generate-id(following::text:h[@text:level = $section1_OutlineLevel][1])"/>
-
 	<!-- The key function "getHeadingsByOutline" returns all headings of a certain outline level -->
 	<xsl:key name="getHeadingsByOutline"
 			 match="text:h"
@@ -175,7 +170,7 @@
 				<xsl:text disable-output-escaping="yes">&lt;sect1&gt;</xsl:text>
 				<title></title>
 				<!-- create sections for all the first section1 preluding headings -->
-				<xsl:for-each select="key('preludingHeadings', generate-id())">
+                <xsl:for-each select="key('getHeadingsByOutline', $section1_OutlineLevel)[1]/preceding::text:h">
 					<xsl:call-template name="make-section">
 						<xsl:with-param name="previousSectionLevel" select="$section1_OutlineLevel"/>
 						<xsl:with-param name="currentSectionLevel">
@@ -1186,4 +1181,4 @@
 			<xsl:with-param name="whitespaces" select="8"/>
 		</xsl:call-template>
 	</xsl:template>
-</xsl:stylesheet>
\ No newline at end of file
+</xsl:stylesheet>
Index: filter/source/xslt/odf2xhtml/export/xhtml/body.xsl
===================================================================
--- filter/source/xslt/odf2xhtml/export/xhtml/body.xsl	(revision 276736)
+++ filter/source/xslt/odf2xhtml/export/xhtml/body.xsl	(working copy)
@@ -59,6 +59,13 @@
 	<xsl:key name="writingModeStyles" match="/*/office:styles/style:style/style:paragraph-properties/@style:writing-mode | /*/office:automatic-styles/style:style/style:paragraph-properties/@style:writing-mode" use="'test'"/>
 	<xsl:template name="create-body">
 		<xsl:param name="globalData"/>
+        <xsl:call-template name="create-body.collect-page-properties">
+            <xsl:with-param name="globalData" select="$globalData"/>
+        </xsl:call-template>
+    </xsl:template>
+
+    <xsl:template name="create-body.collect-page-properties">
+        <xsl:param name="globalData"/>
 
 		<!-- approximation to find the correct master page style (with page dimensions) -->
 		<xsl:variable name="masterPageNames">
@@ -75,10 +82,10 @@
 
 		<!-- Take the first of the masterpage list and get the according style:master-page element and find the @style:page-layout-name  -->
 		<xsl:variable name="pageLayoutName" select="key('masterPageElements', substring-before($masterPageNames,';'))/@style:page-layout-name"/>
-		<xsl:variable name="pageProperties">
+		<xsl:variable name="pagePropertiesRTF">
 			<xsl:choose>
 				<xsl:when test="not($pageLayoutName) or $pageLayoutName = ''">
-					<xsl:copy-of select="$globalData/styles-file/*/office:automatic-styles/style:page-layout[1]/style:page-layout-properties"/>
+					<xsl:value-of select="$globalData/styles-file/*/office:automatic-styles/style:page-layout[1]/style:page-layout-properties"/>
 				</xsl:when>
 				<xsl:otherwise>
 					<!-- Find the according style:page-layout and store the properties in a variable  -->
@@ -86,6 +93,35 @@
 				</xsl:otherwise>
 			</xsl:choose>
 		</xsl:variable>
+        <xsl:choose>
+            <xsl:when test="function-available('common:node-set')">
+                <xsl:call-template name="create-body.create">
+                    <xsl:with-param name="globalData" select="common:node-set($globalData)"/>
+                    <xsl:with-param name="pageProperties" select="common:node-set($pagePropertiesRTF)"/>
+                </xsl:call-template>
+            </xsl:when>
+            <xsl:when test="function-available('xalan:nodeset')">
+                <xsl:call-template name="create-body.create">
+                    <xsl:with-param name="globalData" select="xalan:nodeset($globalData)"/>
+                    <xsl:with-param name="pageProperties" select="xalan:nodeset($pagePropertiesRTF)"/>
+                </xsl:call-template>
+            </xsl:when>
+            <xsl:when test="function-available('xt:node-set')">
+                <xsl:call-template name="create-body.create">
+                    <xsl:with-param name="globalData" select="xt:node-set($globalData)"/>
+                    <xsl:with-param name="pageProperties" select="xt:node-set($pagePropertiesRTF)"/>
+                </xsl:call-template>
+            </xsl:when>
+            <xsl:otherwise>
+                <xsl:message terminate="yes">The required node-set function was not found!</xsl:message>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template name="create-body.create">
+        <xsl:param name="globalData"/>
+        <xsl:param name="pageProperties"/>
+		
 		<xsl:element name="body">
 			<!-- direction of text flow -->
 			<xsl:variable name="writingMode" select="$pageProperties/style:page-layout-properties/@style:writing-mode"/>
